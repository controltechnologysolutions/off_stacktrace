/**
 * Copyright (c) 2010 Zef Hemel <zef@zef.me>
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

if (typeof exports !== 'undefined') {
    exports.createPersistence = function () {
        return initPersistence({})
    }
    var singleton;
    if (typeof (exports.__defineGetter__) === 'function') {
        exports.__defineGetter__("persistence", function () {
            if (!singleton)
                singleton = exports.createPersistence();
            return singleton;
        });
    } else {
        Object.defineProperty(exports, "persistence", {
            get: function () {
                if (!singleton)
                    singleton = exports.createPersistence();
                return singleton;
            },
            enumerable: true, configurable: true
        });
    }

}
else {
    //window = window || {};
    if (!window) window = {};
    window.persistence = initPersistence(window.persistence || {});
}


function initPersistence(persistence) {
    if (persistence.isImmutable) // already initialized
        return persistence;

    /**
     * Check for immutable fields
     */
    persistence.isImmutable = function (fieldName) {
        return (fieldName == "id");
    };

    /**
     * Default implementation for entity-property
     */
    persistence.defineProp = function (scope, field, setterCallback, getterCallback) {
        if (typeof (scope.__defineSetter__) === 'function' && typeof (scope.__defineGetter__) === 'function') {
            scope.__defineSetter__(field, function (value) {
                setterCallback(value);
            });
            scope.__defineGetter__(field, function () {
                return getterCallback();
            });
        } else {
            Object.defineProperty(scope, field, {
                get: getterCallback,
                set: function (value) {
                    setterCallback(value);
                },
                enumerable: true, configurable: true
            });
        }
    };

    /**
     * Default implementation for entity-property setter
     */
    persistence.set = function (scope, fieldName, value) {
        if (persistence.isImmutable(fieldName)) throw new Error("immutable field: " + fieldName);
        scope[fieldName] = value;
    };

    /**
     * Default implementation for entity-property getter
     */
    persistence.get = function (arg1, arg2) {
        return (arguments.length == 1) ? arg1 : arg1[arg2];
    };



    (function () {
        var entityMeta = {};
        var entityClassCache = {};
        persistence.getEntityMeta = function () { return entityMeta; }

        // Per-session data
        persistence.trackedObjects = {};
        persistence.objectsToRemove = {};
        persistence.objectsRemoved = []; // {id: ..., type: ...}
        persistence.globalPropertyListeners = {}; // EntityType__prop -> QueryColleciton obj
        persistence.queryCollectionCache = {}; // entityName -> uniqueString -> QueryCollection

        persistence.getObjectsToRemove = function () { return this.objectsToRemove; };
        persistence.getTrackedObjects = function () { return this.trackedObjects; };

        // Public Extension hooks
        persistence.entityDecoratorHooks = [];
        persistence.flushHooks = [];
        persistence.schemaSyncHooks = [];

        // Enable debugging (display queries using console.log etc)
        persistence.debug = true;

        persistence.subscribeToGlobalPropertyListener = function (coll, entityName, property) {
            var key = entityName + '__' + property;
            if (key in this.globalPropertyListeners) {
                var listeners = this.globalPropertyListeners[key];
                for (var i = 0; i < listeners.length; i++) {
                    if (listeners[i] === coll) {
                        return;
                    }
                }
                this.globalPropertyListeners[key].push(coll);
            } else {
                this.globalPropertyListeners[key] = [coll];
            }
        }

        persistence.unsubscribeFromGlobalPropertyListener = function (coll, entityName, property) {
            var key = entityName + '__' + property;
            var listeners = this.globalPropertyListeners[key];
            for (var i = 0; i < listeners.length; i++) {
                if (listeners[i] === coll) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        }

        persistence.propertyChanged = function (obj, property, oldValue, newValue) {
            if (!this.trackedObjects[obj.id]) return; // not yet added, ignore for now

            var entityName = obj._type;
            var key = entityName + '__' + property;
            if (key in this.globalPropertyListeners) {
                var listeners = this.globalPropertyListeners[key];
                for (var i = 0; i < listeners.length; i++) {
                    var coll = listeners[i];
                    var dummyObj = obj._data;
                    dummyObj[property] = oldValue;
                    var matchedBefore = coll._filter.match(dummyObj);
                    dummyObj[property] = newValue;
                    var matchedAfter = coll._filter.match(dummyObj);
                    if (matchedBefore != matchedAfter) {
                        coll.triggerEvent('change', coll, obj);
                    }
                }
            }
        }

        persistence.objectRemoved = function (obj) {
            var entityName = obj._type;
            if (this.queryCollectionCache[entityName]) {
                var colls = this.queryCollectionCache[entityName];
                for (var key in colls) {
                    if (colls.hasOwnProperty(key)) {
                        var coll = colls[key];
                        if (coll._filter.match(obj)) { // matched the filter -> was part of collection
                            coll.triggerEvent('change', coll, obj);
                        }
                    }
                }
            }
        }

        /**
         * Retrieves metadata about entity, mostly for internal use
         */
        function getMeta(entityName) {
            return entityMeta[entityName];
        }

        persistence.getMeta = getMeta;


        /**
         * A database session
         */
        function Session(conn) {
            this.trackedObjects = {};
            this.objectsToRemove = {};
            this.objectsRemoved = [];
            this.globalPropertyListeners = {}; // EntityType__prop -> QueryColleciton obj
            this.queryCollectionCache = {}; // entityName -> uniqueString -> QueryCollection
            this.conn = conn;
        }

        Session.prototype = persistence; // Inherit everything from the root persistence object

        persistence.Session = Session;

        /**
         * Define an entity
         *
         * @param entityName
         *            the name of the entity (also the table name in the database)
         * @param fields
         *            an object with property names as keys and SQLite types as
         *            values, e.g. {name: "TEXT", age: "INT"}
         * @return the entity's constructor
         */
        persistence.define = function (entityName, fields) {
            if (entityMeta[entityName]) { // Already defined, ignore
                return getEntity(entityName);
            }
            var meta = {
                name: entityName,
                fields: fields,
                isMixin: false,
                indexes: [],
                hasMany: {},
                hasOne: {}
            };
            entityMeta[entityName] = meta;
            return getEntity(entityName);
        };

        /**
         * Checks whether an entity exists
         *
         * @param entityName
         *            the name of the entity (also the table name in the database)
         * @return `true` if the entity exists, otherwise `false`
         */
        persistence.isDefined = function (entityName) {
            return !!entityMeta[entityName];
        }

        /**
         * Define a mixin
         *
         * @param mixinName
         *            the name of the mixin
         * @param fields
         *            an object with property names as keys and SQLite types as
         *            values, e.g. {name: "TEXT", age: "INT"}
         * @return the entity's constructor
         */
        persistence.defineMixin = function (mixinName, fields) {
            var Entity = this.define(mixinName, fields);
            Entity.meta.isMixin = true;
            return Entity;
        };

        persistence.isTransaction = function (obj) {
            return !obj || (obj && obj.executeSql);
        };

        persistence.isSession = function (obj) {
            return !obj || (obj && obj.schemaSync);
        };

        /**
        *  Luiz: Changed here so that it behaves as add/update
        *
        *
         * Adds the object to tracked entities to be persisted
         *
         * @param obj
         *            the object to be tracked
         */
        persistence.add = function (obj) {
            if (!obj) {
                return;
            }
            var trackedObject = this.trackedObjects[obj.id];
            if (trackedObject) {
                if (trackedObject._dirtyProperties != obj._dirtyProperties) {
                    //letï¿½s replace the object with the newer one
                    this.trackedObjects[obj.id] = obj;
                }
            } else {
                //new item added
                this.trackedObjects[obj.id] = obj;
                if (obj._new) {
                    for (var p in obj._data) {
                        if (obj._data.hasOwnProperty(p)) {
                            this.propertyChanged(obj, p, undefined, obj._data[p]);
                        }
                    }
                }
            }
            return this;
        };

        /**
         * Marks the object to be removed (on next flush)
         * @param obj object to be removed
         */
        persistence.remove = function (obj) {
            if (obj._new) {
                delete this.trackedObjects[obj.id];
            } else {
                if (!this.objectsToRemove[obj.id]) {
                    this.objectsToRemove[obj.id] = obj;
                }
                this.objectsRemoved.push({ id: obj.id, entity: obj._type });
            }
            this.objectRemoved(obj);
            return this;
        };


        /**
         * Clean the persistence context of cached entities and such.
         */
        persistence.clean = function () {
            this.trackedObjects = {};
            this.objectsToRemove = {};
            this.objectsRemoved = [];
            this.globalPropertyListeners = {};
            this.queryCollectionCache = {};
        };

        /**
         * asynchronous sequential version of Array.prototype.forEach
         * @param array the array to iterate over
         * @param fn the function to apply to each item in the array, function
         *        has two argument, the first is the item value, the second a
         *        callback function
         * @param callback the function to call when the forEach has ended
         */
        persistence.asyncForEach = function (array, fn, callback) {


            array = array.slice(0); // Just to be sure
            function processOne() {
                var item = array.pop();
                fn(item, function (result, err) {
                    if (array.length > 0) {
                        processOne();
                    } else {
                        callback(result, err);
                    }
                });
            }
            if (array.length > 0) {
                processOne();
            } else {
                callback();
            }
        };

        /**
         * asynchronous parallel version of Array.prototype.forEach
         * @param array the array to iterate over
         * @param fn the function to apply to each item in the array, function
         *        has two argument, the first is the item value, the second a
         *        callback function
         * @param callback the function to call when the forEach has ended
         */
        persistence.asyncParForEach = function (array, fn, callback) {
            var completed = 0;
            var arLength = array.length;
            if (arLength === 0) {
                callback();
            }
            for (var i = 0; i < arLength; i++) {
                fn(array[i], function (result, err) {
                    completed++;
                    if (completed === arLength) {
                        callback(result, err);
                    }
                });
            }
        };

        /**
         * Logs a rich message in 'ERROR' level
         * 
         * @param String query 
         * @param [Object] args 
         * @param Object error 
         */
        persistence.defaultTransactionErrorHandler = function (query, args, error) {
            var msg = "Failed to execute query \"" + query + "\"";
            if (!!args) msg += " with arguments " + args;
            msg += " resulting in the error " + error;
            console.error(msg);
        };

        /**
         * Retrieves or creates an entity constructor function for a given
         * entity name
         * @return the entity constructor function to be invoked with `new fn()`
         */
        function getEntity(entityName) {
            if (entityClassCache[entityName]) {
                return entityClassCache[entityName];
            }
            var meta = entityMeta[entityName];

            /**
             * @constructor
             */
            function Entity(session, obj, noEvents) {
                var args = argspec.getArgs(arguments, [
                    { name: "session", optional: true, check: persistence.isSession, defaultValue: persistence },
                    { name: "obj", optional: true, check: function (obj) { return obj; }, defaultValue: {} }
                ]);
                if (meta.isMixin)
                    throw new Error("Cannot instantiate mixin");
                session = args.session;
                obj = args.obj;

                var that = this;
                this.id = obj.id || persistence.createUUID();
                this._new = true;
                this._type = entityName;
                this._dirtyProperties = {};
                this._data = {};
                this._data_obj = {}; // references to objects
                this._session = session || persistence;
                this.subscribers = {}; // observable

                for (var field in meta.fields) {
                    (function () {
                        if (meta.fields.hasOwnProperty(field)) {
                            var f = field; // Javascript scopes/closures SUCK
                            persistence.defineProp(that, f, function (val) {
                                // setterCallback
                                var oldValue = that._data[f];
                                if (oldValue !== val || (oldValue && val && oldValue.getTime && val.getTime)) { // Don't mark properties as dirty and trigger events unnecessarily
                                    that._data[f] = val;
                                    that._dirtyProperties[f] = oldValue;
                                    that.triggerEvent('set', that, f, val);
                                    that.triggerEvent('change', that, f, val);
                                    session.propertyChanged(that, f, oldValue, val);
                                }
                            }, function () {
                                // getterCallback
                                return that._data[f];
                            });
                            that._data[field] = defaultValue(meta.fields[field]);
                        }
                    }());
                }

                for (var it in meta.hasOne) {
                    if (meta.hasOne.hasOwnProperty(it)) {
                        (function () {
                            var ref = it;
                            var mixinClass = meta.hasOne[it].type.meta.isMixin ? ref + '_class' : null;
                            persistence.defineProp(that, ref, function (val) {
                                // setterCallback
                                var oldValue = that._data[ref];
                                var oldValueObj = that._data_obj[ref] || session.trackedObjects[that._data[ref]];
                                if (val == null) {
                                    that._data[ref] = null;
                                    that._data_obj[ref] = undefined;
                                    if (mixinClass)
                                        that[mixinClass] = '';
                                } else if (val.id) {
                                    that._data[ref] = val.id;
                                    that._data_obj[ref] = val;
                                    if (mixinClass)
                                        that[mixinClass] = val._type;
                                    session.add(val);
                                    session.add(that);
                                } else { // let's assume it's an id
                                    that._data[ref] = val;
                                }
                                that._dirtyProperties[ref] = oldValue;
                                that.triggerEvent('set', that, ref, val);
                                that.triggerEvent('change', that, ref, val);
                                // Inverse
                                if (meta.hasOne[ref].inverseProperty) {
                                    var newVal = that[ref];
                                    if (newVal) {
                                        var inverse = newVal[meta.hasOne[ref].inverseProperty];
                                        if (inverse.list && inverse._filter) {
                                            inverse.triggerEvent('change', that, ref, val);
                                        }
                                    }
                                    if (oldValueObj) {
                                        var inverse = oldValueObj[meta.hasOne[ref].inverseProperty];
                                        if (inverse.list && inverse._filter) {
                                            inverse.triggerEvent('change', that, ref, val);
                                        }
                                    }
                                }
                            }, function () {
                                // getterCallback
                                if (!that._data[ref]) {
                                    return null;
                                } else if (that._data_obj[ref] !== undefined) {
                                    return that._data_obj[ref];
                                } else if (that._data[ref] && session.trackedObjects[that._data[ref]]) {
                                    that._data_obj[ref] = session.trackedObjects[that._data[ref]];
                                    return that._data_obj[ref];
                                } else {
                                    throw new Error("Property '" + ref + "' of '" + meta.name + "' with id: " + that._data[ref] + " not fetched, either prefetch it or fetch it manually.");
                                }
                            });
                        }());
                    }
                }

                for (var it in meta.hasMany) {
                    if (meta.hasMany.hasOwnProperty(it)) {
                        (function () {
                            var coll = it;
                            if (meta.hasMany[coll].manyToMany) {
                                persistence.defineProp(that, coll, function (val) {
                                    // setterCallback
                                    if (val && val._items) {
                                        // Local query collection, just add each item
                                        // TODO: this is technically not correct, should clear out existing items too
                                        var items = val._items;
                                        for (var i = 0; i < items.length; i++) {
                                            persistence.get(that, coll).add(items[i]);
                                        }
                                    } else {
                                        throw new Error("Not yet supported.");
                                    }
                                }, function () {
                                    // getterCallback
                                    if (that._data[coll]) {
                                        return that._data[coll];
                                    } else {
                                        var rel = meta.hasMany[coll];
                                        var inverseMeta = rel.type.meta;
                                        var inv = inverseMeta.hasMany[rel.inverseProperty];
                                        var direct = rel.mixin ? rel.mixin.meta.name : meta.name;
                                        var inverse = inv.mixin ? inv.mixin.meta.name : inverseMeta.name;

                                        var queryColl = new persistence.ManyToManyDbQueryCollection(session, inverseMeta.name);
                                        queryColl.initManyToMany(that, coll);
                                        queryColl._manyToManyFetch = {
                                            table: rel.tableName,
                                            prop: direct + '_' + coll,
                                            inverseProp: inverse + '_' + rel.inverseProperty,
                                            id: that.id
                                        };
                                        that._data[coll] = queryColl;
                                        return session.uniqueQueryCollection(queryColl);
                                    }
                                });
                            } else { // one to many
                                persistence.defineProp(that, coll, function (val) {
                                    // setterCallback
                                    if (val && val._items) {
                                        // Local query collection, just add each item
                                        // TODO: this is technically not correct, should clear out existing items too
                                        var items = val._items;
                                        for (var i = 0; i < items.length; i++) {
                                            persistence.get(that, coll).add(items[i]);
                                        }
                                    } else {
                                        throw new Error("Not yet supported.");
                                    }
                                }, function () {
                                    // getterCallback
                                    if (that._data[coll]) {
                                        return that._data[coll];
                                    } else {
                                        var queryColl = session.uniqueQueryCollection(new persistence.DbQueryCollection(session, meta.hasMany[coll].type.meta.name).filter(meta.hasMany[coll].inverseProperty, '=', that));
                                        that._data[coll] = queryColl;
                                        return queryColl;
                                    }
                                });
                            }
                        }());
                    }
                }

                if (this.initialize) {
                    this.initialize();
                }

                for (var f in obj) {
                    if (obj.hasOwnProperty(f)) {
                        if (f !== 'id') {
                            persistence.set(that, f, obj[f]);
                        }
                    }
                }
            } // Entity

            Entity.prototype = new Observable();

            Entity.meta = meta;

            Entity.prototype.equals = function (other) {
                return this.id == other.id;
            };

            Entity.prototype.toJSON = function () {
                var json = { id: this.id };
                for (var p in this._data) {
                    if (this._data.hasOwnProperty(p)) {
                        if (typeof this._data[p] == "object" && this._data[p] != null) {
                            if (this._data[p].toJSON != undefined) {
                                json[p] = this._data[p].toJSON();
                            }
                        } else {
                            json[p] = this._data[p];
                        }
                    }
                }
                return json;
            };


            /**
             * Select a subset of data as a JSON structure (Javascript object)
             *
             * A property specification is passed that selects the
             * properties to be part of the resulting JSON object. Examples:
             *    ['id', 'name'] -> Will return an object with the id and name property of this entity
             *    ['*'] -> Will return an object with all the properties of this entity, not recursive
             *    ['project.name'] -> will return an object with a project property which has a name
             *                        property containing the project name (hasOne relationship)
             *    ['project.[id, name]'] -> will return an object with a project property which has an
             *                              id and name property containing the project name
             *                              (hasOne relationship)
             *    ['tags.name'] -> will return an object with an array `tags` property containing
             *                     objects each with a single property: name
             *
             * @param tx database transaction to use, leave out to start a new one
             * @param props a property specification
             * @param callback(result)
             */
            Entity.prototype.selectJSON = function (tx, props, callback) {
                var that = this;
                var args = argspec.getArgs(arguments, [
                    { name: "tx", optional: true, check: persistence.isTransaction, defaultValue: null },
                    { name: "props", optional: false },
                    { name: "callback", optional: false }
                ]);
                tx = args.tx;
                props = args.props;
                callback = args.callback;

                if (!tx) {
                    this._session.transaction(function (tx) {
                        that.selectJSON(tx, props, callback);
                    });
                    return;
                }
                var includeProperties = {};
                props.forEach(function (prop) {
                    var current = includeProperties;
                    var parts = prop.split('.');
                    for (var i = 0; i < parts.length; i++) {
                        var part = parts[i];
                        if (i === parts.length - 1) {
                            if (part === '*') {
                                current.id = true;
                                for (var p in meta.fields) {
                                    if (meta.fields.hasOwnProperty(p)) {
                                        current[p] = true;
                                    }
                                }
                                for (var p in meta.hasOne) {
                                    if (meta.hasOne.hasOwnProperty(p)) {
                                        current[p] = true;
                                    }
                                }
                                for (var p in meta.hasMany) {
                                    if (meta.hasMany.hasOwnProperty(p)) {
                                        current[p] = true;
                                    }
                                }
                            } else if (part[0] === '[') {
                                part = part.substring(1, part.length - 1);
                                var propList = part.split(/,\s*/);
                                propList.forEach(function (prop) {
                                    current[prop] = true;
                                });
                            } else {
                                current[part] = true;
                            }
                        } else {
                            current[part] = current[part] || {};
                            current = current[part];
                        }
                    }
                });
                buildJSON(this, tx, includeProperties, callback);
            };

            function buildJSON(that, tx, includeProperties, callback) {
                var session = that._session;
                var properties = [];
                var meta = getMeta(that._type);
                var fieldSpec = meta.fields;

                for (var p in includeProperties) {
                    if (includeProperties.hasOwnProperty(p)) {
                        properties.push(p);
                    }
                }

                var cheapProperties = [];
                var expensiveProperties = [];

                properties.forEach(function (p) {
                    if (includeProperties[p] === true && !meta.hasMany[p]) { // simple, loaded field
                        cheapProperties.push(p);
                    } else {
                        expensiveProperties.push(p);
                    }
                });

                var itemData = that._data;
                var item = {};

                cheapProperties.forEach(function (p) {
                    if (p === 'id') {
                        item.id = that.id;
                    } else if (meta.hasOne[p]) {
                        item[p] = itemData[p] ? { id: itemData[p] } : null;
                    } else {
                        item[p] = persistence.entityValToJson(itemData[p], fieldSpec[p]);
                    }
                });
                properties = expensiveProperties.slice();

                persistence.asyncForEach(properties, function (p, callback) {
                    if (meta.hasOne[p]) {
                        that.fetch(tx, p, function (obj) {
                            if (obj) {
                                buildJSON(obj, tx, includeProperties[p], function (result) {
                                    item[p] = result;
                                    callback();
                                });
                            } else {
                                item[p] = null;
                                callback();
                            }
                        });
                    } else if (meta.hasMany[p]) {
                        persistence.get(that, p).list(function (objs) {
                            item[p] = [];
                            persistence.asyncForEach(objs, function (obj, callback) {
                                var obj = objs.pop();
                                if (includeProperties[p] === true) {
                                    item[p].push({ id: obj.id });
                                    callback();
                                } else {
                                    buildJSON(obj, tx, includeProperties[p], function (result) {
                                        item[p].push(result);
                                        callback();
                                    });
                                }
                            }, callback);
                        });
                    }
                }, function () {
                    callback(item);
                });
            }; // End of buildJson

            Entity.prototype.fetch = function (tx, rel, callback) {
                var args = argspec.getArgs(arguments, [
                    { name: 'tx', optional: true, check: persistence.isTransaction, defaultValue: null },
                    { name: 'rel', optional: false, check: argspec.hasType('string') },
                    { name: 'callback', optional: false, check: argspec.isCallback() }
                ]);
                tx = args.tx;
                rel = args.rel;
                callback = args.callback;

                var that = this;
                var session = this._session;

                if (!tx) {
                    session.transaction(function (tx) {
                        that.fetch(tx, rel, callback);
                    });
                    return;
                }
                if (!this._data[rel]) { // null
                    if (callback) {
                        callback(null);
                    }
                } else if (this._data_obj[rel]) { // already loaded
                    if (callback) {
                        callback(this._data_obj[rel]);
                    }
                } else {
                    var type = meta.hasOne[rel].type;
                    if (type.meta.isMixin) {
                        type = getEntity(this._data[rel + '_class']);
                    }
                    type.load(session, tx, this._data[rel], function (obj) {
                        that._data_obj[rel] = obj;
                        if (callback) {
                            callback(obj);
                        }
                    });
                }
            };

            /**
             * Currently this is only required when changing JSON properties
             */
            Entity.prototype.markDirty = function (prop) {
                this._dirtyProperties[prop] = true;
            };

            /**
             * Returns a QueryCollection implementation matching all instances
             * of this entity in the database
             */
            Entity.all = function (session) {
                var args = argspec.getArgs(arguments, [
                    { name: 'session', optional: true, check: persistence.isSession, defaultValue: persistence }
                ]);
                session = args.session;
                return session.uniqueQueryCollection(new AllDbQueryCollection(session, entityName));
            };

            Entity.fromSelectJSON = function (session, tx, jsonObj, callback) {
                var args = argspec.getArgs(arguments, [
                    { name: 'session', optional: true, check: persistence.isSession, defaultValue: persistence },
                    { name: 'tx', optional: true, check: persistence.isTransaction, defaultValue: null },
                    { name: 'jsonObj', optional: false },
                    { name: 'callback', optional: false, check: argspec.isCallback() }
                ]);
                session = args.session;
                tx = args.tx;
                jsonObj = args.jsonObj;
                callback = args.callback;

                if (!tx) {
                    session.transaction(function (tx) {
                        Entity.fromSelectJSON(session, tx, jsonObj, callback);
                    });
                    return;
                }

                if (typeof jsonObj === 'string') {
                    jsonObj = JSON.parse(jsonObj);
                }

                if (!jsonObj) {
                    callback(null);
                    return;
                }

                function loadedObj(obj) {
                    if (!obj) {
                        obj = new Entity(session);
                        if (jsonObj.id) {
                            obj.id = jsonObj.id;
                        }
                    }
                    session.add(obj);
                    var expensiveProperties = [];
                    for (var p in jsonObj) {
                        if (jsonObj.hasOwnProperty(p)) {
                            if (p === 'id') {
                                continue;
                            } else if (meta.fields[p]) { // regular field
                                persistence.set(obj, p, persistence.jsonToEntityVal(jsonObj[p], meta.fields[p]));
                            } else if (meta.hasOne[p] || meta.hasMany[p]) {
                                expensiveProperties.push(p);
                            }
                        }
                    }
                    persistence.asyncForEach(expensiveProperties, function (p, callback) {
                        if (meta.hasOne[p]) {
                            meta.hasOne[p].type.fromSelectJSON(session, tx, jsonObj[p], function (result) {
                                persistence.set(obj, p, result);
                                callback();
                            });
                        } else if (meta.hasMany[p]) {
                            var coll = persistence.get(obj, p);
                            var ar = jsonObj[p].slice(0);
                            var PropertyEntity = meta.hasMany[p].type;
                            // get all current items
                            coll.list(tx, function (currentItems) {
                                persistence.asyncForEach(ar, function (item, callback) {
                                    PropertyEntity.fromSelectJSON(session, tx, item, function (result) {
                                        // Check if not already in collection
                                        for (var i = 0; i < currentItems.length; i++) {
                                            if (currentItems[i].id === result.id) {
                                                callback();
                                                return;
                                            }
                                        }
                                        coll.add(result);
                                        callback();
                                    });
                                }, function () {
                                    callback();
                                });
                            });
                        }
                    }, function () {
                        callback(obj);
                    });
                }
                if (jsonObj.id) {
                    Entity.load(session, tx, jsonObj.id, loadedObj);
                } else {
                    loadedObj(new Entity(session));
                }
            };

            Entity.load = function (session, tx, id, callback) {
                var args = argspec.getArgs(arguments, [
                    { name: 'session', optional: true, check: persistence.isSession, defaultValue: persistence },
                    { name: 'tx', optional: true, check: persistence.isTransaction, defaultValue: null },
                    { name: 'id', optional: false, check: argspec.hasType('string') },
                    { name: 'callback', optional: true, check: argspec.isCallback(), defaultValue: function () { } }
                ]);
                Entity.findBy(args.session, args.tx, "id", args.id, args.callback);
            };

            Entity.findBy = function (session, tx, property, value, callback) {
                var args = argspec.getArgs(arguments, [
                    { name: 'session', optional: true, check: persistence.isSession, defaultValue: persistence },
                    { name: 'tx', optional: true, check: persistence.isTransaction, defaultValue: null },
                    { name: 'property', optional: false, check: argspec.hasType('string') },
                    { name: 'value', optional: false },
                    { name: 'callback', optional: true, check: argspec.isCallback(), defaultValue: function () { } }
                ]);
                session = args.session;
                tx = args.tx;
                property = args.property;
                value = args.value;
                callback = args.callback;

                if (property === 'id' && value in session.trackedObjects) {
                    callback(session.trackedObjects[value]);
                    return;
                }
                if (!tx) {
                    session.transaction(function (tx) {
                        Entity.findBy(session, tx, property, value, callback);
                    });
                    return;
                }
                Entity.all(session).filter(property, "=", value).one(tx, function (obj) {
                    callback(obj);
                });
            }


            Entity.index = function (cols, options) {
                var opts = options || {};
                if (typeof cols == "string") {
                    cols = [cols];
                }
                opts.columns = cols;
                meta.indexes.push(opts);
            };

            /**
             * Declares a one-to-many or many-to-many relationship to another entity
             * Whether 1:N or N:M is chosed depends on the inverse declaration
             * @param collName the name of the collection (becomes a property of
               *   Entity instances
               * @param otherEntity the constructor function of the entity to define
               *   the relation to
               * @param inverseRel the name of the inverse property (to be) defined on otherEntity
               */
            Entity.hasMany = function (collName, otherEntity, invRel) {
                var otherMeta = otherEntity.meta;
                if (otherMeta.hasMany[invRel]) {
                    // other side has declared it as a one-to-many relation too -> it's in
                    // fact many-to-many
                    var tableName = meta.name + "_" + collName + "_" + otherMeta.name;
                    var inverseTableName = otherMeta.name + '_' + invRel + '_' + meta.name;

                    if (tableName > inverseTableName) {
                        // Some arbitrary way to deterministically decide which table to generate
                        tableName = inverseTableName;
                    }
                    meta.hasMany[collName] = {
                        type: otherEntity,
                        inverseProperty: invRel,
                        manyToMany: true,
                        tableName: tableName
                    };
                    otherMeta.hasMany[invRel] = {
                        type: Entity,
                        inverseProperty: collName,
                        manyToMany: true,
                        tableName: tableName
                    };
                    delete meta.hasOne[collName];
                    delete meta.fields[collName + "_class"]; // in case it existed
                } else {
                    meta.hasMany[collName] = {
                        type: otherEntity,
                        inverseProperty: invRel
                    };
                    otherMeta.hasOne[invRel] = {
                        type: Entity,
                        inverseProperty: collName
                    };
                    if (meta.isMixin)
                        otherMeta.fields[invRel + "_class"] = persistence.typeMapper ? persistence.typeMapper.classNameType : "TEXT";
                }
            }

            Entity.hasOne = function (refName, otherEntity, inverseProperty) {
                meta.hasOne[refName] = {
                    type: otherEntity,
                    inverseProperty: inverseProperty
                };
                if (otherEntity.meta.isMixin)
                    meta.fields[refName + "_class"] = persistence.typeMapper ? persistence.typeMapper.classNameType : "TEXT";
            };

            Entity.is = function (mixin) {
                var mixinMeta = mixin.meta;
                if (!mixinMeta.isMixin)
                    throw new Error("not a mixin: " + mixin);

                mixin.meta.mixedIns = mixin.meta.mixedIns || [];
                mixin.meta.mixedIns.push(meta);

                for (var field in mixinMeta.fields) {
                    if (mixinMeta.fields.hasOwnProperty(field))
                        meta.fields[field] = mixinMeta.fields[field];
                }
                for (var it in mixinMeta.hasOne) {
                    if (mixinMeta.hasOne.hasOwnProperty(it))
                        meta.hasOne[it] = mixinMeta.hasOne[it];
                }
                for (var it in mixinMeta.hasMany) {
                    if (mixinMeta.hasMany.hasOwnProperty(it)) {
                        mixinMeta.hasMany[it].mixin = mixin;
                        meta.hasMany[it] = mixinMeta.hasMany[it];
                    }
                }
            }

            // Allow decorator functions to add more stuff
            var fns = persistence.entityDecoratorHooks;
            for (var i = 0; i < fns.length; i++) {
                fns[i](Entity);
            }

            entityClassCache[entityName] = Entity;
            return Entity;
        }

        persistence.jsonToEntityVal = function (value, type) {
            if (type) {
                switch (type) {
                    case 'DATE':
                        if (typeof value === 'number') {
                            if (value > 1000000000000) {
                                // it's in milliseconds
                                return new Date(value);
                            } else {
                                return new Date(value * 1000);
                            }
                        } else {
                            return null;
                        }
                        break;
                    default:
                        return value;
                }
            } else {
                return value;
            }
        };

        persistence.entityValToJson = function (value, type) {
            if (type) {
                switch (type) {
                    case 'DATE':
                        if (value) {
                            value = new Date(value);
                            return Math.round(value.getTime() / 1000);
                        } else {
                            return null;
                        }
                        break;
                    default:
                        return value;
                }
            } else {
                return value;
            }
        };

        /**
         * Dumps the entire database into an object (that can be serialized to JSON for instance)
         * @param tx transaction to use, use `null` to start a new one
         * @param entities a list of entity constructor functions to serialize, use `null` for all
         * @param callback (object) the callback function called with the results.
         */
        persistence.dump = function (tx, entities, callback) {
            var args = argspec.getArgs(arguments, [
                { name: 'tx', optional: true, check: persistence.isTransaction, defaultValue: null },
                { name: 'entities', optional: true, check: function (obj) { return !obj || (obj && obj.length && !obj.apply); }, defaultValue: null },
                { name: 'callback', optional: false, check: argspec.isCallback(), defaultValue: function () { } }
            ]);
            tx = args.tx;
            entities = args.entities;
            callback = args.callback;

            if (!entities) { // Default: all entity types
                entities = [];
                for (var e in entityClassCache) {
                    if (entityClassCache.hasOwnProperty(e)) {
                        entities.push(entityClassCache[e]);
                    }
                }
            }

            var result = {};
            persistence.asyncParForEach(entities, function (Entity, callback) {
                Entity.all().list(tx, function (all) {
                    var items = [];
                    persistence.asyncParForEach(all, function (e, callback) {
                        var rec = {};
                        var fields = Entity.meta.fields;
                        for (var f in fields) {
                            if (fields.hasOwnProperty(f)) {
                                rec[f] = persistence.entityValToJson(e._data[f], fields[f]);
                            }
                        }
                        var refs = Entity.meta.hasOne;
                        for (var r in refs) {
                            if (refs.hasOwnProperty(r)) {
                                rec[r] = e._data[r];
                            }
                        }
                        var colls = Entity.meta.hasMany;
                        var collArray = [];
                        for (var coll in colls) {
                            if (colls.hasOwnProperty(coll)) {
                                collArray.push(coll);
                            }
                        }
                        persistence.asyncParForEach(collArray, function (collP, callback) {
                            var coll = persistence.get(e, collP);
                            coll.list(tx, function (results) {
                                rec[collP] = results.map(function (r) { return r.id; });
                                callback();
                            });
                        }, function () {
                            rec.id = e.id;
                            items.push(rec);
                            callback();
                        });
                    }, function () {
                        result[Entity.meta.name] = items;
                        callback();
                    });
                });
            }, function () {
                callback(result);
            });
        };

        /**
         * Loads a set of entities from a dump object
         * @param tx transaction to use, use `null` to start a new one
         * @param dump the dump object
         * @param callback the callback function called when done.
         */
        persistence.load = function (tx, dump, callback) {
            var args = argspec.getArgs(arguments, [
                { name: 'tx', optional: true, check: persistence.isTransaction, defaultValue: null },
                { name: 'dump', optional: false },
                { name: 'callback', optional: true, check: argspec.isCallback(), defaultValue: function () { } }
            ]);
            tx = args.tx;
            dump = args.dump;
            callback = args.callback;

            var finishedCount = 0;
            var collItemsToAdd = [];
            var session = this;
            for (var entityName in dump) {
                if (dump.hasOwnProperty(entityName)) {
                    var Entity = getEntity(entityName);
                    var fields = Entity.meta.fields;
                    var instances = dump[entityName];
                    for (var i = 0; i < instances.length; i++) {
                        var instance = instances[i];
                        var ent = new Entity();
                        ent.id = instance.id;
                        for (var p in instance) {
                            if (instance.hasOwnProperty(p)) {
                                if (persistence.isImmutable(p)) {
                                    ent[p] = instance[p];
                                } else if (Entity.meta.hasMany[p]) { // collection
                                    var many = Entity.meta.hasMany[p];
                                    if (many.manyToMany && Entity.meta.name < many.type.meta.name) { // Arbitrary way to avoid double adding
                                        continue;
                                    }
                                    var coll = persistence.get(ent, p);
                                    if (instance[p].length > 0) {
                                        instance[p].forEach(function (it) {
                                            collItemsToAdd.push({ Entity: Entity, coll: coll, id: it });
                                        });
                                    }
                                } else {
                                    persistence.set(ent, p, persistence.jsonToEntityVal(instance[p], fields[p]));
                                }
                            }
                        }
                        this.add(ent);
                    }
                }
            }
            session.flush(tx, function () {
                persistence.asyncForEach(collItemsToAdd, function (collItem, callback) {
                    collItem.Entity.load(session, tx, collItem.id, function (obj) {
                        collItem.coll.add(obj);
                        callback();
                    });
                }, function () {
                    session.flush(tx, callback);
                });
            });
        };

        /**
         * Dumps the entire database to a JSON string
         * @param tx transaction to use, use `null` to start a new one
         * @param entities a list of entity constructor functions to serialize, use `null` for all
         * @param callback (jsonDump) the callback function called with the results.
         */
        persistence.dumpToJson = function (tx, entities, callback) {
            var args = argspec.getArgs(arguments, [
                { name: 'tx', optional: true, check: persistence.isTransaction, defaultValue: null },
                { name: 'entities', optional: true, check: function (obj) { return obj && obj.length && !obj.apply; }, defaultValue: null },
                { name: 'callback', optional: false, check: argspec.isCallback(), defaultValue: function () { } }
            ]);
            tx = args.tx;
            entities = args.entities;
            callback = args.callback;
            this.dump(tx, entities, function (obj) {
                callback(JSON.stringify(obj));
            });
        };

        /**
         * Loads data from a JSON string (as dumped by `dumpToJson`)
         * @param tx transaction to use, use `null` to start a new one
         * @param jsonDump JSON string
         * @param callback the callback function called when done.
         */
        persistence.loadFromJson = function (tx, jsonDump, callback) {
            var args = argspec.getArgs(arguments, [
                { name: 'tx', optional: true, check: persistence.isTransaction, defaultValue: null },
                { name: 'jsonDump', optional: false },
                { name: 'callback', optional: true, check: argspec.isCallback(), defaultValue: function () { } }
            ]);
            tx = args.tx;
            jsonDump = args.jsonDump;
            callback = args.callback;
            this.load(tx, JSON.parse(jsonDump), callback);
        };


        /**
         * Generates a UUID according to http://www.ietf.org/rfc/rfc4122.txt
         */
        function createUUID() {
            if (persistence.typeMapper && persistence.typeMapper.newUuid) {
                return persistence.typeMapper.newUuid();
            }
            var s = [];
            var hexDigits = "0123456789ABCDEF";
            for (var i = 0; i < 32; i++) {
                s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
            }
            s[12] = "4";
            s[16] = hexDigits.substr((s[16] & 0x3) | 0x8, 1);

            var uuid = s.join("");
            return uuid;
        }

        persistence.createUUID = createUUID;


        function defaultValue(type) {
            if (persistence.typeMapper && persistence.typeMapper.defaultValue) {
                return persistence.typeMapper.defaultValue(type);
            }
            switch (type) {
                case "TEXT": return "";
                case "BOOL": return false;
                default:
                    if (type.indexOf("INT") !== -1) {
                        return 0;
                    } else if (type.indexOf("CHAR") !== -1) {
                        return "";
                    } else {
                        return null;
                    }
            }
        }

        function arrayContains(ar, item) {
            var l = ar.length;
            for (var i = 0; i < l; i++) {
                var el = ar[i];
                if (el.equals && el.equals(item)) {
                    return true;
                } else if (el === item) {
                    return true;
                }
            }
            return false;
        }

        function arrayRemove(ar, item) {
            var l = ar.length;
            for (var i = 0; i < l; i++) {
                var el = ar[i];
                if (el.equals && el.equals(item)) {
                    ar.splice(i, 1);
                    return;
                } else if (el === item) {
                    ar.splice(i, 1);
                    return;
                }
            }
        }

        ////////////////// QUERY COLLECTIONS \\\\\\\\\\\\\\\\\\\\\\\

        function Subscription(obj, eventType, fn) {
            this.obj = obj;
            this.eventType = eventType;
            this.fn = fn;
        }

        Subscription.prototype.unsubscribe = function () {
            this.obj.removeEventListener(this.eventType, this.fn);
        };

        /**
         * Simple observable function constructor
         * @constructor
         */
        function Observable() {
            this.subscribers = {};
        }

        Observable.prototype.addEventListener = function (eventType, fn) {
            if (!this.subscribers[eventType]) {
                this.subscribers[eventType] = [];
            }
            this.subscribers[eventType].push(fn);
            return new Subscription(this, eventType, fn);
        };

        Observable.prototype.removeEventListener = function (eventType, fn) {
            var subscribers = this.subscribers[eventType];
            for (var i = 0; i < subscribers.length; i++) {
                if (subscribers[i] == fn) {
                    this.subscribers[eventType].splice(i, 1);
                    return true;
                }
            }
            return false;
        };

        Observable.prototype.triggerEvent = function (eventType) {
            if (!this.subscribers[eventType]) { // No subscribers to this event type
                return;
            }
            var subscribers = this.subscribers[eventType].slice(0);
            for (var i = 0; i < subscribers.length; i++) {
                subscribers[i].apply(null, arguments);
            }
        };

        /*
         * Each filter has 4 methods:
         * - sql(prefix, values) -- returns a SQL representation of this filter,
         *     possibly pushing additional query arguments to `values` if ?'s are used
         *     in the query
         * - match(o) -- returns whether the filter matches the object o.
         * - makeFit(o) -- attempts to adapt the object o in such a way that it matches
         *     this filter.
         * - makeNotFit(o) -- the oppositive of makeFit, makes the object o NOT match
         *     this filter
         */

        /**
         * Default filter that does not filter on anything
         * currently it generates a 1=1 SQL query, which is kind of ugly
         */
        function NullFilter() {
        }

        NullFilter.prototype.match = function (o) {
            return true;
        };

        NullFilter.prototype.makeFit = function (o) {
        };

        NullFilter.prototype.makeNotFit = function (o) {
        };

        NullFilter.prototype.toUniqueString = function () {
            return "NULL";
        };

        NullFilter.prototype.subscribeGlobally = function () { };

        NullFilter.prototype.unsubscribeGlobally = function () { };

        /**
         * Filter that makes sure that both its left and right filter match
         * @param left left-hand filter object
         * @param right right-hand filter object
         */
        function AndFilter(left, right) {
            this.left = left;
            this.right = right;
        }

        AndFilter.prototype.match = function (o) {
            return this.left.match(o) && this.right.match(o);
        };

        AndFilter.prototype.makeFit = function (o) {
            this.left.makeFit(o);
            this.right.makeFit(o);
        };

        AndFilter.prototype.makeNotFit = function (o) {
            this.left.makeNotFit(o);
            this.right.makeNotFit(o);
        };

        AndFilter.prototype.toUniqueString = function () {
            return this.left.toUniqueString() + " AND " + this.right.toUniqueString();
        };

        AndFilter.prototype.subscribeGlobally = function (coll, entityName) {
            this.left.subscribeGlobally(coll, entityName);
            this.right.subscribeGlobally(coll, entityName);
        };

        AndFilter.prototype.unsubscribeGlobally = function (coll, entityName) {
            this.left.unsubscribeGlobally(coll, entityName);
            this.right.unsubscribeGlobally(coll, entityName);
        };

        /**
         * Filter that makes sure that either its left and right filter match
         * @param left left-hand filter object
         * @param right right-hand filter object
         */
        function OrFilter(left, right) {
            this.left = left;
            this.right = right;
        }

        OrFilter.prototype.match = function (o) {
            return this.left.match(o) || this.right.match(o);
        };

        OrFilter.prototype.makeFit = function (o) {
            this.left.makeFit(o);
            this.right.makeFit(o);
        };

        OrFilter.prototype.makeNotFit = function (o) {
            this.left.makeNotFit(o);
            this.right.makeNotFit(o);
        };

        OrFilter.prototype.toUniqueString = function () {
            return this.left.toUniqueString() + " OR " + this.right.toUniqueString();
        };

        OrFilter.prototype.subscribeGlobally = function (coll, entityName) {
            this.left.subscribeGlobally(coll, entityName);
            this.right.subscribeGlobally(coll, entityName);
        };

        OrFilter.prototype.unsubscribeGlobally = function (coll, entityName) {
            this.left.unsubscribeGlobally(coll, entityName);
            this.right.unsubscribeGlobally(coll, entityName);
        };

        /**
         * Filter that checks whether a certain property matches some value, based on an
         * operator. Supported operators are '=', '!=', '<', '<=', '>' and '>='.
         * @param property the property name
         * @param operator the operator to compare with
         * @param value the literal value to compare to
         */
        function PropertyFilter(property, operator, value) {
            this.property = property;
            this.operator = operator.toLowerCase();
            this.value = value;
        }

        PropertyFilter.prototype.match = function (o) {
            var value = this.value;
            var propValue = persistence.get(o, this.property);
            if (value && value.getTime) { // DATE
                // TODO: Deal with arrays of dates for 'in' and 'not in'
                value = Math.round(value.getTime() / 1000) * 1000; // Deal with precision
                if (propValue && propValue.getTime) { // DATE
                    propValue = Math.round(propValue.getTime() / 1000) * 1000; // Deal with precision
                }
            }
            switch (this.operator) {
                case '=':
                    return propValue === value;
                    break;
                case '!=':
                    return propValue !== value;
                    break;
                case '<':
                    return propValue < value;
                    break;
                case '<=':
                    return propValue <= value;
                    break;
                case '>':
                    return propValue > value;
                    break;
                case '>=':
                    return propValue >= value;
                    break;
                case 'in':
                    return arrayContains(value, propValue);
                    break;
                case 'not in':
                    return !arrayContains(value, propValue);
                    break;
            }
        };

        PropertyFilter.prototype.makeFit = function (o) {
            if (this.operator === '=') {
                persistence.set(o, this.property, this.value);
            } else {
                throw new Error("Sorry, can't perform makeFit for other filters than =");
            }
        };

        PropertyFilter.prototype.makeNotFit = function (o) {
            if (this.operator === '=') {
                persistence.set(o, this.property, null);
            } else {
                throw new Error("Sorry, can't perform makeNotFit for other filters than =");
            }
        };

        PropertyFilter.prototype.subscribeGlobally = function (coll, entityName) {
            persistence.subscribeToGlobalPropertyListener(coll, entityName, this.property);
        };

        PropertyFilter.prototype.unsubscribeGlobally = function (coll, entityName) {
            persistence.unsubscribeFromGlobalPropertyListener(coll, entityName, this.property);
        };

        PropertyFilter.prototype.toUniqueString = function () {
            var val = this.value;
            if (val && val._type) {
                val = val.id;
            }
            return this.property + this.operator + val;
        };

        persistence.NullFilter = NullFilter;
        persistence.AndFilter = AndFilter;
        persistence.OrFilter = OrFilter;
        persistence.PropertyFilter = PropertyFilter;

        /**
         * Ensure global uniqueness of query collection object
         */
        persistence.uniqueQueryCollection = function (coll) {
            var entityName = coll._entityName;
            if (coll._items) { // LocalQueryCollection
                return coll;
            }
            if (!this.queryCollectionCache[entityName]) {
                this.queryCollectionCache[entityName] = {};
            }
            return coll;
            //      var uniqueString = coll.toUniqueString();
            //      if(!this.queryCollectionCache[entityName][uniqueString]) {
            //        this.queryCollectionCache[entityName][uniqueString] = coll;
            //      }
            //      return this.queryCollectionCache[entityName][uniqueString];
        }

        /**
         * The constructor function of the _abstract_ QueryCollection
         * DO NOT INSTANTIATE THIS
         * @constructor
         */
        function QueryCollection() {
        }

        QueryCollection.prototype = new Observable();

        QueryCollection.prototype.oldAddEventListener = QueryCollection.prototype.addEventListener;

        QueryCollection.prototype.setupSubscriptions = function () {
            this._filter.subscribeGlobally(this, this._entityName);
        };

        QueryCollection.prototype.teardownSubscriptions = function () {
            this._filter.unsubscribeGlobally(this, this._entityName);
        };

        QueryCollection.prototype.addEventListener = function (eventType, fn) {
            var that = this;
            var subscription = this.oldAddEventListener(eventType, fn);
            if (this.subscribers[eventType].length === 1) { // first subscriber
                this.setupSubscriptions();
            }
            subscription.oldUnsubscribe = subscription.unsubscribe;
            subscription.unsubscribe = function () {
                this.oldUnsubscribe();

                if (that.subscribers[eventType].length === 0) { // last subscriber
                    that.teardownSubscriptions();
                }
            };
            return subscription;
        };

        /**
         * Function called when session is flushed, returns list of SQL queries to execute
         * (as [query, arg] tuples)
         */
        QueryCollection.prototype.persistQueries = function () { return []; };

        /**
         * Invoked by sub-classes to initialize the query collection
         */
        QueryCollection.prototype.init = function (session, entityName, constructor) {
            this._filter = new NullFilter();
            this._orderColumns = []; // tuples of [column, ascending]
            this._prefetchFields = [];
            this._entityName = entityName;
            this._constructor = constructor;
            this._limit = -1;
            this._skip = 0;
            this._reverse = false;
            this._session = session || persistence;
            // For observable
            this.subscribers = {};
        }

        QueryCollection.prototype.toUniqueString = function () {
            var s = this._constructor.name + ": " + this._entityName;
            s += '|Filter:';
            var values = [];
            s += this._filter.toUniqueString();
            s += '|Values:';
            for (var i = 0; i < values.length; i++) {
                s += values + "|^|";
            }
            s += '|Order:';
            for (var i = 0; i < this._orderColumns.length; i++) {
                var col = this._orderColumns[i];
                s += col[0] + ", " + col[1] + ", " + col[2];
            }
            s += '|Prefetch:';
            for (var i = 0; i < this._prefetchFields.length; i++) {
                s += this._prefetchFields[i];
            }
            s += '|Limit:';
            s += this._limit;
            s += '|Skip:';
            s += this._skip;
            s += '|Reverse:';
            s += this._reverse;
            return s;
        };

        /**
         * Creates a clone of this query collection
         * @return a clone of the collection
         */
        QueryCollection.prototype.clone = function (cloneSubscribers) {
            var c = new (this._constructor)(this._session, this._entityName);
            c._filter = this._filter;
            c._prefetchFields = this._prefetchFields.slice(0); // clone
            c._orderColumns = this._orderColumns.slice(0);
            c._limit = this._limit;
            c._skip = this._skip;
            c._reverse = this._reverse;
            if (cloneSubscribers) {
                var subscribers = {};
                for (var eventType in this.subscribers) {
                    if (this.subscribers.hasOwnProperty(eventType)) {
                        subscribers[eventType] = this.subscribers[eventType].slice(0);
                    }
                }
                c.subscribers = subscribers; //this.subscribers;
            } else {
                c.subscribers = this.subscribers;
            }
            return c;
        };

        /**
         * Returns a new query collection with a property filter condition added
         * @param property the property to filter on
         * @param operator the operator to use
         * @param value the literal value that the property should match
         * @return the query collection with the filter added
         */
        QueryCollection.prototype.filter = function (property, operator, value) {
            var c = this.clone(true);
            c._filter = new AndFilter(this._filter, new PropertyFilter(property,
                operator, value));
            // Add global listener (TODO: memory leak waiting to happen!)
            var session = this._session;
            c = session.uniqueQueryCollection(c);
            //session.subscribeToGlobalPropertyListener(c, this._entityName, property);
            return session.uniqueQueryCollection(c);
        };

        /**
         * Returns a new query collection with an OR condition between the
         * current filter and the filter specified as argument
         * @param filter the other filter
         * @return the new query collection
         */
        QueryCollection.prototype.or = function (filter) {
            var c = this.clone(true);
            c._filter = new OrFilter(this._filter, filter);
            return this._session.uniqueQueryCollection(c);
        };

        /**
         * Returns a new query collection with an AND condition between the
         * current filter and the filter specified as argument
         * @param filter the other filter
         * @return the new query collection
         */
        QueryCollection.prototype.and = function (filter) {
            var c = this.clone(true);
            c._filter = new AndFilter(this._filter, filter);
            return this._session.uniqueQueryCollection(c);
        };

        /**
         * Returns a new query collection with an ordering imposed on the collection
         * @param property the property to sort on
         * @param ascending should the order be ascending (= true) or descending (= false)
         * @param caseSensitive should the order be case sensitive (= true) or case insensitive (= false)
         *        note: using case insensitive ordering for anything other than TEXT fields yields
         *        undefinded behavior
         * @return the query collection with imposed ordering
         */
        QueryCollection.prototype.order = function (property, ascending, caseSensitive) {
            ascending = ascending === undefined ? true : ascending;
            caseSensitive = caseSensitive === undefined ? true : caseSensitive;
            var c = this.clone();
            c._orderColumns.push([property, ascending, caseSensitive]);
            return this._session.uniqueQueryCollection(c);
        };

        /**
         * Returns a new query collection will limit its size to n items
         * @param n the number of items to limit it to
         * @return the limited query collection
         */
        QueryCollection.prototype.limit = function (n) {
            var c = this.clone();
            c._limit = n;
            return this._session.uniqueQueryCollection(c);
        };

        /**
         * Returns a new query collection which will skip the first n results
         * @param n the number of results to skip
         * @return the query collection that will skip n items
         */
        QueryCollection.prototype.skip = function (n) {
            var c = this.clone();
            c._skip = n;
            return this._session.uniqueQueryCollection(c);
        };

        /**
         * Returns a new query collection which reverse the order of the result set
         * @return the query collection that will reverse its items
         */
        QueryCollection.prototype.reverse = function () {
            var c = this.clone();
            c._reverse = true;
            return this._session.uniqueQueryCollection(c);
        };

        /**
         * Returns a new query collection which will prefetch a certain object relationship.
         * Only works with 1:1 and N:1 relations.
         * Relation must target an entity, not a mix-in.
         * @param rel the relation name of the relation to prefetch
         * @return the query collection prefetching `rel`
         */
        QueryCollection.prototype.prefetch = function (rel) {
            var c = this.clone();
            c._prefetchFields.push(rel);
            return this._session.uniqueQueryCollection(c);
        };


        /**
         * Select a subset of data, represented by this query collection as a JSON
         * structure (Javascript object)
         *
         * @param tx database transaction to use, leave out to start a new one
         * @param props a property specification
         * @param callback(result)
         */
        QueryCollection.prototype.selectJSON = function (tx, props, callback) {
            var args = argspec.getArgs(arguments, [
                { name: "tx", optional: true, check: persistence.isTransaction, defaultValue: null },
                { name: "props", optional: false },
                { name: "callback", optional: false }
            ]);
            var session = this._session;
            var that = this;
            tx = args.tx;
            props = args.props;
            callback = args.callback;

            if (!tx) {
                session.transaction(function (tx) {
                    that.selectJSON(tx, props, callback);
                });
                return;
            }
            var Entity = getEntity(this._entityName);
            // TODO: This could do some clever prefetching to make it more efficient
            this.list(function (items) {
                var resultArray = [];
                persistence.asyncForEach(items, function (item, callback) {
                    item.selectJSON(tx, props, function (obj) {
                        resultArray.push(obj);
                        callback();
                    });
                }, function () {
                    callback(resultArray);
                });
            });
        };

        /**
         * Adds an object to a collection
         * @param obj the object to add
         */
        QueryCollection.prototype.add = function (obj) {
            if (!obj.id || !obj._type) {
                throw new Error("Cannot add object of non-entity type onto collection.");
            }
            this._session.add(obj);
            this._filter.makeFit(obj);
            this.triggerEvent('add', this, obj);
            this.triggerEvent('change', this, obj);
        }

        /**
         * Adds an an array of objects to a collection
         * @param obj the object to add
         */
        QueryCollection.prototype.addAll = function (objs) {
            for (var i = 0; i < objs.length; i++) {
                var obj = objs[i];
                this._session.add(obj);
                this._filter.makeFit(obj);
                this.triggerEvent('add', this, obj);
            }
            this.triggerEvent('change', this);
        }

        /**
         * Removes an object from a collection
         * @param obj the object to remove from the collection
         */
        QueryCollection.prototype.remove = function (obj) {
            if (!obj.id || !obj._type) {
                throw new Error("Cannot remove object of non-entity type from collection.");
            }
            this._filter.makeNotFit(obj);
            this.triggerEvent('remove', this, obj);
            this.triggerEvent('change', this, obj);
        }


        /**
         * A database implementation of the QueryCollection
         * @param entityName the name of the entity to create the collection for
         * @constructor
         */
        function DbQueryCollection(session, entityName) {
            this.init(session, entityName, DbQueryCollection);
        }

        /**
         * Execute a function for each item in the list
         * @param tx the transaction to use (or null to open a new one)
         * @param eachFn (elem) the function to be executed for each item
         */
        QueryCollection.prototype.each = function (tx, eachFn) {
            var args = argspec.getArgs(arguments, [
                { name: 'tx', optional: true, check: persistence.isTransaction, defaultValue: null },
                { name: 'eachFn', optional: true, check: argspec.isCallback() }
            ]);
            tx = args.tx;
            eachFn = args.eachFn;

            this.list(tx, function (results) {
                for (var i = 0; i < results.length; i++) {
                    eachFn(results[i]);
                }
            });
        }

        // Alias
        QueryCollection.prototype.forEach = QueryCollection.prototype.each;

        QueryCollection.prototype.one = function (tx, oneFn) {
            var args = argspec.getArgs(arguments, [
                { name: 'tx', optional: true, check: persistence.isTransaction, defaultValue: null },
                { name: 'oneFn', optional: false, check: argspec.isCallback() }
            ]);
            tx = args.tx;
            oneFn = args.oneFn;

            var that = this;

            this.limit(1).list(tx, function (results) {
                if (results.length === 0) {
                    oneFn(null);
                } else {
                    oneFn(results[0]);
                }
            });
        }

        DbQueryCollection.prototype = new QueryCollection();


        /**
         * An implementation of QueryCollection, that is used
         * to represent all instances of an entity type
         * @constructor
         */
        function AllDbQueryCollection(session, entityName) {
            this.init(session, entityName, AllDbQueryCollection);
        }

        AllDbQueryCollection.prototype = new DbQueryCollection();

        AllDbQueryCollection.prototype.add = function (obj) {
            this._session.add(obj);
            this.triggerEvent('add', this, obj);
            this.triggerEvent('change', this, obj);
        };

        AllDbQueryCollection.prototype.remove = function (obj) {
            this._session.remove(obj);
            this.triggerEvent('remove', this, obj);
            this.triggerEvent('change', this, obj);
        };

        /**
         * A ManyToMany implementation of QueryCollection
         * @constructor
         */
        function ManyToManyDbQueryCollection(session, entityName) {
            this.init(session, entityName, persistence.ManyToManyDbQueryCollection);
            this._localAdded = [];
            this._localRemoved = [];
        }

        ManyToManyDbQueryCollection.prototype = new DbQueryCollection();

        ManyToManyDbQueryCollection.prototype.initManyToMany = function (obj, coll) {
            this._obj = obj;
            this._coll = coll;
        };

        ManyToManyDbQueryCollection.prototype.add = function (obj) {
            if (!arrayContains(this._localAdded, obj)) {
                this._session.add(obj);
                this._localAdded.push(obj);
                this.triggerEvent('add', this, obj);
                this.triggerEvent('change', this, obj);
            }
        };

        ManyToManyDbQueryCollection.prototype.addAll = function (objs) {
            for (var i = 0; i < objs.length; i++) {
                var obj = objs[i];
                if (!arrayContains(this._localAdded, obj)) {
                    this._session.add(obj);
                    this._localAdded.push(obj);
                    this.triggerEvent('add', this, obj);
                }
            }
            this.triggerEvent('change', this);
        }

        ManyToManyDbQueryCollection.prototype.clone = function () {
            var c = DbQueryCollection.prototype.clone.call(this);
            c._localAdded = this._localAdded;
            c._localRemoved = this._localRemoved;
            c._obj = this._obj;
            c._coll = this._coll;
            return c;
        };

        ManyToManyDbQueryCollection.prototype.remove = function (obj) {
            if (arrayContains(this._localAdded, obj)) { // added locally, can just remove it from there
                arrayRemove(this._localAdded, obj);
            } else if (!arrayContains(this._localRemoved, obj)) {
                this._localRemoved.push(obj);
            }
            this.triggerEvent('remove', this, obj);
            this.triggerEvent('change', this, obj);
        };

        ////////// Local implementation of QueryCollection \\\\\\\\\\\\\\\\

        function LocalQueryCollection(initialArray) {
            this.init(persistence, null, LocalQueryCollection);
            this._items = initialArray || [];
        }

        LocalQueryCollection.prototype = new QueryCollection();

        LocalQueryCollection.prototype.clone = function () {
            var c = DbQueryCollection.prototype.clone.call(this);
            c._items = this._items;
            return c;
        };

        LocalQueryCollection.prototype.add = function (obj) {
            if (!arrayContains(this._items, obj)) {
                this._session.add(obj);
                this._items.push(obj);
                this.triggerEvent('add', this, obj);
                this.triggerEvent('change', this, obj);
            }
        };

        LocalQueryCollection.prototype.addAll = function (objs) {
            for (var i = 0; i < objs.length; i++) {
                var obj = objs[i];
                if (!arrayContains(this._items, obj)) {
                    this._session.add(obj);
                    this._items.push(obj);
                    this.triggerEvent('add', this, obj);
                }
            }
            this.triggerEvent('change', this);
        }

        LocalQueryCollection.prototype.remove = function (obj) {
            var items = this._items;
            for (var i = 0; i < items.length; i++) {
                if (items[i] === obj) {
                    this._items.splice(i, 1);
                    this.triggerEvent('remove', this, obj);
                    this.triggerEvent('change', this, obj);
                }
            }
        };

        LocalQueryCollection.prototype.list = function (tx, callback) {
            var args = argspec.getArgs(arguments, [
                { name: 'tx', optional: true, check: persistence.isTransaction, defaultValue: null },
                { name: 'callback', optional: true, check: argspec.isCallback() }
            ]);
            callback = args.callback;

            if (!callback || callback.executeSql) { // first argument is transaction
                callback = arguments[1]; // set to second argument
            }
            var array = this._items.slice(0);
            var that = this;
            var results = [];
            for (var i = 0; i < array.length; i++) {
                if (this._filter.match(array[i])) {
                    results.push(array[i]);
                }
            }
            results.sort(function (a, b) {
                for (var i = 0; i < that._orderColumns.length; i++) {
                    var col = that._orderColumns[i][0];
                    var asc = that._orderColumns[i][1];
                    var sens = that._orderColumns[i][2];
                    var aVal = persistence.get(a, col);
                    var bVal = persistence.get(b, col);
                    if (!sens) {
                        aVal = aVal.toLowerCase();
                        bVal = bVal.toLowerCase();
                    }
                    if (aVal < bVal) {
                        return asc ? -1 : 1;
                    } else if (aVal > bVal) {
                        return asc ? 1 : -1;
                    }
                }
                return 0;
            });
            if (this._skip) {
                results.splice(0, this._skip);
            }
            if (this._limit > -1) {
                results = results.slice(0, this._limit);
            }
            if (this._reverse) {
                results.reverse();
            }
            if (callback) {
                callback(results);
            } else {
                return results;
            }
        };

        LocalQueryCollection.prototype.destroyAll = function (callback) {
            if (!callback || callback.executeSql) { // first argument is transaction
                callback = arguments[1]; // set to second argument
            }
            this._items = [];
            this.triggerEvent('change', this);
            if (callback) callback();
        };

        LocalQueryCollection.prototype.count = function (tx, callback) {
            var args = argspec.getArgs(arguments, [
                { name: 'tx', optional: true, check: persistence.isTransaction, defaultValue: null },
                { name: 'callback', optional: true, check: argspec.isCallback() }
            ]);
            tx = args.tx;
            callback = args.callback;

            var result = this.list();

            if (callback) {
                callback(result.length);
            } else {
                return result.length;
            }
        };

        persistence.QueryCollection = QueryCollection;
        persistence.DbQueryCollection = DbQueryCollection;
        persistence.ManyToManyDbQueryCollection = ManyToManyDbQueryCollection;
        persistence.LocalQueryCollection = LocalQueryCollection;
        persistence.Observable = Observable;
        persistence.Subscription = Subscription;
        persistence.AndFilter = AndFilter;
        persistence.OrFilter = OrFilter;
        persistence.PropertyFilter = PropertyFilter;
    }());

    // ArgSpec.js library: http://github.com/zefhemel/argspecjs
    var argspec = {};

    (function () {
        argspec.getArgs = function (args, specs) {
            var argIdx = 0;
            var specIdx = 0;
            var argObj = {};
            while (specIdx < specs.length) {
                var s = specs[specIdx];
                var a = args[argIdx];
                if (s.optional) {
                    if (a !== undefined && s.check(a)) {
                        argObj[s.name] = a;
                        argIdx++;
                        specIdx++;
                    } else {
                        if (s.defaultValue !== undefined) {
                            argObj[s.name] = s.defaultValue;
                        }
                        specIdx++;
                    }
                } else {
                    if (s.check && !s.check(a)) {
                        throw new Error("Invalid value for argument: " + s.name + " Value: " + a);
                    }
                    argObj[s.name] = a;
                    specIdx++;
                    argIdx++;
                }
            }
            return argObj;
        }

        argspec.hasProperty = function (name) {
            return function (obj) {
                return obj && obj[name] !== undefined;
            };
        }

        argspec.hasType = function (type) {
            return function (obj) {
                return typeof obj === type;
            };
        }

        argspec.isCallback = function () {
            return function (obj) {
                return obj && obj.apply;
            };
        }
    }());

    persistence.argspec = argspec;

    return persistence;
} // end of createPersistence



// JSON2 library, source: http://www.JSON.org/js.html
// Most modern browsers already support this natively, but mobile
// browsers often don't, hence this implementation
// Relevant APIs:
//    JSON.stringify(value, replacer, space)
//    JSON.parse(text, reviver)

if (typeof JSON === 'undefined') {
    JSON = {};
}
//var JSON = typeof JSON === 'undefined' ? window.JSON : {};
if (!JSON.stringify) {
    (function () {
        function f(n) {
            return n < 10 ? '0' + n : n;
        }
        if (typeof Date.prototype.toJSON !== 'function') {

            Date.prototype.toJSON = function (key) {

                return isFinite(this.valueOf()) ?
                this.getUTCFullYear() + '-' +
                  f(this.getUTCMonth() + 1) + '-' +
                  f(this.getUTCDate()) + 'T' +
                  f(this.getUTCHours()) + ':' +
                  f(this.getUTCMinutes()) + ':' +
                  f(this.getUTCSeconds()) + 'Z' : null;
            };

            String.prototype.toJSON =
              Number.prototype.toJSON =
              Boolean.prototype.toJSON = function (key) {
                  return this.valueOf();
              };
        }

        var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap, indent,
        meta = {
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"': '\\"',
            '\\': '\\\\'
        },
        rep;

        function quote(string) {
            escapable.lastIndex = 0;
            return escapable.test(string) ?
            '"' + string.replace(escapable, function (a) {
                var c = meta[a];
                return typeof c === 'string' ? c :
                '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
            }) + '"' :
            '"' + string + '"';
        }


        function str(key, holder) {
            var i, k, v, length, mind = gap, partial, value = holder[key];

            if (value && typeof value === 'object' &&
              typeof value.toJSON === 'function') {
                value = value.toJSON(key);
            }

            if (typeof rep === 'function') {
                value = rep.call(holder, key, value);
            }

            switch (typeof value) {
                case 'string':
                    return quote(value);
                case 'number':
                    return isFinite(value) ? String(value) : 'null';
                case 'boolean':
                case 'null':
                    return String(value);
                case 'object':
                    if (!value) {
                        return 'null';
                    }

                    gap += indent;
                    partial = [];

                    if (Object.prototype.toString.apply(value) === '[object Array]') {
                        length = value.length;
                        for (i = 0; i < length; i += 1) {
                            partial[i] = str(i, value) || 'null';
                        }

                        v = partial.length === 0 ? '[]' :
                        gap ? '[\n' + gap +
                          partial.join(',\n' + gap) + '\n' +
                          mind + ']' :
                        '[' + partial.join(',') + ']';
                        gap = mind;
                        return v;
                    }

                    if (rep && typeof rep === 'object') {
                        length = rep.length;
                        for (i = 0; i < length; i += 1) {
                            k = rep[i];
                            if (typeof k === 'string') {
                                v = str(k, value);
                                if (v) {
                                    partial.push(quote(k) + (gap ? ': ' : ':') + v);
                                }
                            }
                        }
                    } else {
                        for (k in value) {
                            if (Object.hasOwnProperty.call(value, k)) {
                                v = str(k, value);
                                if (v) {
                                    partial.push(quote(k) + (gap ? ': ' : ':') + v);
                                }
                            }
                        }
                    }

                    v = partial.length === 0 ? '{}' :
                    gap ? '{\n' + gap + partial.join(',\n' + gap) + '\n' +
                      mind + '}' : '{' + partial.join(',') + '}';
                    gap = mind;
                    return v;
            }
        }

        if (typeof JSON.stringify !== 'function') {
            JSON.stringify = function (value, replacer, space) {
                var i;
                gap = '';
                indent = '';
                if (typeof space === 'number') {
                    for (i = 0; i < space; i += 1) {
                        indent += ' ';
                    }
                } else if (typeof space === 'string') {
                    indent = space;
                }

                rep = replacer;
                if (replacer && typeof replacer !== 'function' &&
                  (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                    throw new Error('JSON.stringify');
                }

                return str('', { '': value });
            };
        }

        if (typeof JSON.parse !== 'function') {
            JSON.parse = function (text, reviver) {
                var j;
                function walk(holder, key) {
                    var k, v, value = holder[key];
                    if (value && typeof value === 'object') {
                        for (k in value) {
                            if (Object.hasOwnProperty.call(value, k)) {
                                v = walk(value, k);
                                if (v !== undefined) {
                                    value[k] = v;
                                } else {
                                    delete value[k];
                                }
                            }
                        }
                    }
                    return reviver.call(holder, key, value);
                }

                cx.lastIndex = 0;
                if (cx.test(text)) {
                    text = text.replace(cx, function (a) {
                        return '\\u' +
                          ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                    });
                }

                if (/^[\],:{}\s]*$/.
                test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@').
                  replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').
                  replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {
                    j = eval('(' + text + ')');
                    return typeof reviver === 'function' ?
                    walk({ '': j }, '') : j;
                }
                throw new SyntaxError('JSON.parse');
            };
        }
    }());
}

;
/**
 * Default type mapper. Override to support more types or type options.
 */
var defaultTypeMapper = {
    /**
     * SQL type for ids
     */
    idType: "VARCHAR(32)",

    /**
     * SQL type for class names (used by mixins)
     */
    classNameType: "TEXT",

    /**
     * Returns SQL type for column definition
     */
    columnType: function (type) {
        switch (type) {
            case 'JSON': return 'TEXT';
            case 'BOOL': return 'INT';
            case 'DATE': return 'INT';
            default: return type;
        }
    },

    inVar: function (str, type) {
        return str;
    },
    outVar: function (str, type) {
        return str;
    },
    outId: function (str) {
        return "'" + str + "'";
    },
    /**
     * Converts a value from the database to a value suitable for the entity
     * (also does type conversions, if necessary)
     */
    dbValToEntityVal: function (val, type) {
        if (val === null || val === undefined) {
            return val;
        }
        switch (type) {
            case 'DATE':
                // SQL is in seconds and JS in miliseconds
                if (val > 1000000000000) {
                    // usually in seconds, but sometimes it's milliseconds
                    return new Date(parseInt(val, 10));
                } else {
                    return new Date(parseInt(val, 10) * 1000);
                }
            case 'BOOL':
                return val === 1 || val === '1';
                break;
            case 'INT':
                return +val;
                break;
            case 'BIGINT':
                return +val;
                break;
            case 'JSON':
                if (val) {
                    return JSON.parse(val);
                }
                else {
                    return val;
                }
                break;
            default:
                return val;
        }
    },

    /**
     * Converts an entity value to a database value, inverse of
     *   dbValToEntityVal
     */
    entityValToDbVal: function (val, type) {
        if (val === undefined || val === null) {
            return null;
        }
        else if (type === 'JSON' && val) {
            return JSON.stringify(val);
        }
        else if (val.id) {
            return val.id;
        }
        else if (type === 'BOOL') {
            return (val === 'false') ? 0 : (val ? 1 : 0);
        }
        else if (type === 'DATE' || val.getTime) {
            // In order to make SQLite Date/Time functions work we should store
            // values in seconds and not as miliseconds as JS Date.getTime()
            val = new Date(val);
            return Math.round(val.getTime() / 1000);
        }
        else if (type === 'VARCHAR(32)') {
            return val.toString();
        }
        else {
            return val;
        }
    },
    /**
     * Shortcut for inVar when type is id -- no need to override
     */
    inIdVar: function (str) {
        return this.inVar(str, this.idType);
    },
    /**
     * Shortcut for outVar when type is id -- no need to override
     */
    outIdVar: function (str) {
        return this.outVar(str, this.idType);
    },
    /**
     * Shortcut for entityValToDbVal when type is id -- no need to override
     */
    entityIdToDbId: function (id) {
        return this.entityValToDbVal(id, this.idType);
    }
}

function config(persistence, dialect) {
    var argspec = persistence.argspec;

    persistence.typeMapper = dialect.typeMapper || defaultTypeMapper;

    persistence.generatedTables = {}; // set

    /**
     * Synchronize the data model with the database, creates table that had not
     * been defined before
     *
     * @param tx
     *            transaction object to use (optional)
     * @param callback
     *            function to be called when synchronization has completed,
     *            takes started transaction as argument
     */
    persistence.schemaSync = function (tx, callback, emulate) {
        var args = argspec.getArgs(arguments, [
            { name: "tx", optional: true, check: persistence.isTransaction, defaultValue: null },
            { name: "callback", optional: true, check: argspec.isCallback(), defaultValue: function () { } },
            { name: "emulate", optional: true, check: argspec.hasType('boolean') }
        ]);
        tx = args.tx;
        callback = args.callback;
        emulate = args.emulate;

        if (!tx) {
            var session = this;
            this.transaction(function (tx) { session.schemaSync(tx, callback, emulate); });
            return;
        }
        var queries = [], meta, colDefs, otherMeta, tableName;

        var tm = persistence.typeMapper;
        var entityMeta = persistence.getEntityMeta();
        for (var entityName in entityMeta) {
            if (entityMeta.hasOwnProperty(entityName)) {
                meta = entityMeta[entityName];
                if (!meta.isMixin) {
                    colDefs = [];
                    for (var prop in meta.fields) {
                        if (meta.fields.hasOwnProperty(prop)) {
                            colDefs.push([prop, meta.fields[prop]]);
                        }
                    }
                    for (var rel in meta.hasOne) {
                        if (meta.hasOne.hasOwnProperty(rel)) {
                            otherMeta = meta.hasOne[rel].type.meta;
                            colDefs.push([rel, tm.idType]);
                            queries.push([dialect.createIndex(meta.name, [rel]), null]);
                        }
                    }
                    for (var i = 0; i < meta.indexes.length; i++) {
                        queries.push([dialect.createIndex(meta.name, meta.indexes[i].columns, meta.indexes[i]), null]);
                    }
                }
                for (var rel in meta.hasMany) {
                    if (meta.hasMany.hasOwnProperty(rel) && meta.hasMany[rel].manyToMany) {
                        tableName = meta.hasMany[rel].tableName;
                        if (!persistence.generatedTables[tableName]) {
                            var otherMeta = meta.hasMany[rel].type.meta;
                            var inv = meta.hasMany[rel].inverseProperty;
                            // following test ensures that mixin mtm tables get created with the mixin itself
                            // it seems superfluous because mixin will be processed before entitites that use it
                            // but better be safe than sorry.
                            if (otherMeta.hasMany[inv].type.meta != meta)
                                continue;
                            var p1 = meta.name + "_" + rel;
                            var p2 = otherMeta.name + "_" + inv;
                            queries.push([dialect.createIndex(tableName, [p1]), null]);
                            queries.push([dialect.createIndex(tableName, [p2]), null]);
                            var columns = [[p1, tm.idType], [p2, tm.idType]];
                            if (meta.isMixin)
                                columns.push([p1 + "_class", tm.classNameType])
                            if (otherMeta.isMixin)
                                columns.push([p2 + "_class", tm.classNameType])
                            queries.push([dialect.createTable(tableName, columns), null]);
                            persistence.generatedTables[tableName] = true;
                        }
                    }
                }
                if (!meta.isMixin) {
                    colDefs.push(["id", tm.idType, "PRIMARY KEY"]);
                    persistence.generatedTables[meta.name] = true;
                    queries.push([dialect.createTable(meta.name, colDefs), null]);
                }
            }
        }
        var fns = persistence.schemaSyncHooks;
        for (var i = 0; i < fns.length; i++) {
            fns[i](tx);
        }
        if (emulate) {
            // Done
            callback(tx);
        } else {
            executeQueriesSeq(tx, queries, function (_, err) {
                callback(tx, err);
            });
        }
    };

    /**
     * Persists all changes to the database transaction
     *
     * @param tx
     *            transaction to use
     * @param callback
     *            function to be called when done
     */
    persistence.flush = function (tx, callback) {
        var args = argspec.getArgs(arguments, [
            { name: "tx", optional: true, check: persistence.isTransaction },
            { name: "callback", optional: true, check: argspec.isCallback(), defaultValue: null }
        ]);
        tx = args.tx;
        callback = args.callback;

        var session = this;
        if (!tx) {
            this.transaction(function (tx) { session.flush(tx, callback); });
            return;
        }
        var fns = persistence.flushHooks;
        persistence.asyncForEach(fns, function (fn, callback) {
            fn(session, tx, callback);
        }, function () {
            // After applying the hooks
            var persistObjArray = [];
            for (var id in session.trackedObjects) {
                if (session.trackedObjects.hasOwnProperty(id)) {
                    persistObjArray.push(session.trackedObjects[id]);
                }
            }
            var removeObjArray = [];
            for (var id in session.objectsToRemove) {
                if (session.objectsToRemove.hasOwnProperty(id)) {
                    removeObjArray.push(session.objectsToRemove[id]);
                    delete session.trackedObjects[id]; // Stop tracking
                }
            }
            session.objectsToRemove = {};
            if (callback) {
                persistence.asyncParForEach(removeObjArray, function (obj, callback) {
                    remove(obj, tx, callback);
                }, function (result, err) {
                    if (err) return callback(result, err);
                    persistence.asyncParForEach(persistObjArray, function (obj, callback) {
                        save(obj, tx, callback);
                    }, callback);
                });
            } else { // More efficient
                for (var i = 0; i < persistObjArray.length; i++) {
                    save(persistObjArray[i], tx);
                }
                for (var i = 0; i < removeObjArray.length; i++) {
                    remove(removeObjArray[i], tx);
                }
            }
        });
    };

    /**
     * Remove all tables in the database (as defined by the model)
     */
    persistence.reset = function (tx, callback) {
        var args = argspec.getArgs(arguments, [
            { name: "tx", optional: true, check: persistence.isTransaction, defaultValue: null },
            { name: "callback", optional: true, check: argspec.isCallback(), defaultValue: function () { } }
        ]);
        tx = args.tx;
        callback = args.callback;

        var session = this;
        if (!tx) {
            session.transaction(function (tx) { session.reset(tx, callback); });
            return;
        }
        // First emulate syncing the schema (to know which tables were created)
        this.schemaSync(tx, function () {
            var tableArray = [];
            for (var p in persistence.generatedTables) {
                if (persistence.generatedTables.hasOwnProperty(p)) {
                    tableArray.push(p);
                }
            }
            function dropOneTable() {
                var tableName = tableArray.pop();
                tx.executeSql("DROP TABLE IF EXISTS `" + tableName + "`", null, function () {
                    if (tableArray.length > 0) {
                        dropOneTable();
                    } else {
                        cb();
                    }
                }, cb);
            }
            if (tableArray.length > 0) {
                dropOneTable();
            } else {
                cb();
            }

            function cb(result, err) {
                session.clean();
                persistence.generatedTables = {};
                if (callback) callback(result, err);
            }
        }, true);
    };

    /**
     * Converts a database row into an entity object
     */
    function rowToEntity(session, entityName, row, prefix) {
        prefix = prefix || '';
        //        if (session.trackedObjects[row[prefix + "id"]]) { // Cached version
        //            return session.trackedObjects[row[prefix + "id"]];
        //        }
        var tm = persistence.typeMapper;
        var rowMeta = persistence.getMeta(entityName);
        var ent = persistence.define(entityName); // Get entity
        if (!row[prefix + 'id']) { // null value, no entity found
            return null;
        }
        var o = new ent(session, undefined, true);
        o.id = tm.dbValToEntityVal(row[prefix + 'id'], tm.idType);
        o._new = false;
        var joinedJSONs = [];

        for (var p in row) {
            if (row.hasOwnProperty(p)) {
                if (p.startsWith("#")) {
                    joinedJSONs.push(p);
                    continue;
                }

                if (p.substring(0, prefix.length) === prefix) {
                    var prop = p.substring(prefix.length);
                    if (prop != 'id') {
                        o._data[prop] = tm.dbValToEntityVal(row[p], rowMeta.fields[prop] || tm.idType);
                    }
                }
            }
        }
        //cts:luiz this snippet inserts the joined entities json inside of the main entity json property
        for (var i = 0; i < joinedJSONs.length; i++) {
            var joinedJsonName = joinedJSONs[i];
            var originalPropName = joinedJsonName.substr(1, joinedJsonName.indexOf(".") - 1); // the name of the property that has a matching join (ex: datamap)
            var propName = joinedJsonName.substr(joinedJsonName.indexOf(".")+1); // the name of the relationship of the left join (ex: assignment_)
            if (o.hasOwnProperty(originalPropName)) {
                var innerJson = tm.dbValToEntityVal(row[joinedJsonName], "JSON");
                for (var innerProperty in innerJson) {
                    // each proprperty of the joined json will be added to its original one, making it transparent to other parts of the framework
                    if (innerJson.hasOwnProperty(innerProperty)) {
                        o[originalPropName]["#" + propName + "." + innerProperty] = innerJson[innerProperty];
                    }
                    
                }
                
            }
        }
        //letï¿½s use this to have a valid track by value, since the ids might not be unique on a left join operation
        o.generatedRowStamp = persistence.createUUID();

        return o;
    }

    /**
     * Internal function to persist an object to the database
     * this function is invoked by persistence.flush()
     */
    function save(obj, tx, callback) {
        var meta = persistence.getMeta(obj._type);
        var tm = persistence.typeMapper;
        var properties = [];
        var values = [];
        var qs = [];
        var propertyPairs = [];
        if (obj._new) { // Mark all properties dirty
            for (var p in meta.fields) {
                if (meta.fields.hasOwnProperty(p)) {
                    obj._dirtyProperties[p] = true;
                }
            }
        }
        for (var p in obj._dirtyProperties) {
            if (obj._dirtyProperties.hasOwnProperty(p)) {
                properties.push("`" + p + "`");
                var type = meta.fields[p] || tm.idType;
                values.push(tm.entityValToDbVal(obj._data[p], type));
                qs.push(tm.outVar("?", type));
                propertyPairs.push("`" + p + "` = " + tm.outVar("?", type));
            }
        }
        var additionalQueries = [];
        for (var p in meta.hasMany) {
            if (meta.hasMany.hasOwnProperty(p)) {
                additionalQueries = additionalQueries.concat(persistence.get(obj, p).persistQueries());
            }
        }
        executeQueriesSeq(tx, additionalQueries, function () {
            if (!obj._new && properties.length === 0) { // Nothing changed and not new
                if (callback) callback();
                return;
            }
            obj._dirtyProperties = {};
            if (obj._new) {
                properties.push('id');
                values.push(tm.entityIdToDbId(obj.id));
                qs.push(tm.outIdVar('?'));
                var sql = "INSERT INTO `" + obj._type + "` (" + properties.join(", ") + ") VALUES (" + qs.join(', ') + ")";
                obj._new = false;
                tx.executeSql(sql, values, callback, callback);
            } else {
                var sql = "UPDATE `" + obj._type + "` SET " + propertyPairs.join(',') + " WHERE id = " + tm.outId(obj.id);
                tx.executeSql(sql, values, callback, callback);
            }
        });
    }

    persistence.save = save;

    function remove(obj, tx, callback) {
        var meta = persistence.getMeta(obj._type);
        var tm = persistence.typeMapper;
        var queries = [["DELETE FROM `" + obj._type + "` WHERE id = " + tm.outId(obj.id), null]];
        for (var rel in meta.hasMany) {
            if (meta.hasMany.hasOwnProperty(rel) && meta.hasMany[rel].manyToMany) {
                var tableName = meta.hasMany[rel].tableName;
                //var inverseProperty = meta.hasMany[rel].inverseProperty;
                queries.push(["DELETE FROM `" + tableName + "` WHERE `" + meta.name + '_' + rel + "` = " + tm.outId(obj.id), null]);
            }
        }
        executeQueriesSeq(tx, queries, callback);
    }

    function executeQueriesSeqForceBatch(tx, queries, callback) {
        if (persistence.db.implementation === "sqliteplugin") {
            tx.bulkSQL(queries,
            () => callback(queries, null),
            (err) => callback(null, err));
        } else {
            this.executeQueriesSeq(tx, queries, callback);
        }
    }


    /**
     * Utility function to execute a series of queries in an asynchronous way
     * @param tx the transaction to execute the queries on
     * @param queries an array of [query, args] tuples
     * @param callback the function to call when all queries have been executed
     */
    function executeQueriesSeq(tx, queries, callback) {



        // queries.reverse();
        //var callbackArgs = [];
        //for (var i = 3; i < arguments.length; i++) {
        //    callbackArgs.push(arguments[i]);
        //}
        persistence.asyncForEach(queries,
            (queryTuple, next) => {
                var statement = queryTuple[0];
                var args = queryTuple[1];
                if (persistence.debug) {
                    console.log(statement, args);
                }
                tx.executeSql(statement, args,
                    next, // success fn: go to next element
                    err => { // error fn
                        persistence.defaultTransactionErrorHandler(statement, args, err);
                        next(null, err); // next element with null result
                    });
            }, (result, err) => {
                //if (err && callback) {
                //    callback(result, err);
                //    return;
                //}
                //if (callback) callback.apply(null, callbackArgs);
                if (callback) callback(result, err);
            });
    }

    persistence.executeQueriesSeq = executeQueriesSeq;
    persistence.executeQueriesSeqForceBatch = executeQueriesSeqForceBatch;

    /////////////////////////// QueryCollection patches to work in SQL environment

    /**
     * Function called when session is flushed, returns list of SQL queries to execute
     * (as [query, arg] tuples)
     */
    persistence.QueryCollection.prototype.persistQueries = function () { return []; };

    var oldQCClone = persistence.QueryCollection.prototype.clone;

    persistence.QueryCollection.prototype.clone = function (cloneSubscribers) {
        var c = oldQCClone.call(this, cloneSubscribers);
        c._additionalJoinSqls = this._additionalJoinSqls.slice(0);
        c._additionalWhereSqls = this._additionalWhereSqls.slice(0);
        c._projectionFields = this._projectionFields.slice(0);
        c._extraProjectionFields = this._extraProjectionFields.slice(0);
        c._querytoUse = this._querytoUse;
        c._additionalGroupSqls = this._additionalGroupSqls.slice(0);
        c._manyToManyFetch = this._manyToManyFetch;
        return c;
    };

    var oldQCInit = persistence.QueryCollection.prototype.init;

    persistence.QueryCollection.prototype.init = function (session, entityName, constructor) {
        oldQCInit.call(this, session, entityName, constructor);
        this._manyToManyFetch = null;
        this._additionalJoinSqls = [];
        this._additionalWhereSqls = [];
        this._additionalGroupSqls = [];
        this._projectionFields = [];
        this._extraProjectionFields = [];
        this._querytoUse = null;
    };

    var oldQCToUniqueString = persistence.QueryCollection.prototype.toUniqueString;

    persistence.QueryCollection.prototype.toUniqueString = function () {
        var s = oldQCToUniqueString.call(this);
        s += '|JoinSQLs:';
        for (var i = 0; i < this._additionalJoinSqls.length; i++) {
            s += this._additionalJoinSqls[i];
        }
        s += '|WhereSQLs:';
        for (var i = 0; i < this._additionalWhereSqls.length; i++) {
            s += this._additionalWhereSqls[i];
        }
        s += '|GroupSQLs:';
        for (var i = 0; i < this._additionalGroupSqls.length; i++) {
            s += this._additionalGroupSqls[i];
        }
        if (this._manyToManyFetch) {
            s += '|ManyToManyFetch:';
            s += JSON.stringify(this._manyToManyFetch); // TODO: Do something more efficient
        }
        return s;
    };

    persistence.NullFilter.prototype.sql = function (meta, alias, values) {
        return "1=1";
    };

    persistence.AndFilter.prototype.sql = function (meta, alias, values) {
        return "(" + this.left.sql(meta, alias, values) + " AND "
        + this.right.sql(meta, alias, values) + ")";
    };

    persistence.OrFilter.prototype.sql = function (meta, alias, values) {
        return "(" + this.left.sql(meta, alias, values) + " OR "
        + this.right.sql(meta, alias, values) + ")";
    };

    persistence.PropertyFilter.prototype.sql = function (meta, alias, values) {
        var tm = persistence.typeMapper;
        var aliasPrefix = alias ? "`" + alias + "`." : "";
        var sqlType = meta.fields[this.property] || tm.idType;
        if (this.operator === '=' && this.value === null) {
            return aliasPrefix + '`' + this.property + "` IS NULL";
        } else if (this.operator === '!=' && this.value === null) {
            return aliasPrefix + '`' + this.property + "` IS NOT NULL";
        } else if (this.operator === 'in') {
            var vals = this.value;
            var qs = [];
            for (var i = 0; i < vals.length; i++) {
                qs.push('?');
                values.push(tm.entityValToDbVal(vals[i], sqlType));
            }
            if (vals.length === 0) {
                // Optimize this a little
                return "1 = 0";
            } else {
                return aliasPrefix + '`' + this.property + "` IN (" + qs.join(', ') + ")";
            }
        } else if (this.operator === 'not in') {
            var vals = this.value;
            var qs = [];
            for (var i = 0; i < vals.length; i++) {
                qs.push('?');
                values.push(tm.entityValToDbVal(vals[i], sqlType));
            }

            if (vals.length === 0) {
                // Optimize this a little
                return "1 = 1";
            } else {
                return aliasPrefix + '`' + this.property + "` NOT IN (" + qs.join(', ') + ")";
            }
        } else {
            var value = this.value;
            if (value === true || value === false) {
                value = value ? 1 : 0;
            }
            values.push(tm.entityValToDbVal(value, sqlType));
            return aliasPrefix + '`' + this.property + "` " + this.operator + " " + tm.outVar("?", sqlType);
        }
    };

    // QueryColleciton's list

    /**
     * Asynchronous call to actually fetch the items in the collection
     * @param tx transaction to use
     * @param callback function to be called taking an array with
     *   result objects as argument
     */
    persistence.DbQueryCollection.prototype.list = function (tx, callback) {
        var args = argspec.getArgs(arguments, [
            { name: 'tx', optional: true, check: persistence.isTransaction, defaultValue: null },
            { name: 'callback', optional: false, check: argspec.isCallback() }
        ]);
        tx = args.tx;
        callback = args.callback;

        var that = this;
        var session = this._session;
        if (!tx) { // no transaction supplied
            session.transaction(function (tx) {
                that.list(tx, callback);
            });
            return;
        }
        var entityName = this._entityName;
        var meta = persistence.getMeta(entityName);
        var tm = persistence.typeMapper;

        // handles mixin case -- this logic is generic and could be in persistence.
        if (meta.isMixin) {
            var result = [];
            persistence.asyncForEach(meta.mixedIns, function (realMeta, next) {
                var query = that.clone();
                query._entityName = realMeta.name;
                query.list(tx, function (array) {
                    result = result.concat(array);
                    next();
                });
            }, function () {
                var query = new persistence.LocalQueryCollection(result);
                query._orderColumns = that._orderColumns;
                query._reverse = that._reverse;
                // TODO: handle skip and limit -- do we really want to do it?
                query.list(null, callback);
            });
            return;
        }

        function selectAll(meta, tableAlias, prefix) {
            var selectFields = [tm.inIdVar("`" + tableAlias + "`.id") + " AS " + prefix + "id"];
            for (var p in meta.fields) {
                if (meta.fields.hasOwnProperty(p)) {
                    selectFields.push(tm.inVar("`" + tableAlias + "`.`" + p + "`", meta.fields[p]) + " AS `"
                      + prefix + p + "`");
                }
            }
            for (var p in meta.hasOne) {
                if (meta.hasOne.hasOwnProperty(p)) {
                    selectFields.push(tm.inIdVar("`" + tableAlias + "`.`" + p + "`") + " AS `"
                      + prefix + p + "`");
                }
            }
            return selectFields;
        }
        var args = [];
        var mainPrefix = entityName + "_";

        var mainAlias = 'root';
        var selectFields = [];
        if (this._projectionFields && this._projectionFields.length > 0) {
            var fakeMetafields = {};
            for (var j = 0; j < this._projectionFields.length; j++) {
                fakeMetafields[this._projectionFields[j]] = this._projectionFields[j];
            }

            selectFields = selectAll({ fields: fakeMetafields }, mainAlias, mainPrefix);
        } else {


            selectFields = selectAll(meta, mainAlias, mainPrefix);
        }

        if (this._extraProjectionFields && this._extraProjectionFields.length > 0) {

            for (var m = 0; m < this._extraProjectionFields.length; m++) {
                let field = this._extraProjectionFields[m];
                selectFields.push(`${field.field} as ${field.alias}`);
            }
        }

        var joinSql = '';
        var additionalWhereSqls = this._additionalWhereSqls.slice(0);
        var mtm = this._manyToManyFetch;
        if (mtm) {
            joinSql += "LEFT JOIN `" + mtm.table + "` AS mtm ON mtm.`" + mtm.inverseProp + "` = `root`.`id` ";
            additionalWhereSqls.push("mtm.`" + mtm.prop + "` = " + tm.outId(mtm.id));
        }

        joinSql += this._additionalJoinSqls.join(' ');

        for (var i = 0; i < this._prefetchFields.length; i++) {
            var prefetchFieldParts = this._prefetchFields[i].split('.');
            var prefetchField = prefetchFieldParts[0];
            var eName = entityName;
            if (prefetchFieldParts.length > 1) {
                prefetchField = prefetchFieldParts[1];
                eName = prefetchFieldParts[0];
            }
            var theMeta = persistence.getMeta(eName);
            var thisMeta = theMeta.hasOne[prefetchField].type.meta;
            if (thisMeta.isMixin)
                throw new Error("cannot prefetch a mixin");
            var tableAlias = thisMeta.name + '_' + prefetchField + "_tbl";
            var PrefetchFrom = mainAlias;
            if (prefetchFieldParts.length > 1) {
                PrefetchFrom = eName + '_' + eName + "_tbl";;
            }
            selectFields = selectFields.concat(selectAll(thisMeta, tableAlias,
                prefetchField + "_"));
            joinSql += "LEFT JOIN `" + thisMeta.name + "` AS `" + tableAlias
            + "` ON `" + tableAlias + "`.`id` = `" + PrefetchFrom + '`.`' + prefetchField + "` ";

        }

        var whereSql = "WHERE "
        + [this._filter.sql(meta, mainAlias, args)].concat(additionalWhereSqls).join(' AND ');

        var sql = "SELECT " + selectFields.join(", ") + " FROM `" + entityName
        + "` AS `" + mainAlias + "` " + joinSql + " " + whereSql;

        if (this._additionalGroupSqls.length > 0) {
            sql += this._additionalGroupSqls.join(' ');
        }

        if (this._orderColumns.length > 0) {
            sql += " ORDER BY "
            + this._orderColumns.map(
              function (c) {
                  return (c[2] ? "`" : "LOWER(`") + mainPrefix + c[0] + (c[2] ? "` " : "`) ")
                  + (c[1] ? "ASC" : "DESC");
              }).join(", ");
        }
        if (this._limit >= 0) {
            sql += " LIMIT " + this._limit;
        }
        if (this._skip > 0) {
            sql += " OFFSET " + this._skip;
        }

        if (this._querytoUse) {
            sql = this._querytoUse;
            mainPrefix = "";
        }

        session.flush(tx, function () {
            tx.executeSql(sql, args, function (rows) {
                var results = [];
                if (that._reverse) {
                    rows.reverse();
                }
                for (var i = 0; i < rows.length; i++) {
                    var r = rows[i];
                    var e = rowToEntity(session, entityName, r, mainPrefix);
                    for (var j = 0; j < that._prefetchFields.length; j++) {

                        var prefetchFieldParts = that._prefetchFields[j].split('.');
                        var prefetchField = prefetchFieldParts[0];
                        var eName = entityName;
                        if (prefetchFieldParts.length > 1) {
                            prefetchField = prefetchFieldParts[1];
                            eName = prefetchFieldParts[0];
                        }
                        var theMeta = persistence.getMeta(eName);
                        var thisMeta = theMeta.hasOne[prefetchField].type.meta;

                        e._data_obj[prefetchField] = rowToEntity(session, thisMeta.name, r, prefetchField + '_');
                        session.add(e._data_obj[prefetchField]);
                    }
                    results.push(e);
                    session.add(e);
                }
                callback(results);
                that.triggerEvent('list', that, results);
            });
        });
    };

    /**
     * Asynchronous call to remove all the items in the collection.
     * Note: does not only remove the items from the collection, but
     * the items themselves.
     * @param tx transaction to use
     * @param callback function to be called when clearing has completed
     */
    persistence.DbQueryCollection.prototype.destroyAll = function (tx, callback) {
        var args = argspec.getArgs(arguments, [
            { name: 'tx', optional: true, check: persistence.isTransaction, defaultValue: null },
            { name: 'callback', optional: true, check: argspec.isCallback(), defaultValue: function () { } }
        ]);
        tx = args.tx;
        callback = args.callback;

        var that = this;
        var session = this._session;
        if (!tx) { // no transaction supplied
            session.transaction(function (tx) {
                that.destroyAll(tx, callback);
            });
            return;
        }
        var entityName = this._entityName;
        var meta = persistence.getMeta(entityName);
        var tm = persistence.typeMapper;

        // handles mixin case -- this logic is generic and could be in persistence.
        if (meta.isMixin) {
            persistence.asyncForEach(meta.mixedIns, function (realMeta, next) {
                var query = that.clone();
                query._entityName = realMeta.name;
                query.destroyAll(tx, callback);
            }, callback);
            return;
        }

        var joinSql = '';
        var additionalWhereSqls = this._additionalWhereSqls.slice(0);
        var mtm = this._manyToManyFetch;
        if (mtm) {
            joinSql += "LEFT JOIN `" + mtm.table + "` AS mtm ON mtm.`" + mtm.inverseProp + "` = `root`.`id` ";
            additionalWhereSqls.push("mtm.`" + mtm.prop + "` = " + tm.outId(mtm.id));
        }

        joinSql += this._additionalJoinSqls.join(' ');

        var args = [];
        var whereSql = "WHERE "
        + [this._filter.sql(meta, null, args)].concat(additionalWhereSqls).join(' AND ');

        var selectSql = "SELECT id FROM `" + entityName + "` " + joinSql + ' ' + whereSql;
        var deleteSql = "DELETE FROM `" + entityName + "` " + joinSql + ' ' + whereSql;
        var args2 = args.slice(0);

        session.flush(tx, function () {
            tx.executeSql(selectSql, args, function (results) {
                for (var i = 0; i < results.length; i++) {
                    delete session.trackedObjects[results[i].id];
                    session.objectsRemoved.push({ id: results[i].id, entity: entityName });
                }
                that.triggerEvent('change', that);
                tx.executeSql(deleteSql, args2, callback, callback);
            }, callback);
        });
    };

    /**
     * Asynchronous call to count the number of items in the collection.
     * @param tx transaction to use
     * @param callback function to be called when clearing has completed
     */
    persistence.DbQueryCollection.prototype.count = function (tx, callback) {
        var args = argspec.getArgs(arguments, [
            { name: 'tx', optional: true, check: persistence.isTransaction, defaultValue: null },
            { name: 'callback', optional: false, check: argspec.isCallback() }
        ]);
        tx = args.tx;
        callback = args.callback;

        var that = this;
        var session = this._session;
        if (tx && !tx.executeSql) { // provided callback as first argument
            callback = tx;
            tx = null;
        }
        if (!tx) { // no transaction supplied
            session.transaction(function (tx) {
                that.count(tx, callback);
            });
            return;
        }
        var entityName = this._entityName;
        var meta = persistence.getMeta(entityName);
        var tm = persistence.typeMapper;

        // handles mixin case -- this logic is generic and could be in persistence.
        if (meta.isMixin) {
            var result = 0;
            persistence.asyncForEach(meta.mixedIns, function (realMeta, next) {
                var query = that.clone();
                query._entityName = realMeta.name;
                query.count(tx, function (count) {
                    result += count;
                    next();
                });
            }, function () {
                callback(result);
            });
            return;
        }

        var joinSql = '';
        var additionalWhereSqls = this._additionalWhereSqls.slice(0);
        var mtm = this._manyToManyFetch;
        if (mtm) {
            joinSql += "LEFT JOIN `" + mtm.table + "` AS mtm ON mtm.`" + mtm.inverseProp + "` = `root`.`id` ";
            additionalWhereSqls.push("mtm.`" + mtm.prop + "` = " + tm.outId(mtm.id));
        }

        joinSql += this._additionalJoinSqls.join(' ');
        var args = [];
        var whereSql = "WHERE " + [this._filter.sql(meta, "root", args)].concat(additionalWhereSqls).join(' AND ');

        var sql = "SELECT COUNT(*) AS cnt FROM `" + entityName + "` AS `root` " + joinSql + " " + whereSql;

        session.flush(tx, function () {
            tx.executeSql(sql, args, function (results) {
                callback(parseInt(results[0].cnt, 10));
            });
        });
    };

    persistence.ManyToManyDbQueryCollection.prototype.persistQueries = function () {
        var queries = [];
        var meta = persistence.getMeta(this._obj._type);
        var inverseMeta = meta.hasMany[this._coll].type.meta;
        var tm = persistence.typeMapper;
        var rel = meta.hasMany[this._coll];
        var inv = inverseMeta.hasMany[rel.inverseProperty];
        var direct = rel.mixin ? rel.mixin.meta.name : meta.name;
        var inverse = inv.mixin ? inv.mixin.meta.name : inverseMeta.name;

        // Added
        for (var i = 0; i < this._localAdded.length; i++) {
            var columns = [direct + "_" + this._coll, inverse + '_' + rel.inverseProperty];
            var vars = [tm.outIdVar("?"), tm.outIdVar("?")];
            var args = [tm.entityIdToDbId(this._obj.id), tm.entityIdToDbId(this._localAdded[i].id)];
            if (rel.mixin) {
                columns.push(direct + "_" + this._coll + "_class");
                vars.push("?");
                args.push(meta.name);
            }
            if (inv.mixin) {
                columns.push(inverse + "_" + rel.inverseProperty + "_class");
                vars.push("?");
                args.push(inverseMeta.name);
            }
            queries.push(["INSERT INTO " + rel.tableName +
                  " (`" + columns.join("`, `") + "`) VALUES (" + vars.join(",") + ")", args]);
        }
        this._localAdded = [];
        // Removed
        for (var i = 0; i < this._localRemoved.length; i++) {
            queries.push(["DELETE FROM  " + rel.tableName +
                  " WHERE `" + direct + "_" + this._coll + "` = " + tm.outIdVar("?") + " AND `" +
                  inverse + '_' + rel.inverseProperty +
                  "` = " + tm.outIdVar("?"), [tm.entityIdToDbId(this._obj.id), tm.entityIdToDbId(this._localRemoved[i].id)]]);
        }
        this._localRemoved = [];
        return queries;
    };
};

if (typeof exports !== 'undefined') {
    exports.defaultTypeMapper = defaultTypeMapper;
    exports.config = config;
}
else {
    //window = window || {};
    if (!window) window = {};
    window.persistence = window.persistence || persistence || {};
    window.persistence.store = window.persistence.store || {};
    window.persistence.store.sql = {
        defaultTypeMapper: defaultTypeMapper,
        config: config
    };
}
;
try {
    if (!window) {
        window = {};
        //exports.console = console;
    }
} catch (e) {
    window = {};
    exports.console = console;
}

var persistence = (window && window.persistence) ? window.persistence : {};

if (!persistence.store) {
    persistence.store = {};
}

persistence.store.cordovasql = {};

/**
 * Configure the database connection (either sqliteplugin or websql)
 *
 * @param persistence
 * @param dbname
 * @param dbversion
 * @param description
 * @param size
 * @param backgroundProcessing
 */
persistence.store.cordovasql.config = function (persistence, dbname, dbversion, description, size, backgroundProcessing) {
    var conn = null;

    /**
     * Create a transaction
     *
     * @param callback
     *            the callback function to be invoked when the transaction
     *            starts, taking the transaction object as argument
     */
    persistence.transaction = function (callback) {
        if (!conn) {
            throw new Error("No ongoing database connection, please connect first.");
        } else {
            conn.transaction(callback);
        }
    };

    persistence.db = persistence.db || {};
    persistence.db.implementation = "unsupported";
    persistence.db.conn = null;

    /* Find out if sqliteplugin is loaded. Otherwise, we'll fall back to WebSql */
    if (!isRippleEmulator() && window && 'sqlitePlugin' in window) {
        persistence.db.implementation = 'sqliteplugin';
    } else if (window && window.openDatabase) {
        persistence.db.implementation = "websql";
    } else {
        // Well, we are stuck!
    }

    /*
     * Cordova SqlitePlugin
     */
    persistence.db.sqliteplugin = {};

    /**
     * Connect to Sqlite plugin database
     *
     * @param dbname
     * @param backgroundProcessing
     * @returns {{}}
     */
    persistence.db.sqliteplugin.connect = function (dbname, backgroundProcessing) {
        var that = {};
        var conn = window.sqlitePlugin.openDatabase({ name: dbname, bgType: backgroundProcessing, location: "default" });

        that.transaction = function (fn) {
            return conn.transaction(function (sqlt) {
                return fn(persistence.db.sqliteplugin.transaction(sqlt));
            });
        };
        return that;
    };


    /**
     * Run transaction on Sqlite plugin database
     *
     * @param t
     * @returns {{}}
     */
    persistence.db.sqliteplugin.transaction = function (t) {
        var that = {};
        that.executeSql = function (query, args, successFn, errorFn) {
            if (persistence.debug) {
                console.log(query, args);
            }
            window.rootlogger.get("persistence#transaction", ["persistence", "sql"]).debug(query, args);
            t.executeSql(query, args, function (_, result) {
                if (successFn) {
                    var results = [];
                    for (var i = 0; i < result.rows.length; i++) {
                        results.push(result.rows.item(i));
                    }
                    successFn(results);
                }
            }, function (err) {
                if (errorFn) {
                    // error callback provided: execute it passing the error object
                    errorFn(err);
                } else {
                    // otherwise use default error handling: logs a rich message in 'ERROR' level
                    persistence.defaultTransactionErrorHandler(query, args, err);
                }
            });
        };

        that.bulkSQL = function (queries, successFn, errorFn) {
            if (persistence.debug) {
                console.log(queries);
            }
            t.db.sqlBatch(queries, function () {
                if (successFn) {
                    successFn();
                }
            }, function (err) {
                if (errorFn) {
                    // error callback provided: execute it passing the error object
                    errorFn(err);
                } else {
                    // otherwise use default error handling: logs a rich message in 'ERROR' level
                    persistence.defaultTransactionErrorHandler(queries, args, err);
                }
            });
        };

        return that;
    };

    /*
     * WebSQL
     */
    persistence.db.websql = {};

    /**
     * Connect to the default WebSQL database
     *
     * @param dbname
     * @param dbversion
     * @param description
     * @param size
     * @returns {{}}
     */
    persistence.db.websql.connect = function (dbname, dbversion, description, size) {
        var that = {};
        var conn = openDatabase(dbname, dbversion, description, size);

        that.transaction = function (fn) {
            return conn.transaction(function (sqlt) {
                return fn(persistence.db.websql.transaction(sqlt));
            });
        };
        return that;
    };

    /**
     * Run transaction on WebSQL database
     *
     * @param t
     * @returns {{}}
     */
    persistence.db.websql.transaction = function (t) {
        var that = {};
        that.executeSql = function (query, args, successFn, errorFn) {
            if (persistence.debug) {
                console.log(query, args);
            }
            t.executeSql(query, args, function (_, result) {
                if (successFn) {
                    var results = [];
                    for (var i = 0; i < result.rows.length; i++) {
                        results.push(result.rows.item(i));
                    }
                    successFn(results);
                }
            }, function (err) {
                if (errorFn) {
                    // error callback provided: execute it passing the error object
                    errorFn(err);
                } else {
                    // otherwise use default error handling: logs a rich message in 'ERROR' level
                    persistence.defaultTransactionErrorHandler(query, args, err);
                }
            });
        };




        return that;
    };

    /**
     * Connect() wrapper
     *
     * @param dbname
     * @param dbversion
     * @param description
     * @param size
     * @param backgroundProcessing
     * @returns {*}
     */
    persistence.db.connect = function (dbname, dbversion, description, size, backgroundProcessing) {
        if (persistence.db.implementation == "sqliteplugin") {
            return persistence.db.sqliteplugin.connect(dbname, backgroundProcessing);
        } else if (persistence.db.implementation == "websql") {
            return persistence.db.websql.connect(dbname, dbversion, description, size);
        }

        return null;
    };

    /**
     * Set the sqlite dialect
     *
     * @type {{createTable: createTable, createIndex: createIndex}}
     */
    persistence.store.cordovasql.sqliteDialect = {

        /**
         * columns is an array of arrays, e.g. [["id", "VARCHAR(32)", "PRIMARY KEY"], ["name", "TEXT"]]
         *
         * @param tableName
         * @param columns
         * @returns {string}
         */
        createTable: function (tableName, columns) {
            var tm = persistence.typeMapper;
            var sql = "CREATE TABLE IF NOT EXISTS `" + tableName + "` (";
            var defs = [];
            for (var i = 0; i < columns.length; i++) {
                var column = columns[i];
                defs.push("`" + column[0] + "` " + tm.columnType(column[1]) + (column[2] ? " " + column[2] : ""));
            }
            sql += defs.join(", ");
            sql += ')';
            return sql;
        },

        /**
         * columns is array of column names, e.g. ["id"]
         * @param tableName
         * @param columns
         * @param options
         * @returns {string}
         */
        createIndex: function (tableName, columns, options) {
            options = options || {};
            return "CREATE " + (options.unique ? "UNIQUE " : "") + "INDEX IF NOT EXISTS `" + tableName + "__" + columns.join("_") +
              "` ON `" + tableName + "` (" +
              columns.map(function (col) {
                  return "`" + col + "`";
              }).join(", ") + ")";
        }
    };

    // Configure persistence for generic sql persistence, using sqliteDialect
    persistence.store.sql.config(persistence, persistence.store.cordovasql.sqliteDialect);

    // Make the connection
    conn = persistence.db.connect(dbname, dbversion, description, size, backgroundProcessing);
    if (!conn) {
        throw new Error("No supported database found in this browser.");
    }
};

try {
    exports.persistence = persistence;
} catch (e) {
}
;
/**
 * @license
 * Copyright (c) 2010 FÃ¡bio Rehm <fgrehm@gmail.com>
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 * 
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

if (!window.persistence) { // persistence.js not loaded!
  throw new Error("persistence.js should be loaded before persistence.migrations.js");
}

(function () {

  var Migrator = {
    migrations: [],

    version: function (callback) {
      persistence.transaction(function (t) {
        t.executeSql('SELECT current_version FROM schema_version', null, function (result) {
          if (result.length == 0) {
            t.executeSql('INSERT INTO schema_version VALUES (0)', null, function () {
              callback(0);
            });
          } else {
            callback(result[0].current_version);
          }
        });
      });
    },

    setVersion: function (v, callback) {
      persistence.transaction(function (t) {
        t.executeSql('UPDATE schema_version SET current_version = ?', [v], function () {
          Migrator._version = v;
          if (callback) callback();
        });
      });
    },

    setup: function (callback) {
      persistence.transaction(function (t) {
        t.executeSql('CREATE TABLE IF NOT EXISTS schema_version (current_version INTEGER)', null, function () {
          // Creates a dummy migration just to force setting schema version when cleaning DB
          Migrator.migration(0, { up: function () { }, down: function () { } });
          if (callback) callback();
        });
      });
    },

    // Method should only be used for testing
    reset: function (callback) {
      // Creates a dummy migration just to force setting schema version when cleaning DB
      Migrator.migrations = [];
      Migrator.migration(0, { up: function () { }, down: function () { } });
      Migrator.setVersion(0, callback);
    },

    migration: function (version, actions) {
      Migrator.migrations[version] = new Migration(version, actions);
      return Migrator.migrations[version];
    },

    migrateUpTo: function (version, callback) {
      var migrationsToRun = [];

      function migrateOne() {
        var migration = migrationsToRun.pop();

        if (!migration) callback();

        migration.up(function () {
          if (migrationsToRun.length > 0) {
            migrateOne();
          } else if (callback) {
            callback();
          }
        });
      }

      this.version(function (currentVersion) {
        for (var v = currentVersion + 1; v <= version; v++)
          migrationsToRun.unshift(Migrator.migrations[v]);

        if (migrationsToRun.length > 0) {
          migrateOne();
        } else if (callback) {
          callback();
        }
      });
    },

    migrateDownTo: function (version, callback) {
      var migrationsToRun = [];

      function migrateOne() {
        var migration = migrationsToRun.pop();

        if (!migration) callback();

        migration.down(function () {
          if (migrationsToRun.length > 0) {
            migrateOne();
          } else if (callback) {
            callback();
          }
        });
      }

      this.version(function (currentVersion) {
        for (var v = currentVersion; v > version; v--)
          migrationsToRun.unshift(Migrator.migrations[v]);

        if (migrationsToRun.length > 0) {
          migrateOne();
        } else if (callback) {
          callback();
        }
      });
    },

    migrate: function (version, callback) {
      if (arguments.length === 1) {
        callback = version;
        version = this.migrations.length - 1;
      }

      this.version(function (curVersion) {
        if (curVersion < version)
          Migrator.migrateUpTo(version, callback);
        else if (curVersion > version)
          Migrator.migrateDownTo(version, callback);
        else
          callback();
      });
    }
  }

  var Migration = function (version, body) {
    this.version = version;
    // TODO check if actions contains up and down methods
    this.body = body;
    this.actions = [];
  };

  Migration.prototype.executeActions = function (callback, customVersion) {
    var actionsToRun = this.actions;
    var version = (customVersion !== undefined) ? customVersion : this.version;

    persistence.transaction(function (tx) {
      function nextAction() {
        if (actionsToRun.length == 0)
          Migrator.setVersion(version, callback);
        else {
          var action = actionsToRun.pop();
          action(tx, nextAction);
        }
      }

      nextAction();
    });
  }

  Migration.prototype.up = function (callback) {
    if (this.body.up) this.body.up.apply(this);
    this.executeActions(callback);
  }

  Migration.prototype.down = function (callback) {
    if (this.body.down) this.body.down.apply(this);
    this.executeActions(callback, this.version - 1);
  }

  Migration.prototype.createTable = function (tableName, callback) {
    var table = new ColumnsHelper();

    if (callback) callback(table);

    var column;
    var sql = 'CREATE TABLE ' + tableName + ' (id VARCHAR(32) PRIMARY KEY';
    while (column = table.columns.pop())
      sql += ', ' + column;

    this.executeSql(sql + ')');
  }

  Migration.prototype.dropTable = function (tableName) {
    var sql = 'DROP TABLE ' + tableName;
    this.executeSql(sql);
  }

  Migration.prototype.addColumn = function (tableName, columnName, columnType) {
    var sql = 'ALTER TABLE ' + tableName + ' ADD ' + columnName + ' ' + columnType;
    this.executeSql(sql);
  }

  Migration.prototype.removeColumn = function (tableName, columnName) {
    this.action(function (tx, nextCommand) {
      var sql = 'select sql from sqlite_master where type = "table" and name == "' + tableName + '"';
      tx.executeSql(sql, null, function (result) {
        var columns = new RegExp("CREATE TABLE `\\w+` |\\w+ \\((.+)\\)").exec(result[0].sql)[1].split(', ');
        var selectColumns = [];
        var columnsSql = [];

        for (var i = 0; i < columns.length; i++) {
          var colName = new RegExp("((`\\w+`)|(\\w+)) .+").exec(columns[i])[1];
          if (colName == columnName) continue;

          columnsSql.push(columns[i]);
          selectColumns.push(colName);
        }
        columnsSql = columnsSql.join(', ');
        selectColumns = selectColumns.join(', ');

        var queries = [];
        queries.unshift(["ALTER TABLE " + tableName + " RENAME TO " + tableName + "_bkp;", null]);
        queries.unshift(["CREATE TABLE " + tableName + " (" + columnsSql + ");", null]);
        queries.unshift(["INSERT INTO " + tableName + " SELECT " + selectColumns + " FROM " + tableName + "_bkp;", null]);
        queries.unshift(["DROP TABLE " + tableName + "_bkp;", null]);

        persistence.executeQueriesSeq(tx, queries, nextCommand);
      });
    });
  }

  Migration.prototype.addIndex = function (tableName, columnName, unique, failOnError = true) {
    var sql = 'CREATE ' + (unique === true ? 'UNIQUE' : '') + ' INDEX ' + tableName + '_' + columnName + ' ON ' + tableName + ' (' + columnName + ')';
    this.executeSql(sql, null, failOnError);
  }

  Migration.prototype.removeIndex = function (tableName, columnName) {
    var sql = 'DROP INDEX ' + tableName + '_' + columnName;
    this.executeSql(sql);
  }

  Migration.prototype.executeSql = function (sql, args, failOnError = true) {
    this.action(function (tx, nextCommand) {
      let errCbck = null;
      if (!failOnError) {
        errCbck = (err) => {
          console.log(err);
          nextCommand();
        };
      }
      tx.executeSql(sql, args, nextCommand, errCbck);
    });
  }

  Migration.prototype.action = function (callback) {
    this.actions.unshift(callback);
  }

  var ColumnsHelper = function () {
    this.columns = [];
  }

  ColumnsHelper.prototype.text = function (columnName) {
    this.columns.unshift(columnName + ' TEXT');
  }

  ColumnsHelper.prototype.integer = function (columnName) {
    this.columns.unshift(columnName + ' INT');
  }

  ColumnsHelper.prototype.real = function (columnName) {
    this.columns.unshift(columnName + ' REAL');
  }

  ColumnsHelper.prototype['boolean'] = function (columnName) {
    this.columns.unshift(columnName + ' BOOL');
  }

  ColumnsHelper.prototype.date = function (columnName) {
    this.columns.unshift(columnName + ' DATE');
  }

  ColumnsHelper.prototype.json = function (columnName) {
    this.columns.unshift(columnName + ' TEXT');
  }

  // Makes Migrator and Migration available to tests
  persistence.migrations = {};
  persistence.migrations.Migrator = Migrator;
  persistence.migrations.Migration = Migration;
  persistence.migrations.init = function () { Migrator.setup.apply(Migrator, Array.prototype.slice.call(arguments, 0)) };

  persistence.migrate = function () { Migrator.migrate.apply(Migrator, Array.prototype.slice.call(arguments, 0)) };
  persistence.defineMigration = function () { Migrator.migration.apply(Migrator, Array.prototype.slice.call(arguments, 0)) };

}());
;
/*
 * jQuery Scanner Detection
 *
 * Copyright (c) 2013 Julien Maurel
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * Project home:
 * https://github.com/julien-maurel/jQuery-Scanner-Detection
 *
 * Version: 1.1.4
 *
 */
(function ($) {
    $.fn.scannerDetection = function (options) {

        if (options === null) {
            //removing the scanner listener, for the sake of application restoring best performance on inputs
            $(this).data('scannerDetection', { options: {} })
                .unbind('.scannerDetection').unbind('keydown.scannerDetection');
            return this;
        }

        // If string given, call onComplete callback
        if (typeof options === "string") {
            this.each(function () {
                this.scannerDetectionTest(options);
            });
            return this;
        }

        var defaults = {
            onComplete: false, // Callback after detection of a successfull scanning (scanned string in parameter)
            onError: false, // Callback after detection of a unsuccessfull scanning (scanned string in parameter)
            onReceive: false, // Callback after receive a char (scanned char in parameter)
            timeBeforeScanTest: 100, // Wait duration (ms) after keypress event to check if scanning is finished
            avgTimeByChar: 14, // Average time (ms) between 2 chars. Used to do difference between keyboard typing and scanning
            minLength: 3, // Minimum length for a scanning
            endChar: [9, 13], // Chars to remove and means end of scanning
            stopPropagation: false, // Stop immediate propagation on keypress event
            preventDefault: false // Prevent default action on keypress event
        };
        if (typeof options === "function") {
            options = { onComplete: options }
        }
        if (typeof options !== "object") {
            options = $.extend({}, defaults);
        } else {
            options = $.extend({}, defaults, options);
        }



        this.each(function () {
            var self = this, $self = $(self), firstCharTime = 0, lastCharTime = 0, stringWriting = '', callIsScanner = false, testTimer = false;
            var charBuffer = '';
            var focusedInput;
            var initScannerDetection = function () {
                firstCharTime = 0;
                stringWriting = '';
                charBuffer = '';

            };
            self.scannerDetectionTest = function (s) {
                // If string is given, test it
                if (s) {
                    firstCharTime = lastCharTime = 0;
                    stringWriting = s;
                    charBuffer = s;
                }
                // If all condition are good (length, time...), call the callback and re-initialize the plugin for next scanning
                // Else, just re-initialize
                if (stringWriting.length >= options.minLength && lastCharTime - firstCharTime < stringWriting.length * options.avgTimeByChar) {
                    var alphaString;
                    if (options.onComplete) {
                        //TODO: Narrow down the wrong characther here, instead of removing them all
                        alphaString = stringWriting ? stringWriting.replace(/\W/g, '') : null;
                        options.onComplete.call(self, alphaString);
                    }
                    $self.trigger('scannerDetectionComplete', {
                        string: stringWriting
                    });
                    initScannerDetection();
                    return true;
                } else {
                    if (options.onError) {
                        options.onError.call(self, stringWriting);
                    }
                    $self.trigger('scannerDetectionError', { string: stringWriting });
                    if (focusedInput) {
                        var newValue = $(focusedInput).val() + charBuffer;
                        $(focusedInput).val(newValue);
                        //to fire model update on angular 1.4.3+
                        angular.element($(focusedInput)).triggerHandler('input');
                        $(focusedInput).trigger('input');
                    }
                    initScannerDetection();
                    return false;
                }
            }

            $self.data('scannerDetection', { options: options })
                .unbind('.scannerDetection')
                .bind('keydown.scannerDetection', function (e) {


                    if (e.which >= 48 && e.which <= 90 && (e.target.type === "text" || e.target.type === "search")) {
                        e.preventDefault();
                        focusedInput = e.target;
                        if (e.shiftKey || e.which < 65) {
                            // capital letters and numbers
                            charBuffer = String.fromCharCode(e.which);
                        } else
                        {
                            //non capital letters
                            charBuffer = String.fromCharCode(e.which + 32);
                        }
                    } else {
                        focusedInput = null;
                    }



                    if (options.stopPropagation) e.stopImmediatePropagation();
                    if (options.preventDefault) e.preventDefault();

                    if (firstCharTime && options.endChar.indexOf(e.which) !== -1) {
                        e.preventDefault();
                        e.stopImmediatePropagation();
                        callIsScanner = true;
                    } else {
                        stringWriting += String.fromCharCode(e.which);
                        callIsScanner = false;
                    }

                    if (!firstCharTime) {
                        firstCharTime = Date.now();
                    }
                    lastCharTime = Date.now();

                    if (testTimer) clearTimeout(testTimer);
                    if (callIsScanner) {
                        self.scannerDetectionTest();
                        testTimer = false;
                    } else {
                        testTimer = setTimeout(self.scannerDetectionTest, options.timeBeforeScanTest);
                    }

                    if (options.onReceive) options.onReceive.call(self, e);
                    $self.trigger('scannerDetectionReceive', { evt: e });


                    // Add event on keydown because keypress is not triggered for non character keys (tab, up, down...)
                    // So need that to check endChar (that is often tab or enter) and call keypress if necessary
                    if (firstCharTime && options.endChar.indexOf(e.which) !== -1) {
                        // Clone event, set type and trigger it
                        var e2 = jQuery.Event('keypress', e);
                        e2.type = 'keypress.scannerDetection';
                        if (!focusedInput) {
                            $self.triggerHandler(e2);
                        }
                        // Cancel default
                        e.preventDefault();
                        e.stopImmediatePropagation();
                    }
                });
        });
        return this;
    }
})(jQuery);
;
(function (angular, cordova) {
    "use strict";

    /**
     * Manages rolling log files
     * v1.0.0
     * 
     * @author https://github.com/morinted/angular-cordova-rolling-logs
     * @author rbotti: changed source -> support for varargs (like $log and console.log), formatting errors, strict-mode, es6
     */
    const logModule = angular.module('rollingLog', []);

    // copied and adapted from angular.js's $log.formatError
    function formatToMessage(arg) {
        if (arg instanceof Error) {
            if (arg.stack) {
                arg = (arg.message && arg.stack.indexOf(arg.message) < 0)
                    ? `Error: ${arg.message}\n${arg.stack}`
                    : arg.stack;
            } else if (arg.sourceURL) {
                arg = `${arg.message}\n${arg.sourceURL}:${arg.line}`;
            }
            return arg;
        }
        if (!angular.isString(arg)) {
            try {
                const jsonValue = JSON.stringify(JSON.decycle(arg));
                return jsonValue;
            } catch (err) {
                return arg;
            }
            
        }
        return arg;
    }

    logModule.factory('$roll', ['$q', function ($q) {
            /**
             * CordovaFile is an internal service used to interface with
             * the filesystem while using promises instead of callbacks.
             */
            var cordovaFile = {
                // Instance variables to hold the current directory
                location: null,
                // And the current file writer
                writer: null   
            };

            // "Retrieve a DirectoryEntry or FileEntry using local URL"
            function resolveLocalFileSystemURL(directory) {
                const q = $q.defer();

                window.resolveLocalFileSystemURL(directory,
                     fileSystem => q.resolve(fileSystem),
                     err => q.reject(err)
                );

                return q.promise;
            }

            // "Request a file system in which to store application data."
            function getFilesystem() {
                const q = $q.defer();

                window.requestFileSystem(
                    LocalFileSystem.PERSISTENT, 1024 * 1024,
                    filesystem => q.resolve(filesystem),
                    err => q.reject(err)
                );

                return q.promise;
            }

            // Removes a file by its path
            cordovaFile.removeFile = function (filePath) {
                const q = $q.defer();

                getFilesystem().then(filesystem => {
                    filesystem.root.getFile(filePath, { create: false },
                        fileEntry => 
                            fileEntry.remove(() =>
                                q.resolve()
                            )
                        );
                });

                return q.promise;
            };

            // Moves a file by its current file entry to a new location/name
            cordovaFile.moveFile = function (fileEntry, newName) {
                const q = $q.defer();

                fileEntry.moveTo(cordovaFile.location, newName,
                    success => q.resolve(success),
                    error => q.reject(error)
                );

                return q.promise;
            };

            // Returns a promise that resolves the filesize of the file entry
            cordovaFile.getFileSize = function (fileEntry) {
                const q = $q.defer();

                fileEntry.file(
                    file => q.resolve(file.size),
                    err => q.reject(err)
                );

                return q.promise;
            };

            // Get file returns a file entry given a file path/name
            cordovaFile.getFile = function (fileName) {
                const q = $q.defer();

                if (!cordovaFile.location) {
                    q.reject('Please set location before getting a file.');
                } else {
                    // Get file if it exists, create if not
                    cordovaFile.location.getFile(fileName, { create: true, exclusive: false },
                        aFileEntry => q.resolve(aFileEntry),
                        err => q.reject(err)
                    );
                }

                return q.promise;
            };

            // Sets the current writer of cordovaFile, given a file entry.
            cordovaFile.setWriter = function (file) {
                const q = $q.defer();

                file.createWriter(
                    success => {
                        cordovaFile.writer = success;
                        // Seek to end of file for appending
                        cordovaFile.writer.seek(cordovaFile.writer.length);
                        q.resolve(cordovaFile.writer);
                    },
                    err => q.reject(err)
                );

                return q.promise;
            };

            // Appends 'toWrite' to the end of cordovaFile's current writer
            // See: setWriter
            cordovaFile.write = function (toWrite) {
                const q = $q.defer();

                if (!cordovaFile.writer) {
                    q.reject("No writer defined. Please use setWriter before writing.");
                } else {
                    cordovaFile.writer.onwrite = () => q.resolve('Write to file success.');
                        
                    cordovaFile.writer.onerror = err => q.reject(err);
                        
                    cordovaFile.writer.write(toWrite);
                }

                return q.promise;
            };

            // Sets the cordovaFile directory
            cordovaFile.setLocation = function (path) {
                const q = $q.defer();

                resolveLocalFileSystemURL(path)
                    .then(success => {
                        cordovaFile.location = success;
                        q.resolve(success);
                    },
                    err => q.reject(err));

                return q.promise;
            };

            // Rolling log external service
            return {
                logs: [], // holds logs in memory before writing to file
                logCurr: '.0.txt', // suffix for active log
                logLast: '.1.txt', // suffix for old log
                started: false, // whether logging has started

                /**
                 * Internal use: activate or deactivate pause listener
                 */
                listenForPause: function (listen) {
                    if (listen) {
                        document.addEventListener('pause', this.getOnPause(), false);
                    } else {
                        document.removeEventListener('pause', this.getOnPause(), false);
                    }
                },

                readCurrent: function () {
                    const logCurr = this.config.prefix + this.logCurr;
                    var deferred = $q.defer();

                    cordovaFile.getFile(logCurr).then(fileEntry => {

                        fileEntry.file(function(file) {
                            var reader = new FileReader();

                            reader.onloadend = function(e) {
                                deferred.resolve(this.result);
                            }

                            reader.readAsText(file);
                        });

                    }).catch(e => {
                        deferred.reject(e);
                    });

                    return deferred.promise;
                },

                /**
                 * Internal use: Writes logs to file based on config, also performs
                 * the roll.
                 */
                writeToFile: function (logs) {
                    if (!logs || logs.length <= 0) {
                        return $q.when("Success");
                    }
                    var log = "";
                    var logFile;
                    const deferredWrite = $q.defer();
                    const logCurr = this.config.prefix + this.logCurr;
                    const logLast = this.config.prefix + this.logLast;
                    // Get file entry based on log file name
                    cordovaFile.getFile(logCurr)
                        .then(aFileEntry => {
                            logFile = aFileEntry;
                            return cordovaFile.getFileSize(logFile);
                        })
                        .then(size => {
                            if (size > this.config.logSize) {
                                // We then return the original log all over again
                                return cordovaFile.moveFile(logFile, logLast)
                                    .then(success => 
                                        cordovaFile.getFile(logCurr)
                                    )
                                    .then(aFileEntry => {
                                        logFile = aFileEntry;
                                        return cordovaFile.setWriter(logFile);
                                    });
                            }
                            return cordovaFile.setWriter(logFile);
                        })
                        .then(() => { // we don't need the file writer that this returned
                            while (logs.length > 0) {
                                log += `\n${logs.shift()}`;
                            }
                            return cordovaFile.write(log);
                        })
                        .then(success => {
                            deferredWrite.resolve("success");
                        })
                        .catch(err => {
                            console.error(err, "Error writing to log file.. Adding old logs to logs variable for next time.");
                            logs.push(...log.split("\n"));
                            deferredWrite.reject(err);
                        })
                        .finally(() => {
                            this.started = true;
                        });

                    return deferredWrite.promise;
                },


                /**
                 * Internal use: Writes log to console, adds log to in-memory list,
                 * then calls to file if it is time.
                 */
                writeLog: function (level, args) {
                    // no messages to log
                    if (args.length <= 0) {
                        return;
                    }
                    const message = [].slice.call(args).map(formatToMessage).join(" ");
                    this.logs.push(message);
                    // add to queue for writing
                    // Only write to file if queue is large enough
                    // or on error.
                    if (this.started && (level === "error" || this.logs.length > this.config.eventBuffer)) {
                        this.started = false;
                        this.writeToFile(this.logs, this.directory);
                    }
                },

                /**
                * Internal use: Function called on device pause when
                * config.writeOnPause is enabled
                */
                getOnPause: function () {
                    // We need to give context to the callback
                    var logFactory = this;
                    return function () {
                        logFactory.writeNow();
                    };
                },


                // Default config
                config: {
                    logSize: 25600, // Size of files, in bytes
                    eventBuffer: 25, // Number of events before write
                    debug: false, // Write debug messages
                    console: false, // Write to JS console with $log
                    writeOnPause: false,
                    prefix: 'log',
                    directory: 'dataDirectory',
                },

                /**
                 * Use setConfig to change from the default config options above
                 */
                setConfig: function (options) {
                    if (!options) {
                        return this.config;
                    }
                    if (options.logSize !== undefined) {
                        this.config.logSize = parseInt(options.logSize, 10);
                    }
                    if (options.eventBuffer !== undefined) {
                        this.config.eventBuffer = parseInt(options.eventBuffer, 10);
                    }
                    if (options.debug !== undefined) {
                        this.config.debug = !!options.debug;
                    }
                    if (options.console !== undefined) {
                        this.config.console = !!options.console;
                    }
                    if (options.writeOnPause !== undefined) {
                        this.config.writeOnPause = !!options.writeOnPause;
                        this.listenForPause(this.config.writeOnPause);
                    }
                    if (options.prefix !== undefined) {
                        if (options.prefix.length >= 1) {
                            this.config.prefix = options.prefix;
                        }
                    }
                    if (options.directory !== undefined) {
                        // TODO check legality
                        this.config.directory = options.directory;
                    }
                    return this.config;
                },

                /**
                 * Starts logging. User must call once the device is
                 * ready so that the module doesn't start before Cordova initiates
                 */
                start: function () {
                    var deferredStart = $q.defer(), directory;
                    try {
                        if (!window.cordova) {
                            throw "Cordova not found";
                        }
                        directory = cordova.file[this.config.directory];
                        this.debug(`Setting location to Cordova file data directory: ${directory}`);
                        cordovaFile.setLocation(directory)
                            .then(success => {
                                this.started = true;
                                deferredStart.resolve('Rolling logger started.');
                            }, error => {
                                console.error(error);
                                deferredStart.reject('Rolling logger unable to start.');
                            });
                    } catch (e) {
                        console.error(e);
                        console.error('No file logging during this session');
                        deferredStart.reject('Rolling logger unable to start');
                    }
                    return deferredStart.promise;
                },

                /**
                 * Write in-memory logs immediately, disregarding the eventBuffer
                 * Called when device is paused if config.writeOnPause is enabled
                 */
                writeNow: function () {
                    return this.started
                        ? this.writeToFile(this.logs, this.directory)
                        : $q.reject("No file to write to");
                },

                /**
                 * Main log calls, mirroring $log in name.
                 */
                log: function () {
                    this.writeLog('log', arguments);
                },
                info: function () {
                    this.writeLog('info', arguments);
                },
                error: function () {
                    this.writeLog('error', arguments);
                },
                debug: function () {
                    this.writeLog('debug', arguments);
                },
                warn: function() {
                    this.writeLog("warn", arguments);
                },
                trace: function() {
                    this.writeLog("trace", arguments);
                }
            };
        }
    ]);

})(angular, cordova);;
(function (angular) {
    "use strict";

angular.module('ion-autocomplete', []).directive('ionAutocomplete', [
    '$ionicTemplateLoader', '$ionicBackdrop', '$ionicScrollDelegate', '$rootScope', '$document', '$q', '$parse', '$ionicPlatform', '$log', "$timeout",
    function ($ionicTemplateLoader, $ionicBackdrop, $ionicScrollDelegate, $rootScope, $document, $q, $parse, $ionicPlatform, $log, $timeout) {
        return {
            require: '?ngModel',
            restrict: 'A',
            scope: {
                model: '=ngModel',
                placeholder: '@',
                cancelLabel: '@',
                selectItemsLabel: '@',
                selectedItemsLabel: '@',
                templateUrl: '@',
                templateData: '=',
                itemsMethod: '&',
                itemsMethodValueKey: '@',
                itemValueKey: '@',
                itemViewValueKey: '@',
                multipleSelect: '@',
                itemsClickedMethod: '&',
                itemsRemovedMethod: '&',
                componentId: '@',
                modelToItemMethod: '&',
                loadingIcon: '@',
                hasUseWhereClause: '=',
                title: '@'
            },
            link: function (scope, element, attrs, ngModel) {

                // do nothing if the model is not set
                if (!ngModel) return;

                const contextSelector = "ion-content ion-item.item-text-wrap:first";

                // set the default values of the passed in attributes
                scope.placeholder = !scope.placeholder ? 'Search for...' : scope.placeholder;
                scope.cancelLabel = !scope.cancelLabel ? scope.multipleSelect === "true" ? 'Done' : 'Cancel' : scope.cancelLabel;
                scope.selectItemsLabel = !scope.selectItemsLabel ? 'Select an item...' : scope.selectItemsLabel;
                scope.selectedItemsLabel = !scope.selectedItemsLabel ? 'Selected items:' : scope.selectedItemsLabel;
                scope.templateUrl = !scope.templateUrl ? '' : scope.templateUrl;
                scope.loadingIcon = !scope.loadingIcon ? '' : scope.loadingIcon;
                scope.useWhereClause = true;
                scope.fontCache = null;

                // loading flag if the items-method is a function
                scope.showLoadingIcon = false;

                // the items, selected items and the query for the list
                scope.items = [];
                scope.selectedItems = [];
                scope.searchQuery = undefined;

                // returns the value of an item
                scope.getItemValue = function (item, key) {

                    // if it's an array, go through all items and add the values to a new array and return it
                    if (angular.isArray(item)) {
                        var items = [];
                        angular.forEach(item, function (itemValue) {
                            if (key && angular.isObject(item)) {
                                items.push($parse(key)(itemValue));
                            } else {
                                items.push(itemValue);
                            }
                        });
                        return items;
                    } else {
                        if (key && angular.isObject(item)) {
                            return $parse(key)(item);
                        }
                    }
                    return item;
                };

                function getDisplayableValue(item) {
                    var viewValue = scope.getItemValue(item, scope.itemViewValueKey);
                    if (!viewValue) return "";
                    viewValue = replaceAll(viewValue, "undefined|null", "");
                    return viewValue.startsWith(" -") || viewValue.endsWith("- ") ? replaceAll(viewValue, " - | -|- ", "") : viewValue;
                }

                function setViewValue(item) {
                    const viewValue = getDisplayableValue(item);
                    scope.$emit("sw:ionAutocomplete:viewValue", viewValue);
                    element.val(viewValue);
                }

                scope.$on("sw:association:resolved", (event, values) => {
                    // TODO: implement full path association identification --> case where there are inline compositions
                    const value = values[scope.componentId];
                    if (!value) return;
                    setViewValue(value.item);
                });

                // render the view value of the model
                ngModel.$render = function () {
                    const viewValue = getDisplayableValue(ngModel.$viewValue);
                    element.val(viewValue);
                    scope.$emit("sw:ionAutocomplete:viewValue", viewValue);
                };

                // set the view value of the model
                ngModel.$formatters.push(getDisplayableValue);

                // set the model value of the model
                ngModel.$parsers.push(function (viewValue) {
                    return scope.getItemValue(viewValue, scope.itemValueKey);
                });

                // the search container template
                const searchContainerTemplate = [
                    '<div class="ion-autocomplete-container modal">',
                        '<ion-header-bar class="bar-positive bar bar-header" align-title="center">',
                            '<div class="buttons buttons-left">',
                              '<span class="left-buttons">',
                                 '<button class="ion-autocomplete-cancel button-icon"><i class="fa fa-chevron-left"></i>&ensp;Back</button>',     
                              '</span>',
                            '</div>',
                            '<div class="title title-center header-item" style="left: 86px !important; right: 86px !important;">{{title}}</div>',
                            '<div class="buttons buttons-right">',
                              '<span class="right-buttons">',
                                 '<button class="ion-autocomplete-clear button-icon"><i class="fa fa-eraser"></i>&ensp;Clear</button>',
                              '</span>',
                            '</div>',
                        '</ion-header-bar>',
                        '<ion-header-bar class="bar-subheader bar-dark bar bar-header" align-title="center" ng-class="{\'hasusewhereclause\' : hasUseWhereClause}">',
                            '<label class="item-input-wrapper search">',
                                '<i class="placeholder-icon fa fa-search"></i>',
                                '<input type="search" class="ion-autocomplete-search" ng-model="searchQuery" ng-model-options="{ debounce: 500 }" placeholder="{{placeholder}}"/>',
                            '</label>',
                            //'<div class="ion-autocomplete-loading-icon" ng-if="showLoadingIcon && loadingIcon"><ion-spinner icon="{{loadingIcon}}"></ion-spinner></div>',
                            '<label class="item-input-wrapper preferred" ng-show="hasUseWhereClause">',
                                '<div class="label">Preferred</div>',
                                '<ion-toggle toggle-class="toggle-light" ng-model="useWhereClause"></ion-toggle>',
                            '</label>',
                        '</ion-header-bar>',
                        '<ion-content class="has-header" has-bouncing="false">',
                            '<ion-list>',
                                '<ion-item class="item-divider" ng-show="selectedItems.length > 0">{{selectedItemsLabel}}</ion-item>',
                                '<ion-item ng-repeat="selectedItem in selectedItems track by $index" type="item-text-wrap" class="item-icon-left item-icon-right">',
                                    '<i class="fa fa-check"></i>',
                                    '{{getItemValue(selectedItem, itemViewValueKey)}}',
                                    '<i class="fa fa-trash" style="cursor:pointer" ng-click="removeItem($index)"></i>',
                                '</ion-item>',
                                '<ion-item class="item-divider" ng-show="items.length > 0">{{selectItemsLabel}}</ion-item>',
                                '<ion-item class="item-divider" ng-show="!items || items.length === 0">No results were found.</ion-item>',
                                '<ion-item collection-repeat="item in items" item-height="getItemHeight(getItemValue(item, itemViewValueKey))" item-width="100%" type="item-text-wrap" ng-click="selectItem(item)" class="item item-text-wrap" style="padding-right: 26px;">',
                                    '<i ng-show="isItemSelected(item)" class="fa fa-check" style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%);"></i>',
                                    '{{getItemValue(item, itemViewValueKey)}}',
                                '</ion-item>',
                            '</ion-list>',
                            '<ion-infinite-scroll ng-if="moreItemsAvailable" on-infinite="loadMore()" distance="10%"></ion-infinite-scroll>',
                        '</ion-content>',
                    '</div>'
                ].join('');

                scope.templateCompileStarted = false;

                const compileTemplate = function () {
                    if (document.activeElement === element[0]) {
                        element[0].blur(); // avoid keybord popup
                    }

                    if (scope.templateCompileStarted) {
                        return;
                    }
                    scope.templateCompileStarted = true;

                    // compile the popup template
                    $ionicTemplateLoader.compile({
                        templateUrl: scope.templateUrl,
                        template: searchContainerTemplate,
                        scope: scope,
                        appendTo: $document[0].body
                    }).then(function (compiledTemplate) {

                        // get the compiled search field
                        var searchInputElement = angular.element(compiledTemplate.element.find('input'));

                        compiledTemplate.scope.isItemSelected = function (item) {
                            if (!item) {
                                return false;
                            }
                            return compiledTemplate.scope.getItemValue(item, compiledTemplate.scope.itemValueKey) === compiledTemplate.scope.model;
                        }

                        //calculate the item height based on the text length
                        compiledTemplate.scope.getItemHeight = function (value) {
                            const width = $(compiledTemplate.element).find(contextSelector).width();

                            //total number of lines
                            const textWidth = compiledTemplate.scope.getTextWidth(value);
                            const lines = Math.ceil(textWidth / width);

                            //calculated height
                            return lines * 20 + 32;
                        }

                        compiledTemplate.scope.getTextWidth = function (text) {
                            // re-use canvas object for better performance
                            const canvas = compiledTemplate.scope.getTextWidth.canvas || (compiledTemplate.scope.getTextWidth.canvas = document.createElement("canvas"));
                            const context = canvas.getContext("2d");

                            if (!scope.fontCache) {
                                scope.fontCache = $(compiledTemplate.element).find(contextSelector).css("font");
                            }
                            context.font = scope.fontCache;

                            const metrics = context.measureText(text);
                            return metrics.width;
                        }

                        // function which selects the item, hides the search container and the ionic backdrop if it is not a multiple select autocomplete
                        compiledTemplate.scope.selectItem = function (item) {

                            // clear the items and the search query
                            compiledTemplate.scope.items = [];
                            compiledTemplate.scope.searchQuery = undefined;

                            // if multiple select is on store the selected items
                            if (compiledTemplate.scope.multipleSelect === "true") {

                                if (!isKeyValueInObjectArray(compiledTemplate.scope.selectedItems,
                                        compiledTemplate.scope.itemValueKey, scope.getItemValue(item, scope.itemValueKey))) {
                                    // create a new array to update the model. See https://github.com/angular-ui/ui-select/issues/191#issuecomment-55471732
                                    compiledTemplate.scope.selectedItems = compiledTemplate.scope.selectedItems.concat([item]);
                                }

                                // set the view value and render it
                                ngModel.$setViewValue(compiledTemplate.scope.selectedItems);
                                ngModel.$render();
                            } else {
                                // set the view value and render it
                                ngModel.$setViewValue(item);
                                ngModel.$render();

                                // hide the container and the ionic backdrop
                                hideSearchContainer();
                            }

                            // call items clicked callback
                            if (angular.isFunction(compiledTemplate.scope.itemsClickedMethod)) {
                                compiledTemplate.scope.itemsClickedMethod({
                                    callback: {
                                        item: item,
                                        componentId: compiledTemplate.scope.componentId,
                                        selectedItems: compiledTemplate.scope.selectedItems.slice()

                                    }
                                });
                            }
                        };

                        // function which removes the item from the selected items.
                        compiledTemplate.scope.removeItem = function (index) {
                            // remove the item from the selected items and create a copy of the array to update the model.
                            // See https://github.com/angular-ui/ui-select/issues/191#issuecomment-55471732
                            var removed = compiledTemplate.scope.selectedItems.splice(index, 1)[0];
                            compiledTemplate.scope.selectedItems = compiledTemplate.scope.selectedItems.slice();

                            // set the view value and render it
                            ngModel.$setViewValue(compiledTemplate.scope.selectedItems);
                            ngModel.$render();

                            // call items clicked callback
                            if (angular.isFunction(compiledTemplate.scope.itemsRemovedMethod)) {
                                compiledTemplate.scope.itemsRemovedMethod({
                                    callback: {
                                        item: removed,
                                        selectedItems: compiledTemplate.scope.selectedItems.slice(),
                                        componentId: compiledTemplate.scope.componentId
                                    }
                                });
                            }
                        };

                        // object to store search container state
                        var searchContainer = {
                            showing: false
                        };

                        function doQuery(query, pageNumber) {
                            if (searchContainer && !searchContainer.showing) {
                                return;
                            }

                            pageNumber = pageNumber || 1;
                            compiledTemplate.scope.lastPage = pageNumber;

                            // right away return if the query is undefined to not call the items method for nothing
                            if (query === undefined) {
                                return;
                            }

                            // if the search query is empty, clear the items
                            if (query == '' && pageNumber === 1) {
                                compiledTemplate.scope.items = [];
                            }

                            if (angular.isFunction(compiledTemplate.scope.itemsMethod)) {

                                // show the loading icon
                                compiledTemplate.scope.showLoadingIcon = true;

                                const queryObject = {
                                    query: query,
                                    useWhereClause: compiledTemplate.scope.useWhereClause,
                                    pageNumber: pageNumber
                                };

                                // if the component id is set, then add it to the query object
                                if (compiledTemplate.scope.componentId) {
                                    queryObject["componentId"] = compiledTemplate.scope.componentId;
                                }

                                // convert the given function to a $q promise to support promises too
                                var promise = $q.when(compiledTemplate.scope.itemsMethod(queryObject));

                                promise.then(function (promiseData) {
                                    $timeout(() => {
                                        // if the given promise data object has a data property use this for the further processing as the
                                        // standard httpPromises from the $http functions store the response data in a data property
                                        if (promiseData && promiseData.data) {
                                            promiseData = promiseData.data;
                                        }

                                        // set the items which are returned by the items method
                                        const newItems = compiledTemplate.scope.getItemValue(promiseData, compiledTemplate.scope.itemsMethodValueKey);
                                        if (pageNumber === 1) {
                                            compiledTemplate.scope.items = newItems;
                                        } else {
                                            compiledTemplate.scope.$broadcast('scroll.infiniteScrollComplete');
                                            compiledTemplate.scope.items = compiledTemplate.scope.items.concat(newItems);
                                        }
                                        compiledTemplate.scope.moreItemsAvailable = newItems.length > 0;

                                        // force the collection repeat to redraw itself as there were issues when the first items were added
                                        $ionicScrollDelegate.resize();

                                        // hide the loading icon
                                        compiledTemplate.scope.showLoadingIcon = false;
                                    }, 0);
                                }, function (error) {
                                    // hide the loading icon
                                    compiledTemplate.scope.showLoadingIcon = false;

                                    // reject the error because we do not handle the error here
                                    return $q.reject(error);
                                });
                            }
                        }

                        compiledTemplate.scope.loadMore = function () {
                            const query = compiledTemplate.scope.searchQuery === undefined ? "" : compiledTemplate.scope.searchQuery;
                            doQuery(query, compiledTemplate.scope.lastPage + 1);
                        }

                        // watcher on the search field model to update the list according to the input
                        compiledTemplate.scope.$watch('searchQuery', function (query) {
                            doQuery(query);
                        });

                        compiledTemplate.scope.$watch('useWhereClause', function () {
                            const query = compiledTemplate.scope.searchQuery === undefined ? "" : compiledTemplate.scope.searchQuery;
                            doQuery(query);
                        });

                        var displaySearchContainer = function () {
                            // container already showing: do nothing
                            if (searchContainer.showing) {
                                return;
                            }
                            $ionicBackdrop.retain();
                            compiledTemplate.element.css('display', 'block');
                            scope.$deregisterBackButton = $ionicPlatform.registerBackButtonAction(function () {
                                hideSearchContainer();
                            }, 300);
                            // mark container as showing
                            searchContainer.showing = true;
                        };

                        var hideSearchContainer = function () {
                            compiledTemplate.element.css('display', 'none');
                            $ionicBackdrop.release();
                            scope.$deregisterBackButton && scope.$deregisterBackButton();
                            // mark container as not showing anymore
                            searchContainer.showing = false;
                        };

                        // object to store if the user moved the finger to prevent opening the modal
                        var scrolling = {
                            moved: false,
                            startX: 0,
                            startY: 0
                        };

                        // store the start coordinates of the touch start event
                        var onTouchStart = function (e) {
                            $log.get("ionautocomplete#ontouchstart").trace("ontouchstart handler");
                            scrolling.moved = false;
                            // Use originalEvent when available, fix compatibility with jQuery
                            if (typeof (e.originalEvent) !== 'undefined') {
                                e = e.originalEvent;
                            }
                            scrolling.startX = e.touches[0].clientX;
                            scrolling.startY = e.touches[0].clientY;
                        };

                        // check if the finger moves more than 10px and set the moved flag to true
                        var onTouchMove = function (e) {
                            $log.get("ionautocomplete#ontouchmove").trace("ontouchmove handler");
                            // Use originalEvent when available, fix compatibility with jQuery
                            if (typeof (e.originalEvent) !== 'undefined') {
                                e = e.originalEvent;
                            }
                            if (Math.abs(e.touches[0].clientX - scrolling.startX) > 10 ||
                                Math.abs(e.touches[0].clientY - scrolling.startY) > 10) {
                                scrolling.moved = true;
                            }
                        };

                        // click handler on the input field to show the search container
                        const onClick = ionic.debounce(function (event) {
                            $log.get("ionautocomplete#onclick").trace("onclick handler");
                            // only open the dialog if was not touched at the beginning of a legitimate scroll event
                            if (scrolling.moved || ionic.scroll.isScrolling) {
                                return;
                            }

                            if (event) {
                                // prevent the default event and the propagation
                                event.preventDefault();
                                event.stopPropagation();
                            }

                            // show the ionic backdrop and the search container
                            displaySearchContainer();

                            doQuery("");
                            // force the collection repeat to redraw itself as there were issues when the first items were added
                            $ionicScrollDelegate.resize();
                        }, 0);

                        var isKeyValueInObjectArray = function (objectArray, key, value) {
                            for (var i = 0; i < objectArray.length; i++) {
                                if (scope.getItemValue(objectArray[i], key) === value) {
                                    return true;
                                }
                            }
                            return false;
                        };

                        // function to call the model to item method and select the item
                        var resolveAndSelectModelItem = function (modelValue) {
                            // convert the given function to a $q promise to support promises too
                            var promise = $q.when(compiledTemplate.scope.modelToItemMethod({ modelValue: modelValue }));

                            promise.then(function (promiseData) {
                                // select the item which are returned by the model to item method
                                compiledTemplate.scope.selectItem(promiseData);
                            }, function (error) {
                                // reject the error because we do not handle the error here
                                return $q.reject(error);
                            });
                        };

                        // bind the handlers to the click and touch events of the input field
                        element.bind('touchstart', onTouchStart);
                        element.bind('touchmove', onTouchMove);
                        element.bind('click focus', onClick);

                        // cancel handler for the cancel button which clears the search input field model and hides the
                        // search container and the ionic backdrop
                        $(compiledTemplate.element).find(".ion-autocomplete-cancel").bind('click', function (event) {
                            compiledTemplate.scope.searchQuery = undefined;
                            hideSearchContainer();
                        });

                        $(compiledTemplate.element).find(".ion-autocomplete-clear").bind('click', function (event) {
                            compiledTemplate.scope.items = [];
                            ngModel.$setViewValue(null);
                            ngModel.$render();
                            compiledTemplate.scope.searchQuery = undefined;
                            hideSearchContainer();
                        });

                        // prepopulate view and selected items if model is already set
                        if (compiledTemplate.scope.model && angular.isFunction(compiledTemplate.scope.modelToItemMethod)) {
                            if (compiledTemplate.scope.multipleSelect === "true" && angular.isArray(compiledTemplate.scope.model)) {
                                angular.forEach(compiledTemplate.scope.model, function (modelValue) {
                                    resolveAndSelectModelItem(modelValue);
                                });
                            } //else {
                            //resolveAndSelectModelItem(compiledTemplate.scope.model);
                            //}
                        }

                        // opens the modal on template compiled
                        onClick();
                    });
                }

                element.bind("touchend click focus", compileTemplate);
            }
        };
    }
]).directive('ionAutocomplete', function () {
    return {
        require: '?ngModel',
        restrict: 'E',
        template: '<textarea ion-autocomplete class="ion-autocomplete item-text-wrap" autocomplete="off" autosize-textarea></textarea>',
        replace: true
    }
});

})(angular);
;
(function (angular) {
    "use strict";

    angular.module("persistence.offline", []);

})(angular);;
(function (angular, persistence) {
    /**
     * entities: exposed as provider propertiy so it can be configured by the modules that use them.
     * Usage in config:
     * angular.module("myApp", ["persistence.offline"]).config(["offlineEntitiesProvider", function(entitiesProvider){
     *     entitiesProvider.entities.MyTable = persistence.define("MyTable", { ... }); 
     * }]);
     * Usage in run, service, controller, etc:
     * app.controller("MyCtrl", ["$scope", "offlineEntities", function($scope, entities){
     *      $scope.newMyTable = function(){
     *          var record = new entities.MyTable();
     *          // ...
     *      };
     * }])
     */
    angular.module("persistence.offline").provider("offlineEntities", [function () {
        // service instance
        var entities = {};

        var provider = {
            // access to the service instance in config time
            entities: entities,
            // alias to persistence.define
            define: function (name, options) {
                entities[name] = persistence.define(name, options);
            },
            // service constructor
            $get: [function () {
                return entities;
            }]
        };
        return provider;
    }]);

})(angular, persistence);;
(function (angular, persistence) {
    "use strict";
    function offlineMigrationService($q, $log, offlineMigrations,swdbDAO) {

        const decorateMigrator = function () {
            const migrator = persistence.migrations.Migrator;
            const Migration = persistence.migrations.Migration;
            const migrations = migrator.migrations.slice(1);

            const log = $log.getInstance("offlineMigrationService");

            // migration method that uses a table to control each migration
            migrator.migrateSw = function() {
                const dbMigrationsIds = [];
                return persistence.runSql("select id from migrations").then((dbMigrations) => {
                    if (!dbMigrations) {
                        return $q.when();
                    }

                    angular.forEach(dbMigrations, (dbMigration) => {
                        dbMigrationsIds.push(dbMigration.id);
                    });

                    const migrationsToRun = [];
                    angular.forEach(migrations, (migration) => {
                        if (!migration.body.id) {
                            log.warn("Migration ignored due to absence of id.");
                        }

                        if (migration.body.id && dbMigrationsIds.indexOf(migration.body.id) < 0) {
                            migrationsToRun.push(migration);
                        }
                    });

                    const deferred = $q.defer();
                    const callback = function () {
                        deferred.resolve();
                    }

                    const reversedMigrationsToRun = migrationsToRun.reverse(); // migrations reversed to use pop
                    const migrateOne = function () {
                        const migration = reversedMigrationsToRun.pop();
                        if (!migration) {
                            callback();
                            return;
                        }

                        const id = migration.body.id;
                        migration.up(function () {
                            persistence.runSql("insert into migrations (id,applied) values (?,?)", [id, new Date().getTime()]).then(() => {
                                if (reversedMigrationsToRun.length > 0) {
                                    migrateOne();
                                } else {
                                    callback();
                                }
                            });
                        });
                    }
                    migrateOne();

                    return deferred.promise;
                });
            };

            // new method to declare varchar and numeric types
            const originalPrototype = Migration.prototype.createTable;
            Migration.prototype.createTable = function(tableName, callback) {
                const wrapper = (table) => {
                    table.varchar = function (columnName, size) {
                        table.columns.unshift(`${columnName} VARCHAR(${size})`);
                    }
                    table.numeric = function (columnName) {
                        table.columns.unshift(`${columnName} NUMERIC`);
                    }
                    callback(table);
                }
                originalPrototype.call(this, tableName, wrapper);
            }

            // adding an extra "_" on index name to be the same pattern as indexes created from persistence.js hasOne and hasMany
            Migration.prototype.addIndex = function (tableName, columnName, unique, indexName, failOnError = true) {
                const sql = swdbDAO.addIndexQuery(tableName, columnName, unique, indexName);
                this.executeSql(sql, null, failOnError);
            }
        }

        const setupMigrator = function() {
            return persistence.runSql("CREATE TABLE IF NOT EXISTS migrations (id VARCHAR(255) PRIMARY KEY, applied DATE)").then(() => {
                decorateMigrator();
            });
        }


        const migrate = function () {
            angular.forEach(offlineMigrations, (offlineMigration, version) => {
                persistence.defineMigration(version + 1, offlineMigration);
            });

            const deferred = $q.defer();
            persistence.migrations.init(() => {
                setupMigrator().then(() => {
                    return persistence.migrations.Migrator.migrateSw();
                }).then(() => {
                    deferred.resolve();
                });
            });

            return deferred.promise;
        }

        const service = {
            migrate
        };
        return service;
    }


    //#region Service registration
    angular.module("persistence.offline").factory("offlineMigrationService", ["$q", "$log", "offlineMigrations", "swdbDAO", offlineMigrationService]);
    //#endregion

})(angular, persistence);;
(function (angular) {
    /**
     * Same of offlineEntities.js but for migrations.
     */
    angular.module("persistence.offline").provider("offlineMigrations", function () {
        // service instance
        const migrationGroups = {};

        function pad(num, size) {
            var s = num+"";
            while (s.length < size) s = `0${s}`;
            return s;
        }

        class MigrationGroup {
            // id has max size = 99999999
            // the id defines the order of migration groups run
            constructor(id, tag) {
                this.id = id;
                this.tag = tag;
                this.stringId = pad(id, 8);
                this.migrations = [];
            }

            // tag has max length = 26 characters
            addMigration(tag, migration) {
                // console.log(`adding migration ${tag}`)
                migration.id = this.stringId + "-" + (this.tag || "") + "-" + (tag || "");
                this.migrations.push(migration);
            }
        }

        const provider = {
            // access to the service instance in config time
            migrationGroups: migrationGroups,
            createMigrationGroup: function (id, tag) {
                const group = new MigrationGroup(id, tag);
                migrationGroups[id] = group;
                return group;
            },
            // service constructor
            $get: [function () {
                var migrations = [];
                var groupIds = [];
                angular.forEach(migrationGroups, (migrationGroup, id) => {
                    if (!id || !migrationGroups.hasOwnProperty(id)) {
                        return;
                    }
                    groupIds.push(Number(id));
                });

                groupIds = groupIds.sort((a, b) => { return a - b });
                angular.forEach(groupIds, (id) => {
                    migrations = migrations.concat(migrationGroups[id].migrations);
                });

                return migrations;
            }]
        };
        return provider;
    });

})(angular);;
(function (angular, persistence) {
    "use strict";

    /**
     * Service with "init" hook to initialize persistence's Database.
     * @constructor
     */
    function offlinePersitenceBootstrap($rootScope, $q, $log, offlineMigrationService) {
        //#region Utils
        const listeners = [];
        var persistenceReady = false;

        const log = $log.get("offlinePersitenceBootstrap");

        var runSql = function (query, params) {
            var deferred = $q.defer();
            persistence.transaction(function (tx) {
                tx.executeSql(query, params,
                    function (results) {
                        if (persistence.debug) {
                            console.log(results);
                        }
                        deferred.resolve(results);
                        // workaround for tests
                        if (typeof (jasmine) !== "undefined" ) {
                            $rootScope.$digest();
                        }
                    }, function (cause) {
                        var msg = "An error ocurred when executing the query '{0}'".format(query);
                        if (params && params.length > 0) msg += " with parameters {0}".format(params);
                        var error = new Error(msg);
                        error.cause = cause;
                        console.error(error);
                        deferred.reject(error);
                    });
            });
            return deferred.promise;
        };

        const sendPersistenceReady = function() {
            persistenceReady = true;
            angular.forEach(listeners, (listener) => {
                listener.persistenceReady();
            });
            listeners.splice(0, listeners.length); // avoid memory leaks
        }
        //#endregion

        //#region Public methods
        function init() {
            log.info("Initing Persistence...");
            // initializing database
            persistence.store.cordovasql.config(persistence, "offlineswdb", "1.0", "SWDB OffLine instance", 5 * 1024 * 1024, 0);
            persistence.debug = sessionStorage["logsql"] === "true" || sessionStorage["loglevel"] === "debug" || sessionStorage["log_persistence"] === "debug";
            // adding some functionalities to persistence
            persistence.runSql = runSql;
            
            log.info("Start Migrations...");
            return offlineMigrationService.migrate().then(() => {
                log.info("Persistence Ready.");
                sendPersistenceReady();
            });
        }

        function addPersistenceReadyListener(listener) {
            if (!listener || !listener.persistenceReady) {
                return;
            }

            if (persistenceReady) {
                listener.persistenceReady();
            } else {
                listeners.push(listener);
            }
        }
        //#endregion

        //#region Service Instance
        const service = {
            init,
            addPersistenceReadyListener
        };

        return service;
        //#endregion
    }
    //#region Service registration
    angular.module("persistence.offline").factory("offlinePersitenceBootstrap", ["$rootScope", "$q", "$log", "offlineMigrationService", offlinePersitenceBootstrap]);
    //#endregion


})(angular, persistence);;
(function (angular) {
    "use strict";

    const day = 24 * 60 * 60 * 1000;

    function queryListBuilderService(offlineSchemaService, searchIndexService, metadataModelService, $log, securityService) {
        //#region Utils

        const log = $log.get("queryListBuilderService", ["list", "search"]);

        function getLaborCode() {
            //TODO: make more generic...
            const user = securityService.currentFullUser();
            if (user == null) {
                return securityService.logout();
            }
            let realLabor = user.properties["laborcode"];
            if (!realLabor) {
                //keeping here for compatibility backwards
                const personId = securityService.currentFullUser()["PersonId"];

                const dotIndex = personId.indexOf(".");
                if (dotIndex !== -1) {
                    realLabor = personId.substring(0, 1).toUpperCase() + personId.substring(dotIndex + 1, personId.length).toUpperCase();
                }
            }
            return realLabor;
        }

        function buildExtraLaborAttribute(childListSchema, childEntityName) {
            
            const realLabor = getLaborCode();


            const laborIdxName = searchIndexService.getIndexColumn(childListSchema.applicationName, childListSchema, "laborcode").replace("`root`", "`" + childEntityName + "`");

            return `${laborIdxName} LIKE '${realLabor}'`;

        }


        function doBuildLeftJoin(mainListSchema, childEntityName) {



            const entityAssociation = mainListSchema.offlineAssociations[childEntityName];
            const application = metadataModelService.getApplicationByName(entityAssociation.to, true);
            const childListSchema = application.data.schemasList.find(s => s.stereotypeAttr === "list");

            const childTable = application.association ? "AssociationData" : "DataEntry";

            let query = ` left join ${childTable} as \`${childEntityName}\` on (`;

            const primaryAttribute = entityAssociation.attributes.find(a => !!a.primary);

            const mainIdx = searchIndexService.getIndexColumn(mainListSchema.applicationName, mainListSchema, primaryAttribute.from);
            const leftJoinedIndex = searchIndexService.getIndexColumn(childListSchema.applicationName, childListSchema, primaryAttribute.to).replace("`root`", "`" + childEntityName + "`");


            let extraLaborQuery = "1=1";
            //TODO:review
            if (mainListSchema.applicationName.equalsAny("workorder", "todayworkorder", "pastworkorder")) {
                extraLaborQuery = buildExtraLaborAttribute(childListSchema, childEntityName);
            }

            //TODO: make it generic, cause now itï¿½s all tied to assignment child application
            const associatioNameQuery = "`" + childEntityName + "`" + ".application= 'assignment'";

            const now = new Date();
            const todayTime = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0).getTime();
            const tomorrowTime = todayTime + day;

            //this handles SWOFF-342
            let duplicateQuery = "`" + childEntityName + "`.dateindex02 = (select max(b.dateindex02) from AssociationData b where b.textindex01 = `" + childEntityName + "`.textindex01 and b.application = 'assignment' and b.textindex02 = " + `'${getLaborCode()}'`;

            if (mainListSchema.applicationName === "todayworkorder") {
                duplicateQuery += ` and b.dateindex02 <= ${tomorrowTime}`
            }

            else if (mainListSchema.applicationName === "pastworkorder"){
                duplicateQuery += ` and b.dateindex02 < ${todayTime}`
            }

            duplicateQuery += ")";


            query += `${mainIdx} = ${leftJoinedIndex} and ${extraLaborQuery} and ${associatioNameQuery}  and ${duplicateQuery} )`;
            return query;
        }




        //#endregion

        //#region Public methods

        /**
         *  Builds eventual extra parameters related to left join entities for the query to be performed on the list page:
         *      1) additionalJoins --> the left join queries
         *      2) extraProjectionFields --> the fields to be selected from these joined entities (datamap basically)
         * 
         * @param {} listSchema current list schema
         * @param {} baseQuery 
         * @param {} queryObj 
         * @returns {} 
         */
        function buildJoinParameters(listSchema) {


            const joinedfields = listSchema.displayables.filter(a => a.attribute.startsWith("#") && a.attribute.contains(".")).map(a => a.attribute);
            const joinedIndexes = searchIndexService.getSearchColumnsByApp(listSchema.applicationName).find(a => a.startsWith("#") && a.contains("."));

            const allAttributes = joinedIndexes ? new Set(joinedfields.concat(joinedIndexes)) : joinedfields;

            if (allAttributes.length === 0) {
                //no extra parameters needed
                return {};
            }
            log.debug("building left join parameters");

            const extraProjectionFields = new Map();
            const additionalJoins = [];

            const leftJoinEntities = new Set();

            allAttributes.forEach(attribute => {
                const entityName = offlineSchemaService.findRelatedEntityName(attribute).entityName;
                if (!extraProjectionFields.has(entityName)) {
                    // should be added only once
                    log.trace(`adding entity ${entityName} as a left join`);
                    extraProjectionFields.set(entityName, { field: "`" + entityName + "`" + ".datamap", alias: "`#datamap." + entityName + "`" });
                }
                leftJoinEntities.add(entityName);
            });


            leftJoinEntities.forEach(entity => {
                additionalJoins.push(doBuildLeftJoin(listSchema, entity));
            });

            return { additionalJoins, extraProjectionFields: Array.from(extraProjectionFields.values()),leftJoinEntities: Array.from(leftJoinEntities) };
        }


        //#endregion

        //#region Service Instance
        const service = {
            buildJoinParameters
        };
        return service;
        //#endregion
    }

    //#region Service registration

    angular.module("persistence.offline").factory("queryListBuilderService", ["offlineSchemaService", "searchIndexService", "metadataModelService", "$log", "securityService", queryListBuilderService]);

    //#endregion

})(angular);;
(function (angular, persistence) {
    "use strict";

    angular.module("persistence.offline").factory("swdbDAO", ["$q", "offlineEntities", function ($q, entities) {

        //creating namespace for the entities, to avoid collisions

        function getInstance(entity) {
            if (!entities[entity]) {
                throw new Error("entity {0} not found".format(entity));
            }
            //            return persistence.define(entity);
            return entities[entity];
        }

        function createFilter(entity, queryString, queryoptions) {
            queryoptions = queryoptions || {};
            const pageNumber = queryoptions.pageNumber || 1;
            const orderProperty = queryoptions.orderby || null;
            const orderascending = queryoptions.orderbyascending;
            const pageSize = queryoptions.pagesize;
            const projectionFields = queryoptions.projectionFields || [];
            const extraProjectionFields = queryoptions.extraProjectionFields || [];
            const additionalJoins = queryoptions.additionalJoins || [];
            const queryToUse = queryoptions.fullquery;
            const prefetch = queryoptions.prefetch;
            var filter = getInstance(entity).all();


            if (pageSize) {
                filter = filter.limit(pageSize);
                filter = filter.skip((pageSize * (pageNumber - 1)));
            }

            filter._additionalWhereSqls = [];
            filter._projectionFields = [];
            filter._extraProjectionFields = [];
            filter._additionalJoinSqls = [];
            filter._querytoUse = null;

            if (queryString) {
                filter._additionalWhereSqls.push(queryString);
            }
            if (projectionFields.length > 0) {
                filter._projectionFields = projectionFields;
            }
            if (additionalJoins.length > 0) {
                filter._additionalJoinSqls = additionalJoins;
            }

            if (extraProjectionFields.length > 0) {
                filter._extraProjectionFields = extraProjectionFields;
            }
            if (prefetch) {
                filter = filter.prefetch(prefetch);
            }
            if (orderProperty) {
                filter = filter.order(orderProperty, orderascending);
            }
            if (queryToUse) {
                filter._querytoUse = queryToUse;
            }
            return filter;

        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="entity">the name of the entity to load</param>
        /// <param name="memoryObject">the object to take as a parameter, so that if it contains an id, that will be used to try to load the persistent instance from cache,
        ///  otherwise a fresh new copy will be used, with all its properties merged into the persistent instance.</param>
        /// <returns type="promise">returns a promise that will pass the loaded instance to the chain</returns>
        function instantiate(entity, memoryObject, mergingFunction) {
            if (!entities[entity]) {
                throw new Error("entity {0} not found".format(entity));
            }

            memoryObject = memoryObject || {};

            var deferred = $q.defer();


            var ob = entities[entity];
            if (memoryObject.id == null || (memoryObject._type && memoryObject._type != entity)) {
                //if the memory object doesnÂ´t contain an id, then we donÂ´t need to check on persistence cache, 
                //just instantiate a new one
                const transientEntity = new ob();
                if (mergingFunction) {
                    deferred.resolve(mergingFunction(memoryObject, transientEntity));
                } else {
                    deferred.resolve(mergeObjects(memoryObject, transientEntity));
                }
                return deferred.promise;
            }


            //since it has an id, thereÂ´s a chance itÂ´s present on session cache
            ob.load(memoryObject.id, function (loadedObject) {
                if (!loadedObject) {
                    //if not found in cache, letÂ´s instantiate a new one anyway
                    loadedObject = new ob();
                }
                if (mergingFunction) {
                    deferred.resolve(mergingFunction(memoryObject, loadedObject));
                } else {
                    deferred.resolve(mergeObjects(memoryObject, loadedObject));
                }
            });

            return deferred.promise;;
        };

        function findById(entity, id) {
            //var deferred = $q.defer();
            const dbEntity = entities[entity];
            if (!dbEntity) {
                return $q.reject(new Error("entity {0} not found".format(entity)));
            }
            return this.findSingleByQuery(entity, `id='${id}'`);
        };

        /// <summary>
        /// 
        /// </summary>
        /// <param name="entity">The name of the table to lookup</param>
        /// <param name="options">
        /// 
        ///  pagesize: number of items per page. if undefined, it will bring all the results
        ///  pagenumber: page to fetch. if undefined, no limit will 
        /// 
        /// </param>
        /// <returns type=""></returns>
        function findAll(entity, options) {
            var deferred = $q.defer();
            const filter = createFilter(entity, null, options);
            filter.list(null, function (result) {
                deferred.resolve(result);
            });
            return deferred.promise;
        };

        function findByQuery(entity, queryString, options) {
            var deferred = $q.defer();
            const filter = createFilter(entity, queryString, options);
            try {
                filter.list(null, function (result) {
                    deferred.resolve(result);
                });
            } catch (err) {
                deferred.reject(err);
            }
            return deferred.promise;
        };

        function findUnique(entity) {
            var deferred = $q.defer();
            const promise = deferred.promise;
            this.findAll(entity).then(function (result) {
                if (result.length == 0) {
                    deferred.resolve(null);
                } else {
                    deferred.resolve(result[0]);
                }
            });
            return promise;
        };

        function save(obj, tx) {
            persistence.add(obj);

            var deferred = $q.defer();
            const promise = deferred.promise;
            if (tx) {
                //flush has to be called from the outside
                deferred.resolve();
                return promise;
            } else {
                persistence.flush(function () {
                    deferred.resolve(obj);
                });
            }
            return promise;

        };


        function createTx(args) {
            var deferred = $q.defer();
            persistence.transaction(function (tx) {
                if (args) {
                    deferred.resolve([tx, args]);
                } else {
                    deferred.resolve([tx]);
                }
            });
            return deferred.promise;
        };

        function bulkSave(objArray, tx) {
            if (objArray == null) {
                return $q.when();
            }

            for (let i = 0; i < objArray.length; i++) {
                persistence.add(objArray[i]);
            }
            var deferred = $q.defer();
            const promise = deferred.promise;
            if (tx) {
                //flush has to be called from the outside
                deferred.resolve(objArray);
                return promise;
            }
            persistence.flush(function () {
                deferred.resolve(objArray);
            });
            return promise;

        };

        function bulkDelete(objArray, tx) {
            var deferred = $q.defer();
            const promise = deferred.promise;
            if (!objArray || objArray.length == 0) {
                deferred.resolve();
                return promise;
            }
            for (let i = 0; i < objArray.length; i++) {
                persistence.remove(objArray[i]);
            }
            if (tx) {
                //flush has to be called from the outside
                deferred.resolve(objArray);
                return promise;
            }
            persistence.flush(function () {
                deferred.resolve();
            });
            return promise;

        };

        function executeQuery(query, tx) {
            return this.executeQueries([query], tx, false);
        };

        function executeQueries(queriesToExecute, tx, batchMode) {
            if (batchMode == undefined) {
                batchMode = true;
            }

            const deferred = $q.defer();
            const promise = deferred.promise;

            const queries = queriesToExecute.map(query =>
                angular.isString(query)
                    // using a formatted query String: tuple as [formatted query String, undefined]
                    // TODO: deprecate it
                    ? [query]
                    // using "prepared statement": tuple as [statement, query arguments]
                    : [query.query, query.args]
            );

            //TODO: refactor
            if (!tx) {
                persistence.transaction((closureTx) => {
                    if (batchMode) {
                        persistence.executeQueriesSeqForceBatch(closureTx, queries, (res, err) => err ? deferred.reject(err) : deferred.resolve(res));
                    } else {
                        persistence.executeQueriesSeq(closureTx, queries, (res, err) => err ? deferred.reject(err) : deferred.resolve(res));
                    }
                }
                );
            } else {
                if (batchMode) {
                    persistence.executeQueriesSeqForceBatch(tx, queries, (res, err) => err ? deferred.reject(err) : deferred.resolve(res));
                }
                else {
                    persistence.executeQueriesSeq(tx, queries, (res, err) => err ? deferred.reject(err) : deferred.resolve(res));
                }
            }
            return promise;
        };

        function findSingleByQuery(entity, query, options) {
            const optionsToUse = !!options ? angular.copy(options) : {};
            optionsToUse.pagesize = 1;
            optionsToUse.pageNumber = 1;
            return this.findByQuery(entity, query, optionsToUse).then(results => !results || results.length <= 0 ? null : results[0]);
        };

        /**
         * Counts the number of results the querry would return.
         * (it uses a count statement, it doesn't actually perform the query to measure the array length).
         * 
         * @param String entity 
         * @param String query 
         * @returns Promise resolved with the count value 
         */
        function countByQuery(entity, query, options) {
            const deferred = $q.defer();
            const filter = createFilter(entity, query, options);
            filter.count(count => deferred.resolve(count));
            return deferred.promise;
        };

        /**
         * Deletes all entries for every entity in the database (every entity registered in window.entities), except for the ones passed as parameters.
         * @param Array except list of tables not to wipe
         * 
         * @returns Promise 
         */
        function resetDataBase(except) {
            const queries = [];
            for (let entity in entities) {
                if (!entities.hasOwnProperty(entity) || except.indexOf(entity) >= 0) {
                    continue;
                }
                queries.push("delete from {0}".format(entity));
            }
            return this.executeQueries(queries);
        };

        /**
         * Deletes all entries of the entity in the database.
         * 
         * @param String entity 
         * @returns Promise 
         */
        function deleteTable(entity) {
            if (!entities[entity]) {
                throw new Error("entity {0} not found".format(entity));
            }
            return this.executeQuery("delete from {0}".format(entity));
        };

        /**
         * Drops all entities in the database (every entity registered in window.entities).
         * 
         * @returns Promise 
         */
        function dropDataBase() {
            const queries = [];
            return persistence.runSql("SELECT name FROM sqlite_master where type = 'table'").then((results) => {
                angular.forEach(results, (result) => {
                    if (!result.name.startsWith("_")) {
                        queries.push(`drop table if exists ${result.name}`);
                    }
                });
                return this.executeQueries(queries);
            });
        };

        /**
         * Drops and recreates all entities in the database.
         * 
         * @returns Promise 
         */
        function recreateDataBase() {
            var deferred = $q.defer();
            persistence.reset(null, function (res, err) {
                if (err) {
                    deferred.reject(err);
                } else {
                    deferred.resolve(res);
                }
            });
            return deferred.promise;
        };

        /**
         * Executes a sql statement.
         * 
         * @param String statement 
         * @param [] args 
         * @returns Promise: resolved with result, rejected with database error 
         */
        function executeStatement(statement, args) {
            return persistence.runSql(statement, args);
        };

        function addIndexQuery(tableName, columnName, unique, indexName) {
            var originalColumnName = columnName;
            if (columnName instanceof Array) {
                originalColumnName = columnName.join("_");
                columnName = columnName.join(',');
            }

            const name = indexName || tableName + "__" + originalColumnName;
            const uniqueString = unique === true ? "UNIQUE" : "";
            const sql = `CREATE ${uniqueString} INDEX IF NOT EXISTS ${name} ON  ${tableName} (${columnName})`;
            return sql;
        }

        function dropIndex(tableName, columnName) {
            var originalColumnName = columnName;
            if (columnName instanceof Array) {
                originalColumnName = columnName.join("_");
                columnName = columnName.join(',');
            }

            var sql = 'DROP INDEX IF EXISTS offlineswdb.' + tableName + '_' + originalColumnName;
            this.executeQuery(sql);
        }

        const api = {
            bulkSave,
            bulkDelete,
            countByQuery,
            createTx,
            dropIndex,
            executeStatement,
            executeQuery,
            executeQueries,
            findAll,
            findById,
            findByQuery,
            findUnique,
            findSingleByQuery,
            instantiate,
            save,
            recreateDataBase,
            dropDataBase,
            deleteTable,
            addIndexQuery,
            resetDataBase
        }

        return api;


    }]);

})(angular, persistence);;
(function (angular, persistence) {
    "use strict";
    angular.module("persistence.offline").config(["offlineEntitiesProvider", function (offlineEntitiesProvider) {

        var entities = offlineEntitiesProvider.entities;

        /**
         * Holds information of Eager-loaded OptionFields processed on the server side, by providerAttributes.
         * 
         * This is similar to an autocompleteclient implementation, whereas the server would return the full list upon the sync
         * 
         */
        entities.OptionFieldData = persistence.define("OptionFieldData", {
            application: 'TEXT',
            schema: 'TEXT',
            providerAttribute: 'TEXT', //used for matching which optionfields on the screen are bound to the data
            optionkey: 'TEXT', // the remoteid of the option (assetnum, classificationid, etc..)
            optionvalue: 'TEXT',
            extraprojectionvalues: 'JSON' //usually null, but can contain a json with extra fields
        });



        //#region AssociationData
        ///
        /// Holds top level application data.
        /// This Entries needs to be reevaluated on every sync, since chances are that they do not needed to be present on client side after execution.
        ///
        //this entity stores the Data which will be used as support of the main entities.
        //It cannot be created locally. Hence Synchronization should use rowstamp caching capabilities by default
        entities.AssociationData = persistence.define('AssociationData', {
            application: 'TEXT',
            datamap: 'JSON',
            rowstamp: 'INT',
            remoteid: 'NUMERIC',
            // index for use on searches
            textindex01: "TEXT",
            textindex02: "TEXT",
            textindex03: "TEXT",
            textindex04: "TEXT",
            textindex05: "TEXT",
            numericindex01: "NUMERIC",
            numericindex02: "NUMERIC",
            dateindex01: "DATE",
            dateindex02: "DATE",
            dateindex03: "DATE"
        });

        entities.AssociationCache = persistence.define('AssociationCache', {
            ///Holds an object that for each application will have properties that will help the framework to understaand how to proceed upon synchronization:
            /// <ul>
            ///     <li>maximorowstamp --> the rowstamp of the last data fetched from maximo of this application</li>
            ///     <li>whereclausehash--> the md5 hash of the latest applied whereclause used to pick this data, or null, if none present
            ///             The framework will compare to see if the wc has changed, invalidating the entire cache in that case.</li>
            ///     <li>syncschemahash --> the hash of the sync schema used for last synchronization. It could have changed due to a presence of a new projection field, for instance</li>
            /// </ul>
            ///ex:
            /// {
            ///    location:{
            ///       maximorowstamp: 1000
            ///       whereclausehash:'abasacvsava'
            ///       syncschemahash:'asadfasdfasdfasdfasdfadsfasdfasdfamlmlmlsdafsadfassfdafa'
            ///    }
            /// 
            ///

            ///    asset:{
            ///       maximorowstamp: 12500
            ///       whereclausehash:'hashoflatestappliedwhereclause'
            ///       syncschemahash:baadfasdfasdfa
            ///    }
            //        .
            //        .
            //        .
            // }
            data: "JSON"
        });

        ///
        /// Inserts or updates associationData based upon the uniqueness of the entries
        ///
        entities.AssociationData.InsertionPattern = "INSERT {0} INTO AssociationData (application,datamap,rowstamp,id,textindex01,textindex02,textindex03,textindex04,textindex05,numericindex01,numericindex02,dateindex01,dateindex02,dateindex03,remoteid) values (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";

        entities.AssociationData.maxRowstampQueries = "select max(rowstamp) as rowstamp,application,id from AssociationData group by application";

        entities.AssociationData.maxRemoteIdQueries = "select max(CAST(remoteid as int)) as remoteid,application,id from AssociationData group by application";

        entities.AssociationData.maxRowstampQueryByApps = "select max(rowstamp) as rowstamp,application,id from AssociationData where application in ({0}) group by application";

        entities.AssociationData.maxRemoteIdQueryByApps = "select max(CAST(remoteid as int)) as remoteid,application,id from AssociationData where application in ({0}) group by application";

        //#endregion

        //#region Batch
        entities.Batch = persistence.define('Batch', {
            ///
            /// A batch gets created when the user has made any local changes to items (operations), and hits the synchronize button.
            /// 
            /// The batch will be sent to the server where it will be handled asynchronously, using a Queue implementation for load distribution.
            /// 
            /// Each operation made locally will incur in a BatchItem entry being generated and linked to the Batch Entry.
            /// 
            /// After submitted, the batch status will be checked periodically (on a configurable setting basis). 
            /// MeanWhile, all the affected DataEntries will be locked locally, so that the user is not able to perform any operation (but viewing) on them before the batch response.
            ///
            application: 'TEXT',
            sentDate: 'DATE',
            completionDate: 'DATE',
            lastChecked: 'DATE',
            //this is the id of the Batch on the server, it will be used for checking the status of it periodically
            remoteId: 'TEXT',
            //either pending, or completed
            status: 'TEXT'
        });

        entities.BatchItem = persistence.define('BatchItem', {
            //how this batch item presents on the screen
            label: 'TEXT',
            //either pending, or completed
            status: 'TEXT',
            // marks the CRUD operation being executed: update, create, etc
            crudoperation: "TEXT"
        });

        entities.Batch.hasMany('items', entities.BatchItem, 'batch');
        //#endregion

        //#region CompositionDataEntry
        ///
        /// Holds Composition Data for the items already stored on server side. 
        /// Items created/updated locally will be pushed straight into the parents datamap; this happens so that we can easily write the datamap to maximo, the exact same way as the online version.
        ///
        ///  Attachments compositions (doclinks) are an exception to this rule, as we need to generate them locally in order to be able to do a match to the attachment table
        ///
        ///  Whenever the list of compositions is to be shown, we need to do a union among the list of compositionDataEntries (persisted entries) and the list coming from the parent datamap (local entries).
        ///
        ///
        entities.CompositionDataEntry = persistence.define('CompositionDataEntry', {
            application: 'TEXT',
            datamap: 'JSON',
            remoteId: 'TEXT',//The id of this entry in maximo, it will be null when itÂ´s created locally
            isDirty: 'BOOL', //if this flag is true, it will indicate that some change has been made to this entry locally, and it will appear on the pending sync dashboard
            rowstamp: 'INT',
            // index for use on searches
            textindex01: "TEXT",
            textindex02: "TEXT",
            textindex03: "TEXT",
            textindex04: "TEXT",
            textindex05: "TEXT",
            numericindex01: "NUMERIC",
            numericindex02: "NUMERIC",
            dateindex01: "DATE",
            dateindex02: "DATE",
            dateindex03: "DATE"
        });

        entities.CompositionDataEntry.insertionQueryPattern = "insert or replace into CompositionDataEntry (application,datamap,isDirty,remoteId,rowstamp,id,'textindex01','textindex02','textindex03','textindex04','textindex05','numericindex01','numericindex02','dateindex01','dateindex02','dateindex03') values (:p0,:p1,0,:p2,:p3,:p4,:p5,:p6,:p7,:p8,:p9,:p10,:p11,:p12,:p13,:p14)";
        entities.CompositionDataEntry.updateQueryPattern = "update CompositionDataEntry set datamap='{0}' rowstamp={1} where remoteId='{2}' and applicaton='{3}'";
        entities.CompositionDataEntry.syncdeletionQuery = "delete from CompositionDataEntry where application = '{0}' and remoteId in ({1})";


        entities.CompositionDataEntry.maxRowstampQueries = "select max(rowstamp) as rowstamp,application,id from CompositionDataEntry  group by application";
        entities.CompositionDataEntry.selectCompositions = "select max(rowstamp) as rowstamp,application,id from CompositionDataEntry  group by application";
        //#endregion

        //#region Attachment

        /**
         * The attachment entity holds the raw base64 of the attachment itself. 
         * It's equivalent to the docinfo table on the server side. 
         * 
         * The id will be used a unique cross-device/user identifier so that it can be used to download an already existing attachment that got created on that device on firstplace.
         * 
         * 
         * Current implementation is storing every attachemnent's base64 but it would be possible just to point to a path of the file on the device FS instead.
         * 
         * 
         */
        entities.Attachment = persistence.define('Attachment', {
            application: "TEXT", // ROOT application of the entity that has the asset (e.g. workorder, sr, etc)
            parentId: "TEXT", // local id of the ROOT entity
            compositionRemoteId: "TEXT", // the remoteId of the composition to link
            docinfoRemoteId: "TEXT", // the remoteId of the composition to link
            path: "TEXT", // local file system path to the saved file (should be in an external storage directory), used to cache access to ios devices
            compressed: "BOOL", // whether or not the file is compressed
            content: "TEXT", // base64 encoded content,
            mimetype: "TEXT" //mimetype of the file
        });

        entities.Attachment.NonPendingAttachments = "select id,compositionRemoteId,docinfoRemoteId from Attachment where (path is not null or content is not null) and (id in ({0}) or docinfoRemoteId in ({1}) )";


        entities.Attachment.UpdateRemoteIdOfExistingAttachments = "update Attachment set 'compositionRemoteId' = ?, 'docinfoRemoteId'=? where id = ?";
        entities.Attachment.CreateNewBlankAttachments = "insert into Attachment ('application','parentId','compositionRemoteId','docinfoRemoteId','id') values (?,?,?,?,?)";
        //brings the attachments that need to be syncrhonized to the server. The ones which have a compositionRemoteId already point to a downloaded composition, and thus do not require to be uploaded
        entities.Attachment.ByApplicationAndIds = "select id,parentId,content from Attachment where application = ? and parentId in ({0}) and compositionRemoteId is null";

        /**
         * query to fetch list of attachments which are pending synchronization against the server side
         */
        entities.Attachment.PendingAttachments = "select id,docinfoRemoteId from Attachment where (path is null and content is null) and compositionRemoteId is not null";

        entities.Attachment.UpdatePendingAttachment = "update Attachment set content =? , mimetype=? where id =?";

        entities.Attachment.UpdateAttachmentPath = "update Attachment set path =? where docinfoRemoteId =?";

        entities.Attachment.ByDocInfoId = "select content,mimetype,path from Attachment where docinfoRemoteId = ?";
        entities.Attachment.ByHashId = "select content,mimetype,path from Attachment where id = ?";
        entities.Attachment.DeleteById = "delete from Attachment where id = ?";
        entities.Attachment.DeleteMultipleByIdsPattern = "delete from Attachment where id in ({0})";

        //#endregion

        //('application','datamap','pending','isDirty','remoteId','rowstamp','id') values (:p0,:p1,0,0,:p2,:p3,:p4)

        //#region DataEntry
        ///
        /// Holds top level application data.
        /// This Entries needs to be reevaluated on every sync, since chances are that they do not needed to be present on client side after execution.
        ///
        entities.DataEntry = persistence.define('DataEntry', {
            application: 'TEXT',
            //this is a datamap that was retrieved from the latest maximo synchronization, will be used to gather the diff upon synchronization
            originaldatamap: 'JSON',
            //this is the current datamap of the entity, after n different operations had succeed on it. ItÂ´s the current entity state, that will be shown on screen.
            datamap: 'JSON',
            //whether this item is pending for a synchronization response, becoming read-only at this point
            pending: 'BOOL',
            //The id of this entry in maximo, it will be null when it has been created locally
            remoteId: 'TEXT',
            //if this flag is true, it will indicate that some change has been made to this entry locally, and it will appear on the pending sync dashboard
            isDirty: 'BOOL',
            //if this flag is true, it will indicate that the dataentry had a problem on the last sync
            hasProblem: 'BOOL',
            rowstamp: 'INT',
            // index for use on searches
            textindex01: "TEXT",
            textindex02: "TEXT",
            textindex03: "TEXT",
            textindex04: "TEXT",
            textindex05: "TEXT",
            numericindex01: "NUMERIC",
            numericindex02: "NUMERIC",
            dateindex01: "DATE",
            dateindex02: "DATE",
            dateindex03: "DATE"
        });


        entities.Operation = persistence.define('Operation', {
            //the json object representing everything needed to perform the operation on the server side
            datamap: 'JSON',
            operation: 'TEXT',
            //used to execute operations on the right order
            creationDate: 'DATE'
        });

        entities.DataEntry.hasMany('operations', entities.Operation, 'entry');

//        entities.DataEntry.index(['application', 'remoteid'], { unique: true });

        entities.DataEntry.maxRowstampByAppQuery = "select max(rowstamp) as rowstamp,application,id from DataEntry where application = '{0}'";

        entities.DataEntry.maxRowstampGeneralQuery = "select max(rowstamp) as rowstamp,application,id from DataEntry group by application";

        //query to be performed after synchronization has occurred, for new items
        entities.DataEntry.insertionQueryPattern = "insert into DataEntry ('application','datamap','pending','isDirty','remoteId','rowstamp','id','textindex01','textindex02','textindex03','textindex04','textindex05','numericindex01','numericindex02','dateindex01','dateindex02','dateindex03') values (:p0,:p1,0,0,:p2,:p3,:p4,:p5,:p6,:p7,:p8,:p9,:p10,:p11,:p12,:p13,:p14)";
        //query to be performed after synchronization has occurred, for existing items
        entities.DataEntry.updateQueryPattern = "update DataEntry set 'datamap'=:p0,'pending'=0,'rowstamp'=:p1,'textindex01'=:p2,'textindex02'=:p3,'textindex03'=:p4,'textindex04'=:p5,'textindex05'=:p6,'numericindex01'=:p7,'numericindex02'=:p8,'dateindex01'=:p9,'dateindex02'=:p10,'dateindex03'=:p11 where remoteId=:p12 and application=:p13";

        entities.DataEntry.insertOrReplacePattern = "INSERT OR REPLACE INTO DataEntry (application,datamap,pending,isDirty,remoteId,rowstamp,id,textindex01,textindex02,textindex03,textindex04,textindex05,numericindex01,numericindex02,dateindex01,dateindex02,dateindex03) values (?,?,0,0,?,?,?,?,?,?,?,?,?,?,?,?,?)";

        entities.DataEntry.deleteQueryPattern = "delete from DataEntry where remoteId in ({0}) and application='{1}'";
        entities.DataEntry.deleteInIdsStatement = "delete from DataEntry where id in ({0}) and application=?";
        entities.DataEntry.deleteLocalStatement = "delete from DataEntry where id=? and application=?";

        entities.DataEntry.updateLocalPattern = "update DataEntry set 'datamap'=?,'isDirty'=1,'textindex01'=?,'textindex02'=?,'textindex03'=?,'textindex04'=?,'textindex05'=?,'numericindex01'=?,'numericindex02'=?,'dateindex01'=?,'dateindex02'=?,'dateindex03'=? where id =?";
        entities.DataEntry.updateLocalSetOriginalPattern = "update DataEntry set 'datamap'=?,'originaldatamap'=?,'isDirty'=1,'textindex01'=?,'textindex02'=?,'textindex03'=?,'textindex04'=?,'textindex05'=?,'numericindex01'=?,'numericindex02'=?,'dateindex01'=?,'dateindex02'=?,'dateindex03'=? where id =?";
        entities.DataEntry.insertLocalPattern = "insert into DataEntry ('application','datamap','isDirty','pending','remoteId','rowstamp','id','textindex01','textindex02','textindex03','textindex04','textindex05','numericindex01','numericindex02','dateindex01','dateindex02','dateindex03') values (?,?,1,0,null,null,?,?,?,?,?,?,?,?,?,?,?)";

        entities.DataEntry.restoreToOriginalStateStatement = "update DataEntry set isDirty=0,hasProblem=0,datamap=originaldatamap where id=? and application=?";

        //entities.DataEntry.clearProblem = "update DataEntry set hasProblem=0 where id in (?)";
        //entities.DataEntry.setProblem = "update DataEntry set hasProblem=1 where id in (?)";
        entities.DataEntry.findProblems = "select p.* from Problem p left join batchitem bi on p.id = bi.problem left join batch b on b.id = bi.batch where bi.dataentry = ? order by b.sentDate desc";

        //here because of the order of the files
        entities.BatchItem.hasOne('dataentry', entities.DataEntry);
        entities.BatchItem.hasOne('operation', entities.Operation);
        //#endregion

        //#region Problem
        entities.Problem = persistence.define("Problem", {
            message: "TEXT"
        });

        entities.BatchItem.hasOne("problem", entities.Problem);
        //#endregion

        //#region SyncOperation
        entities.SyncOperation = persistence.define('SyncOperation', {
            startdate: "DATE",
            enddate: "DATE",
            lastcheckdate: "DATE",
            lastsyncServerVersion: "TEXT",
            //pending,complete
            status: 'TEXT',
            numberofdownloadeditems: "INT",
            numberofdownloadedsupportdata: "INT",
            clientOperationId: "TEXT",
            hasProblems: "BOOL",
            metadatachange: "BOOL",
            items: "INT" // batches.items.length
        });

        //many batches, one per application sent, as they can be processed in parallel cpus
        entities.SyncOperation.hasMany("batches", entities.Batch, "syncoperation");
        //#endregion

        //#region Commons
        entities.Settings = persistence.define('Settings', {
            localversion: "TEXT",
            serverurl: 'TEXT'
        });

        entities.User = persistence.define('User', {
            name: 'TEXT',
            orgid: 'TEXT',
            siteid: 'TEXT'
        });

        entities.Configuration = persistence.define('Configuration', {
            key: 'TEXT',
            value: 'JSON'
        });


        entities.Application = persistence.define('Application', {
            application: 'TEXT',
            association: 'BOOL',
            composition: 'BOOL',
            data: "JSON"
        });



        entities.WhereClause = persistence.define("WhereClause", {
            ///
            /// This should get populated only if, there are multiple whereclauses present for a given association.
            /// Ex: Asset has one WC for the SR, and another one for the WO. If a intersection (fallback condition exists) it should be registered on the asset application alone, though, or via the metadata.
            /// The framework will bring all Assets that match the base whereclause (only once) and match the specific whereclauses entries locally, so that the amount of data transported is minimized.
            ///
            application: "TEXT",
            parentApplication: "TEXT",
            metadataid: "TEXT",
            //the whereclause it self
            data: "TEXT"
        });

        
        entities.Menu = persistence.define('Menu', {
            data: "JSON"
        });

        entities.CommandBar = persistence.define("CommandBar", {
            key: "TEXT",
            data: "JSON"
        });

        entities.Cookie = persistence.define("Cookie", {
            name: "TEXT",
            value: "TEXT"
        });
        entities.Cookie.index(["name"], { unique: true });

        entities.Cookie.insertStatement = "insert into Cookie (id, name, value) values (?,?,?)";
        entities.Cookie.updateByNameStatement = "update Cookie set value=? where name=?";
        entities.Cookie.deleteByNameStatement = "delete from Cookie where name=?";
        entities.Cookie.deleteAllStatement = "delete from Cookie";
        //#endregion

        entities.ActiveLaborTracker = persistence.define("ActiveLaborTracker", {
            parentid: "TEXT",
            laborlocalid: "TEXT"
        });

    }]);

})(angular, persistence);;
(function (angular) {
    "use strict";
    angular.module("persistence.offline").config(["offlineMigrationsProvider", function (offlineMigrationsProvider) {
        // never change/remove/comment migrations or change group id/tag or change migration tag if you need to alter an old migration
        // consider creating a new one that undo the changes (unless you are absolutelly sure about it).

        const migrationGroup = offlineMigrationsProvider.createMigrationGroup(5, "offline migrations");

        migrationGroup.addMigration("table OptionFieldData", {
            up: function () {
                this.createTable("OptionFieldData", (t) => {
                    t.text("application");
                    t.text("schema");
                    t.text("providerAttribute");
                    t.text("optionkey");
                    t.text("optionvalue");
                    t.json("extraprojectionvalues");
                });
            },
            down: function () {
                this.dropTable("OptionFieldData");
            }
        });

        migrationGroup.addMigration("table AssociationData", {
            up: function () {
                this.createTable("AssociationData", (t) => {
                    t.text("application");
                    t.json("datamap");
                    t.integer("rowstamp");
                    t.text("textindex01");
                    t.text("textindex02");
                    t.text("textindex03");
                    t.text("textindex04");
                    t.text("textindex05");
                    t.numeric("numericindex01");
                    t.numeric("numericindex02");
                    t.date("dateindex01");
                    t.date("dateindex02");
                    t.date("dateindex03");
                });

            },
            down: function () {
                this.dropTable("AssociationData");
            }
        });

        migrationGroup.addMigration("table AssociationCache", {
            up: function () {
                this.createTable("AssociationCache", (t) => {
                    t.json("data");
                });
            },
            down: function () {
                this.dropTable("AssociationCache");
            }
        });

        migrationGroup.addMigration("table Batch", {
            up: function () {
                this.createTable("Batch", (t) => {
                    t.text("application");
                    t.date("sentdate");
                    t.date("completionDate");
                    t.date("lastChecked");
                    t.text("remoteId");
                    t.text("status");
                    t.varchar("syncoperation", 32);
                });
                this.addIndex("Batch", "syncoperation");
            },
            down: function () {
                this.removeIndex("Batch", "syncoperation");
                this.dropTable("Batch");
            }

        });

        migrationGroup.addMigration("table BatchItem", {
            up: function () {
                this.createTable("BatchItem", (t) => {
                    t.text("label");
                    t.text("status");
                    t.text("crudoperation");
                    t.varchar("problem", 32);
                    t.varchar("operation", 32);
                    t.varchar("dataentry", 32);
                    t.varchar("batch", 32);
                });
                this.addIndex("BatchItem", "problem");
                this.addIndex("BatchItem", "operation");
                this.addIndex("BatchItem", "dataentry");
                this.addIndex("BatchItem", "batch");
            },
            down: function () {
                this.removeIndex("BatchItem", "batch");
                this.removeIndex("BatchItem", "dataentry");
                this.removeIndex("BatchItem", "operation");
                this.removeIndex("BatchItem", "problem");
                this.dropTable("BatchItem");
            }
        });

        migrationGroup.addMigration("table CompositionDataEntry", {
            up: function () {
                this.createTable("CompositionDataEntry", (t) => {
                    t.text("application");
                    t.json("datamap");
                    t.text("remoteId");
                    t.boolean("isDirty");
                    t.integer("rowstamp");
                });
            },
            down: function () {
                this.dropTable("CompositionDataEntry");
            }
        });

        migrationGroup.addMigration("table Attachment", {
            up: function () {
                this.createTable("Attachment", (t) => {
                    t.text("application");
                    t.text("parentId");
                    t.text("compositionRemoteId");
                    t.text("docinfoRemoteId");
                    t.text("path");
                    t.boolean("compressed");
                    t.text("content");
                    t.text("mimetype");
                });
            },
            down: function () {
                this.dropTable("Attachment");
            }
        });

        migrationGroup.addMigration("table DataEntry", {
            up: function () {
                this.createTable("DataEntry", (t) => {
                    t.text("application");
                    t.json("originaldatamap");
                    t.json("datamap");
                    t.boolean("pending");
                    t.text("remoteId");
                    t.boolean("isDirty");
                    t.boolean("hasProblem");
                    t.integer("rowstamp");
                    t.text("textindex01");
                    t.text("textindex02");
                    t.text("textindex03");
                    t.text("textindex04");
                    t.text("textindex05");
                    t.numeric("numericindex01");
                    t.numeric("numericindex02");
                    t.date("dateindex01");
                    t.date("dateindex02");
                    t.date("dateindex03");
                });
                this.addIndex("DataEntry", ["application", "remoteid"], true);
            },
            down: function () {
                this.dropTable("DataEntry");
            }
        });

        migrationGroup.addMigration("table Operation", {
            up: function () {
                this.createTable("Operation", (t) => {
                    t.json("datamap");
                    t.text("operation");
                    t.date("creationDate");
                    t.varchar("entry", 32);
                });
                this.addIndex("Operation", "entry");
            },
            down: function () {
                this.removeIndex("Operation", "entry");
                this.dropTable("Operation");
            }
        });

        migrationGroup.addMigration("table Problem", {
            up: function () {
                this.createTable("Problem", (t) => {
                    t.text("message");
                });
            },
            down: function () {
                this.dropTable("Problem");
            }
        });

        migrationGroup.addMigration("table SyncOperation", {
            up: function () {
                this.createTable("SyncOperation", (t) => {
                    t.date("startdate");
                    t.date("enddate");
                    t.date("lastcheckdate");
                    t.text("lastsyncServerVersion");
                    t.text("status");
                    t.integer("numberofdownloadeditems");
                    t.integer("numberofdownloadedsupportdata");
                    t.boolean("hasProblems");
                    t.boolean("metadatachange");
                    t.integer("items");
                });
            },
            down: function () {
                this.dropTable("SyncOperation");
            }
        });

        migrationGroup.addMigration("table Settings", {
            up: function () {
                this.createTable("Settings", (t) => {
                    t.text("localversion");
                    t.text("serverurl");
                });
            },
            down: function () {
                this.dropTable("Settings");
            }
        });

        migrationGroup.addMigration("table User", {
            up: function () {
                this.createTable("User", (t) => {
                    t.text("name");
                    t.text("orgid");
                    t.text("siteid");
                });
            },
            down: function () {
                this.dropTable("User");
            }
        });

        migrationGroup.addMigration("table Configuration", {
            up: function () {
                this.createTable("Configuration", (t) => {
                    t.text("key");
                    t.json("value");
                });
            },
            down: function () {
                this.dropTable("Configuration");
            }
        });

        migrationGroup.addMigration("table Application", {
            up: function () {
                this.createTable("Application", (t) => {
                    t.text("application");
                    t.boolean("association");
                    t.boolean("composition");
                    t.json("data");
                });
            },
            down: function () {
                this.dropTable("Application");
            }
        });

        migrationGroup.addMigration("table WhereClause", {
            up: function () {
                this.createTable("WhereClause", (t) => {
                    t.text("application");
                    t.text("parentApplication");
                    t.text("metadataid");
                    t.text("data");
                });
            },
            down: function () {
                this.dropTable("WhereClause");
            }
        });

        migrationGroup.addMigration("table Menu", {
            up: function () {
                this.createTable("Menu", (t) => {
                    t.json("data");
                });
            },
            down: function () {
                this.dropTable("Menu");
            }
        });

        migrationGroup.addMigration("table CommandBar", {
            up: function () {
                this.createTable("CommandBar", (t) => {
                    t.text("key");
                    t.json("data");
                });
            },
            down: function () {
                this.dropTable("CommandBar");
            }
        });

        migrationGroup.addMigration("table Cookie", {
            up: function () {
                this.createTable("Cookie", (t) => {
                    t.text("name");
                    t.text("value");
                });
                this.addIndex("Cookie", "name", true);
            },
            down: function () {
                this.removeIndex("Cookie", "name");
                this.dropTable("Cookie");
            }
        });

        migrationGroup.addMigration("table ActiveLaborTracker", {
            up: function () {
                this.createTable("ActiveLaborTracker", (t) => {
                    t.text("parentid");
                    t.text("laborlocalid");
                });
            },
            down: function () {
                this.dropTable("ActiveLaborTracker");
            }
        });

        migrationGroup.addMigration("search indexes  for CompositionData", {
            up: function () {
                this.addColumn("CompositionDataEntry", "textindex01", "text");
                this.addColumn("CompositionDataEntry", "textindex02", "text");
                this.addColumn("CompositionDataEntry", "textindex03", "text");
                this.addColumn("CompositionDataEntry", "textindex04", "text");
                this.addColumn("CompositionDataEntry", "textindex05", "text");
                this.addColumn("CompositionDataEntry", "numericindex01", "numeric");
                this.addColumn("CompositionDataEntry", "numericindex02", "numeric");
                this.addColumn("CompositionDataEntry", "dateindex01", "date");
                this.addColumn("CompositionDataEntry", "dateindex02", "date");
                this.addColumn("CompositionDataEntry", "dateindex03", "date");
            },
            down: function () {
                this.removeColumn("CompositionDataEntry", "textindex01");
                this.removeColumn("CompositionDataEntry", "textindex02");
                this.removeColumn("CompositionDataEntry", "textindex03");
                this.removeColumn("CompositionDataEntry", "textindex04");
                this.removeColumn("CompositionDataEntry", "textindex05");
                this.removeColumn("CompositionDataEntry", "numericindex01");
                this.removeColumn("CompositionDataEntry", "numericindex02");
                this.removeColumn("CompositionDataEntry", "dateindex01");
                this.removeColumn("CompositionDataEntry", "dateindex02");
                this.removeColumn("CompositionDataEntry", "dateindex03");
            }
        });


        migrationGroup.addMigration("add remoteid for associationdata", {
            up: function () {
                this.addColumn("AssociationData", "remoteid", "text");
                this.addIndex("AssociationData", ["application", "remoteid"], true);
            },
            down: function () {
                this.removeColumn("AssociationData", "remoteid");
            }
        });


        migrationGroup.addMigration("add clientopreationid for syncoperation", {
            up: function () {
                this.addColumn("SyncOperation", "clientoperationid", "text");
            }
        });

        migrationGroup.addMigration("add indexes for composition", {
            up: function () {
                this.addIndex("CompositionDataEntry", ["application", "remoteid"], true,null,false);
            }
        });

    }]);

})(angular, persistence);;
(function (angular, persistence, _) {
    "use strict";

    try {
        angular.module("persistence.offline");
    } catch (err) {
        return;
    }

    //#region audit.offline module
    const audit = angular.module("audit.offline", ["persistence.offline"]);
    //#endregion

    //#region audit.offline migrations
    angular.module("persistence.offline").config(["offlineMigrationsProvider", function (offlineMigrationsProvider) {
        const migrationGroup = offlineMigrationsProvider.createMigrationGroup(10, "offline audit migrations");

        migrationGroup.addMigration("table AuditEntry", {
            up: function () {
                this.createTable("AuditEntry", (t) => {
                    t.text("operation");
                    t.json("originaldatamap");
                    t.json("datamap");
                    t.text("refApplication");
                    t.text("refClientId");
                    t.text("refId");
                    t.text("refUserId");
                    t.text("createdBy");
                    t.date("createdDate");
                });
            },
            down: function () {
                this.dropTable("AuditEntry");
            }
        });
    }]);
    //#endregion

    //#region audit.offline entities
    angular.module("persistence.offline").config(["offlineEntitiesProvider", function (offlineEntitiesProvider) {
        const entities = offlineEntitiesProvider.entities;

        entities.AuditEntry = persistence.define("AuditEntry", {
            //the name of the operation, such as crud_create, crud_update, or a custom one
            operation: "TEXT",
            //this is a datamap before an action has happened on the entry
            originaldatamap: "JSON",
            //this is the datamap after the action has been performed, both will be used to generate a diff
            datamap: "JSON",
            // application/entity being tracked
            refApplication: "TEXT",
            // local/persistence's id of the entity being tracked
            refClientId: "TEXT",
            // server's/maximo's id of the entity being tracked
            refId: "TEXT",
            // server's/maximo's userId of the entity being tracked (such as an asset's assetnum)
            refUserId: "TEXT",

            createdBy: "TEXT",
            createdDate: "DATE"
        });

        entities.AuditEntry.listPattern = "refApplication='{0}' and createdBy='{1}'";
        entities.AuditEntry.listApplicationsStatement = "select distinct refApplication from AuditEntry where createdBy=?";
        entities.AuditEntry.forEntityPattern = "refClientId='{0}' and refApplication='{1}'";
        entities.AuditEntry.deleteRelatedStatement = "delete from AuditEntry where refClientId=? and refApplication=?";
        //TODO: treat the case where AuditEntries that have no refId shouldn't be deleted (e.g. crud_create operations)
        entities.AuditEntry.deleteRelatedByRefIdStatement = "delete from AuditEntry where refApplication=? and (refId in ({0}) or refId is null)";
    }]);
    //#endregion

    //#region offlineAuditService
    (function (audit) {

        function offlineAuditService($q, entities, dao, securityService, routeService) {
            //#region Utils
            function validateEntryField(dict, field) {
                if (!dict[field]) {
                    throw new Error(`IllegalArgumentError: AuditEntry cannot have an empty '${field}'`);
                }
            }

            function instantiateEntry(dict) {
                if (!dict["createdBy"]) {
                    dict["createdBy"] = securityService.currentUser();
                }
                validateEntryField(dict, "operation");
                validateEntryField(dict, "refApplication");
                validateEntryField(dict, "refClientId");
                validateEntryField(dict, "createdBy");

                dict["createdDate"] = new Date();
                return dao.instantiate("AuditEntry", dict);
            }

            //#endregion

            //#region Public methods

            /**
             * Registers an AuditEntry.
             * The entry should follow the format:
             * {
             *  operation: String, // name of the operation, such as crud_create, crud_update, or a custom one
             *  originaldatamap: Object, // a datamap before an action has happened on the entry
             *  datamap: Object, // datamap after the action has been performed, both will be used to generate a diff
             *  refApplication: String, // name of the application/entity being affected
             *  refClientId: String, // local id of the entity being affected
             *  refId: String, // server's id of the entity being affected
             *  createdBy: String, // username of the user who triggered the operation -> defaults to current logged user if omitted
             * }
             * The fields "operation", "refApplication" and "refClientId" are mandatory.
             * The other fields can be ommited depending on the action being executed, this method is intended for registering
             * complete entries though. See other methods (such as {@link #registerEvent}) for registering customized entries.
             * 
             * @param {Object} entry dictionary in the aforementioned format
             * @returns {Promise<entities.AuditEntry>} resolved with the registered AuditEntry
             * @throws {Error} if any of the mandatory fields is ommited and/or there's no user logged in
             */
            function registerEntry(entry) {
                return instantiateEntry(entry).then(auditentry => dao.save(auditentry));
            }

            /**
             * Register an "Audit Event" type entry. 
             * This entry has no data change (create, update, delete) associated with it
             * i.e. it has no tracking of other entities's datamaps.
             * Usage example (user scanned an asset):
             * offlineAuditService.registerEvent("scan", "asset", asset.id, asset.remoteId, auth.currentUser());
             * 
             * @param {String} operation name of the operation/event being tracked
             * @param {String} refApplication name of the application/entity being affected by the event
             * @param {String} refClientId local id of the enity being affected by the event
             * @param {String} refId server's id of the entity being affected by the event
             * @param {String} refUserId server's userId of the entity being affected by the event
             * @param {String} createdBy username of the user who triggered the event -> defaults to current logged user if omitted  
             * @return {Promise<entities.AuditEntry>} resolved with the registered AuditEntry
             * @throws {Error} if any of the parameters is omitted and/or there's no user logged in
             */
            function registerEvent(operation, refApplication, refClientId, refId, refUserId, createdBy) {
                const entry = {
                    operation,
                    refApplication,
                    refClientId,
                    refId,
                    refUserId,
                    createdBy
                };
                return registerEntry(entry);
            }

            /**
             * Lists all apllications that have AuditEntries related to them (refApplication).
             * 
             * @returns {Promise<Array<String>>} resolved with array of name of the applications.
             */
            function listAudittedApplications() {
                const createdBy = securityService.currentUser();
                return dao.executeStatement(entities.AuditEntry.listApplicationsStatement, [createdBy])
                    .then(results => _.pluck(results, "refApplication"));
            }

            /**
             * Fetches AuditEntries from the Database matching the values passed as arguments.
             * The list can be optionally paginated.
             * 
             * @param {String} refApplication 
             * @param {Object?} paginationOptions dicitionary: 
             *              { 
             *              "pagenumber": Integer, // page to fetch 
             *              "pagesize": Integer // number of items per page
             *              }
             *           won't paginate if parameter is omitted
             * @returns {Promise<Array<entities.AuditEntry>>} resolved with AuditEntry list 
             */
            function listEntries(refApplication, paginationOptions) {
                const createdBy = securityService.currentUser();
                const query = entities.AuditEntry.listPattern.format(refApplication, createdBy);
                const options = { orderby: "createdDate", orderbyascendig: false };
                if (!!paginationOptions) {
                    options.pagesize = paginationOptions["pagesize"];
                    options.pageNumber = paginationOptions["pagenumber"];
                }
                return dao.findByQuery("AuditEntry", query, options);
            }

            /**
             * Fetches the AuditEntry that has matching id.
             * 
             * @param {String} id primary key in the database 
             * @returns {Promise<entities.AuditEntry>} resolved with the AuditEntry
             */
            function getAuditEntry(id) {
                return dao.findById("AuditEntry", id);
            }

            /**
             * Fetches the DataEntry the entry is tracking.
             * 
             * @param {AuditEntry} entry 
             * @returns {Promise<entities.DataEntry>} resolved with the entity 
             */
            function getTrackedEntity(entry) {
                return dao.findById("DataEntry", entry.refClientId);
            }

            /**
             * @param {String} DataEntry's id
             * @param {String} application DataEntry's application
             * @returns {Promise<Array<entites.DataEntry>>} resolved with list of AuditEntries related to the entity
             */
            function getEntriesForEntity(entityId, application) {
                return dao.findByQuery("AuditEntry", entities.AuditEntry.forEntityPattern.format(entityId, application));
            }

            /**
             * Deletes all AuditEntries tracking the entity.
             * 
             * @param {String} entityId DataEntry's id
             * @param {String} application
             * @returns {Promise<Void>} 
             */
            function deleteRelatedEntries(entityId, application) {
                return dao.executeStatement(entities.AuditEntry.deleteRelatedStatement, [entityId, application]);
            }

            /**
             * Navigates to audit's entry-point state (application select screen).
             * 
             * @returns {Promise<Void>} 
             */
            function goToAudit() {
                return routeService.go("main.audit.applicationselect");
            }

            //#endregion

            //#region Service Instance
            const service = {
                registerEvent,
                registerEntry,
                listEntries,
                listAudittedApplications,
                getAuditEntry,
                getTrackedEntity,
                getEntriesForEntity,
                deleteRelatedEntries,
                goToAudit
            };
            return service;
            //#endregion
        };

        //#region Service registration
        audit.factory("offlineAuditService", ["$q", "offlineEntities", "swdbDAO", "securityService", "routeService", offlineAuditService]);
        //#endregion
    })(audit);
    //#endregion

})(angular, persistence, _);;
(function (angular) {
    "use strict";

    var modules = {
        webcommons: angular.module('webcommons_services', ["sw_rootcommons"]),
        maximoapplications: angular.module('maximo_applications', []),
        rootCommons: angular.module('sw_rootcommons', [])
    };
    window.modules = modules;

})(angular);
;
(function(modules) {
    "use strict";

    modules.webcommons.service('statuscolorService', ["$rootScope", "$injector", "contextService", "schemaService","dispatcherService", function ($rootScope, $injector, contextService, schemaService, dispatcherService) {

    var fallbackFunction = function (status, applicationname) {

        //if (status.equalsAny("NEW", "WAPPR", "WSCH", "ACTIVE")) {
        //    return "#e59323"; //orange
        //}

        //if (status.equalsAny("QUEUED", "CANTREPROD", "WAITONINFO", "PENDING", "WMATL", "WORKING", "null")) {
        //    return "#f2d935"; //yellow
        //}

        //if (status.equalsAny("CANCELLED", "FAIL", "CAN", "FAILPIR", "REJECTED", "NOTREQ", "WONT FIX", "WONTIMPLNT", "WONTRESPND", "POSTPONED", "SPAM" )) {
        //    return "#f65752"; //red
        //}

        //if (status.equalsAny("RESOLVED", "SLAHOLD", "SCHED", "APPR", "APPFM", "APPLM", "BY DESIGN", "AUTHORIZED", "DUPLICATE", "AUTH", "FIXED", "HOLDINPRG",  "INPROG", "INPRG", "PLANNED", "ACC_CAT", "ASSESSES")) {
        //    return "#4488f2"; //blue
        //}

        //if (status.equalsAny("CLOSED", "IMPLEMENTED", "RESOLVCONF", "IMPL", "REVIEW", "CLOSE", "HISTEDIT", "COMP", "COMPLETED", "INPRG", "PLANNED")) {
        //    return "#39b54a"; //green
        //}

        //if (status.equalsAny("DRAFT")) {
        //    return "white";
        //}
        //return "#777";

        var statuscolorFallbackJson = $rootScope.statuscolorFallbackJson;
        if (!statuscolorFallbackJson || angular.equals({}, statuscolorFallbackJson)) {
            statuscolorFallbackJson = contextService.fetchFromContext("statuscolorfallback", true);
            $rootScope.statuscolorFallbackJson = statuscolorFallbackJson;
        }

        if (!statuscolorFallbackJson || !applicationname) {
            return "#777";
        }

        var applicationObject = statuscolorFallbackJson[applicationname];
        if (!applicationObject) {
            //if there is no default application in the json, stop here
            applicationObject = statuscolorFallbackJson["default"];
        }

        return applicationObject[status.toLowerCase()];
    };

    return {

        getColor: function (status, applicationname) {
            if (!status) {
                return "transparent";
            }

            var statuscolorJson = $rootScope.statusColor;
            if (statuscolorJson === undefined || angular.equals({}, statuscolorJson)) {
                statuscolorJson = contextService.fetchFromContext("statuscolor", true);
                $rootScope.statusColor = statuscolorJson;
            }

            //if the color json is missing, stop here
            if (statuscolorJson == null) {
                return fallbackFunction(status, applicationname);
            }

            //if the application is missing from the json file
            var applicationObject = statuscolorJson[applicationname];
            if (!applicationObject) {
                //if there is no default application in the json, stop here
                applicationObject = statuscolorJson["default"];
                if (!applicationObject) {
                    return fallbackFunction(status, applicationname);
                }
            }

            //check for the status in the application/default
            if (status in applicationObject || status.toLowerCase() in applicationObject) {
                return applicationObject[status.toLowerCase()];
            }

            //nothing else worked
            return fallbackFunction(status, applicationname);
        },

        load: function (jsonString, fallbackJson) {
            contextService.insertIntoContext("statuscolor", jsonString);
            contextService.insertIntoContext("statuscolorfallback", fallbackJson);
        },

        getColorObject: function(column, datamap, schema) {
            var service = schemaService.getProperty(schema, "list.colorscheme.service");
            const colorScheme = dispatcherService.invokeServiceByString(service, [column, datamap, schema]);
            if (!!colorScheme) {
                if (!colorScheme.forecolor) {
                    colorScheme.forecolor = 'white';
                }
            }

            return colorScheme;
        },

        /// <summary>
        /// convert named color or #rgb into #rrggbb format
        /// </summary>
        /// <param name="color">color value or named color</param>
        /// <returns type="tring">
        /// #rrggbb hex color
        /// </returns>
        colorToHex: function (color) {
            //create a test element
            var a = document.createElement('div');
            a.style.color = color;

            //get the color parts
            var colors = window.getComputedStyle(document.body.appendChild(a)).color.match(/\d+/g).map(function (a) {
                return parseInt(a, 10);
            });

            //remove the test element
            document.body.removeChild(a);

            //make sure the hex color is in #RRGGBB format
            return (colors.length >= 3) ? '#' + (((1 << 24) + (colors[0] << 16) + (colors[1] << 8) + colors[2]).toString(16).substr(1)) : null;
        },

        /// <summary>
        /// calculate foreground color based on background color value
        /// based on https://24ways.org/2010/calculating-color-contrast/
        /// </summary>
        /// <param name="hex">color value</param>
        /// <returns type="string">
        /// hex color value
        /// </returns>
        foregroundColor: function (color) {
            var backgroundRGB = this.colorToHex(color);

            //default to black foreground color
            if (!backgroundRGB) {
                return '#000';
            }

            return parseInt(backgroundRGB.substring(1), 16) > 0xffffff / 2 ? '#000' : '#fff';
        },

        getPriorityColor: function (priority) {
            if (priority === 1 || priority === "1") {
                return "#39b54a"; //green
            }
            if (priority === 2 || priority === "2") {
                return "#4488f2"; //blue
            }
            if (priority === 3 || priority === "3") {
                return "#D850FA"; //purple
            }
            if (priority === 4 || priority === "4") {
                return "#f2d935"; //yellow
            }
            if (priority === 5 || priority === "5") {
                return "#e59323"; //orange
            }
            if (priority === 6 || priority === "6") {
                return "#f65752"; //red
            }
            return "#777";
        }
    };
}]);

})(modules);;
const modalShown = "sw.modal.show";
const modalClosed = "sw.modal.closed";
const HideModal = "sw.modal.hide";
const crudSaved = "sw.crud.detail.savecompleted";
const CrudSubmitData = "sw.crud.detail.submit";
const FormDoubleClicked = "sw.crud.detail.doubleclick";

const BodyRendered = "sw.crud.body.rendered";

//internal event to indicate that all tabs of the crud_body have rendered
const TabsLoaded = "sw.crud.body.alltabsloaded";

const MoveFocus = "sw.crud.body.movefocus";

const ResetFocusToCurrent = "sw.crud.input.resetfocustocurrent";

//used to navigate back of forward towards next/previous entries on the form
const NavigateRequestCrawl = "sw.crud.body.crawl";

const NavigateRequestCrawlOcurred = "sw.crud.body.crawlocurred";

const AjaxError = "sw.ajax.error";

const AjaxFinished = "sw.ajax.finished";

const AjaxInit = "sw.ajax.init";



//#region print

const ReadyToPrint = "sw.application.print.ready";

const PrintReadyForList = "sw.application.print.readyforlist";
const PrintReadyForDetailedList = "sw.application.print.readyfordetailedlist";

const PrintShowModal = "sw.application.print.showmodal";
const PrintHideModal = "sw.application.print.hidemodal";

const PrintSectionRendered = "sw.application.print.sectionrendered";

//#endregion


//#region navigation

/**
 * Event that happens whenever an application (and not only a schema) changes
 */
const AppChanged = "sw.crud.applicationchanged";
//TODO:
const AppRedirected = "sw.crud.navigation.applicationredirected";

const TitleChanged = "sw.crud.navigation.titlechanged";

const RenderView = "sw.crud.navigation.renderview";

const LoginHappened = "sw.crud.navigation.login";

/**
 * Event that happens when a detail page has finish loading. Note that neither the compositions nor the associations have yet been loaded at this stage.
 */
const DetailLoaded = "sw.crud.navigation.detailloaded";

//TODO: reconsider this one
const RenderViewWithData = "sw.crud.navigation.renderwithdata";

const REDIRECT_BEFORE = "sw.crud.navigation.beforeredirection";

//Happens after the server side has returned data and the app is ready to redirect
const REDIRECT_AFTER = "sw.crud.navigation.redirected";

const REDIRECT_AFTERACTION = "sw.crud.navigation.actionredirected";





//#endregion

//#region grid
//Event to dispatch grid refresh on the current list
const REFRESH_GRID = "sw.crud.list.refreshgrid";

//Event to indicate that the grid has been refreshed
const GRID_REFRESHED = "sw.crud.list.gridrefreshed";

//event to clear the underlying quick search
const ClearQuickSearch = "sw.crud.list.clearQuickSearch";

//event to toggle the selection mode on grids with checkboxes
const ToggleSelectionMode = "sw.crud.list.toggleselectionmode";

//event to switch the mode showing only the selecte or all entries of a grid
const ToggleSelected = "sw.crud.list.toggleselected";

// event to reset the toggle buttons to initial state
const ReloadToggleState = "sw.crud.list.reloadtogglestate";

//event to indicate that the crud_tbody has finished processing for real
const ListTableRendered = "sw.crud.list.tbodyrendered";

//event to indicate that the filter row has finished rendering
const FilterRowRendered = "sw.crud.list.filterrowrendered";

//event to indicate that a new grid rendering is needed. This is after the result is already fetched from the server
const GridDataChanged = "sw.crud.list.griddatachanged";

//setting a new filter
//TODO: viewmodel approach?
const GRID_SETFILTER = "sw.crud.list.setfilter";

const GridClearFilter = "sw.crud.list.clearfilter";




//TODO: refactor
const GRID_CHANGED = "sw.crud.list.gridchanged";

//TODO:refactor
const GRID_REFRESH = "sw.grid.refresh";

//#endregion


//#region association

//indicates that the associations of the form have been resolved
const AssociationResolved = "sw.crud.association.resolved";

// ??
const AssociationUpdated = "sw.crud.association.updated";

//indicates that the a eager association has been updated
const Association_EagerOptionUpdated = "sw.crud.associations.updateeageroptions";

//manual event to clear the cache results for an autocomplete cache(angulartypeahead). This should happen whenever the query for the autocomplete needs to be reevaluated 
//(ex: a location changes, invalidating the asset results)
const ClearAutoCompleteCache = "sw.crud.association.clearautocompletecache";


//#endregion

//#region composition

const COMPOSITION_RESOLVED = "sw.crud.composition.dataresolved";
const COMPOSITION_EDIT = "sw.crud.composition.edit";
const COMPOSITION_REFRESH_PAGE = "sw.crud.composition.refreshpage";
const COMPOSITION_BATCH_ADD_MULTIPLE = "sw.crud.composition.batch.add.multiple";

//#endregion


//#region layout

const FORCE_RESIZE = "sw.layout.forceresize";

const REEVAL_DISPLAYABLES = "sw.layout.dynforms.reevaldisplayables";



//#endregion

class JavascriptEventConstants {



    static get ModalShown() {
        return modalShown;
    }

    static get ModalClosed() {
        return modalClosed;
    }

    //#region print

    static get ReadyToPrint() {
        return ReadyToPrint;
    }

    static get PrintReadyForList() {
        return PrintReadyForList;
    }

    static get PrintReadyForDetailedList() {
        return PrintReadyForDetailedList;
    }

    static get PrintShowModal() {
        return PrintShowModal;
    }

    static get PrintHideModal() {
        return PrintHideModal;
    }

    static get PrintSectionRendered() {
        return PrintSectionRendered;
    }

    //#endregion



    static get HideModal() {
        return HideModal;
    }

    static get ErrorAjax() {
        return AjaxError;
    }

    static get AjaxFinished() {
        return AjaxFinished;
    }

    static get AjaxInit() {
        return AjaxInit;
    }


    static get BodyRendered() {
        return BodyRendered;
    }

    static get TabsLoaded() {
        return TabsLoaded;
    }

    static get NavigateRequestCrawl() {
        return NavigateRequestCrawl;
    }

    static get NavigateRequestCrawlOcurred() {
        return NavigateRequestCrawlOcurred;
    }

    static get MoveFocus() {
        return MoveFocus;
    }

    static get ResetFocusToCurrent() {
        return ResetFocusToCurrent;
    }


    //#region navigation
    
    static get AppChanged() {
        return AppChanged;
    }

    static get Login() {
        return LoginHappened;
    }

    static get AppBeforeRedirection() {
        return REDIRECT_BEFORE;
    }

    static get REDIRECT_AFTER() {
        return REDIRECT_AFTER;
    }

    static get ActionAfterRedirection() {
        return REDIRECT_AFTERACTION;
    }

    static get ApplicationRedirected() {
        return AppRedirected;
    }

    static get TitleChanged() {
        return TitleChanged;
    }

    static get DetailLoaded() {
        return DetailLoaded;
    }

    static get RenderView() {
        return RenderView;
    }

    static get RenderViewWithData() {
        return RenderViewWithData;
    }



    //#endregion

    static get CrudSaved() {
        return crudSaved;
    }

    static get CrudSubmitData() {
        return CrudSubmitData;
    }

    static get FormDoubleClicked() {
        return FormDoubleClicked;
    }


    //#region association

    static get AssociationResolved() {
        return AssociationResolved;
    }
    static get Association_EagerOptionUpdated() {
        return Association_EagerOptionUpdated;
    }

    static get ClearAutoCompleteCache() {
        return ClearAutoCompleteCache;
    }

    //#endregion


    //#region grid

    static get RefreshGrid() {
        return REFRESH_GRID;
    }

    static get GRID_REFRESHED() {
        return GRID_REFRESHED;
    }

    //TODO:
    static get GRID_REFRESH2() {
        return GRID_REFRESH;
    }

    static get GRID_SETFILTER() {
        return GRID_SETFILTER;
    }

    static get GRID_CLEARFILTER() {
        return GridClearFilter;
    }

    static get GRID_CHANGED() {
        return GRID_CHANGED;
    }

    static get ListTableRendered() {
        return ListTableRendered;
    }

    static get GridDataChanged() {
        return GridDataChanged;
    }

    static get FilterRowRendered() {
        return FilterRowRendered;
    }


    static get ClearQuickSearch() {
        return ClearQuickSearch;
    }

    static get ToggleSelectionMode() {
        return ToggleSelectionMode;
    }

    static get ToggleSelected() {
        return ToggleSelected;
    }

    static get ReloadToggleState() {
        return ReloadToggleState;
    }

    //#endregion


    //#region composition

    static get COMPOSITION_RESOLVED() {
        return COMPOSITION_RESOLVED;
    }

    static get CompositionEdit() {
        return COMPOSITION_EDIT;
    }

    static get CompositionRefreshPage() {
        return COMPOSITION_REFRESH_PAGE;
    }

    static get CompositionBatchAddMultiple() {
        return COMPOSITION_BATCH_ADD_MULTIPLE;
    }

    //#endregion

    //#region layoyut

    static get ForceResize() {
        return FORCE_RESIZE;
    }


    static get ReevalDisplayables() {
        return REEVAL_DISPLAYABLES;
    }

    //#endregion

}




;
if (typeof String.prototype.endsWith !== 'function') {
    String.prototype.endsWith = function (suffix) {
        return this.indexOf(suffix, this.length - suffix.length) !== -1;
    };
}

if (typeof String.prototype.startsWith != 'function') {
    String.prototype.startsWith = function (str) {
        if (str == undefined) {
            return false;
        }
        return this.slice(0, str.length) == str;
    };
}

function isString(o) {
    return (o !== null && o !== undefined) && (typeof o === "string" || (typeof o === "object" && o.constructor === String));
}

String.prototype.format = String.prototype.f = function () {
    var s = this,
    i = arguments.length;
    while (i--) {
        s = s.replace(new RegExp('\\{' + i + '\\}', 'gm'), arguments[i]);
    }
    return s;
};

String.prototype.in = String.prototype.f = function () {
    var s = this;
    return s.equalsAny(arguments);
};

String.prototype.equalsAny = String.prototype.f = function () {
    var s = this,
    i = arguments.length;
    while (i--) {
        if (arguments[i].isEqual(s, true)) {
            return true;
        }
    }
    return false;
};

String.prototype.equalsIc = String.prototype.f = function () {
    return this.isEqual(arguments[0], true);
};


String.prototype.nullOrEmpty = String.prototype.f = function () {
    var s = this;
    return s.trim().length == 0;
};

String.prototype.isEqual = String.prototype.f = function (other, ignoreCase) {
    var s = this;
    if (!ignoreCase) {
        return s == other;
    }
    if (other == null) {
        return false;
    }
    return s.toLowerCase() == other.toLowerCase();
};

String.prototype.equalIc = String.prototype.f = function (other) {
    var s = this;
    if (other == null) {
        return false;
    }
    return s.toLowerCase() == other.toLowerCase();
};


var nullOrEmpty = function (s) {
    return nullOrUndef(s) || String(s).trim().length === 0;
};

var isNullOrEmpty = function (s) {
    return nullOrUndef(s) || String(s).trim().length === 0;
};

var isArrayNullOrEmpty = function (arr) {
    return nullOrUndef(arr) || arr.length === 0;
};


String.format = function () {
    var s = arguments[0];
    for (var i = 0; i < arguments.length - 1; i++) {
        var reg = new RegExp("\\{" + i + "\\}", "gm");
        s = s.replace(reg, arguments[i + 1]);
    }
    return s;
};

if (typeof String.prototype.byteSize !== "function") {
    /**
     * @returns String's size in bytes
     */
    String.prototype.byteSize = function () {
        return encodeURI(this).split(/%(?:u[0-9A-F]{2})?[0-9A-F]{2}|./).length - 1;
    };
}

String.prototype.containsIgnoreCase = function (search) {
    search = search.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    return new RegExp(search, "i").test(this);
};

String.prototype.repeat = function(times) {
    return new Array(times + 1).join(this);
};
if (typeof String.prototype.endsWith !== 'function') {
    String.prototype.endsWith = function (suffix) {
        return this.indexOf(suffix, this.length - suffix.length) !== -1;
    };
}

if (typeof String.prototype.startsWith != 'function') {
    String.prototype.startsWith = function (str) {
        if (str == undefined) {
            return false;
        }
        return this.slice(0, str.length) == str;
    };
}

var BrowserDetect =
{
    init: function () {
        this.browser = this.searchString(this.dataBrowser) || "Other";
        this.version = this.searchVersion(navigator.userAgent) || this.searchVersion(navigator.appVersion) || "Unknown";
    },

    searchString: function (data) {
        for (let i = 0 ; i < data.length ; i++) {
            const dataString = data[i].string;
            this.versionSearchString = data[i].subString;

            if (dataString.indexOf(data[i].subString) != -1) {
                return data[i].identity;
            }
        }
    },

    searchVersion: function (dataString) {
        const index = dataString.indexOf(this.versionSearchString);
        if (index == -1) return;
        return parseFloat(dataString.substring(index + this.versionSearchString.length + 1));
    },

    dataBrowser:
    [
        { string: navigator.userAgent, subString: "Chrome", identity: "Chrome" },
        { string: navigator.userAgent, subString: "MSIE", identity: "Explorer" },
        { string: navigator.userAgent, subString: "Firefox", identity: "Firefox" },
        { string: navigator.userAgent, subString: "Safari", identity: "Safari" },
        { string: navigator.userAgent, subString: "Opera", identity: "Opera" }
    ]

};
BrowserDetect.init();




var DeviceDetect =
{
    init: function () {
        this.os = this.searchString(this.dataOS) || 'Unknown';
        this.catagory = this.getType(this.os) || 'Unknown';
    },

    searchString: function (data) {
        for (let i = 0 ; i < data.length ; i++) {
            const dataString = data[i].string;
            this.versionSearchString = data[i].subString;

            if (dataString.indexOf(data[i].subString) != -1) {
                return data[i].identity;
            }
        }
    },

    getType: function (os) {
        if (os === 'Unknown') {
            return;
        }

        var catagory;

        switch (os) {
            case 'Windows':
            case 'Macintosh':
            default:
                catagory = 'Desktop';
                break;
            case 'Android':
            case 'iPhone':
            case 'iPad':
                catagory = 'Mobile';
        }

        return catagory;
    },

    dataOS:
    [
        { string: navigator.userAgent, subString: 'Windows', identity: 'Windows' },
        { string: navigator.userAgent, subString: 'Macintosh', identity: 'Macintosh' },
        { string: navigator.userAgent, subString: 'Android', identity: 'Android' },
        { string: navigator.userAgent, subString: 'iPhone', identity: 'iPhone' },
        { string: navigator.userAgent, subString: 'iPad', identity: 'iPad' }
    ]

};
DeviceDetect.init();


const RequiredParam = () => { throw new Error("Required Parameter"); }

function isMobile() {
    return DeviceDetect.catagory == 'Mobile';
};

function isDesktop() {
    return DeviceDetect.catagory == 'Desktop';
};

function safeCSSselector(name) {

    //if column has an attribute property, else return an empty string
    if (name) {
        //make sure name is all lower case
        let newName = name.toLowerCase();

        //replace invaild characters with underscores

        //TODO: make more robust, add additional invalid characters
        newName = newName.replace('.', '_');
        newName = newName.replace('#', '_');

        return newName;
    } else {
        return "";
    }
}



function instantiateIfUndefined(obj, nullcheck) {
    const shouldNullCheck = nullcheck === undefined || nullcheck == true;
    if (obj === undefined || (shouldNullCheck && obj === null)) {
        obj = {};
    }
    return obj;
}

function FillRelationship(obj, property, valueToSet) {
    property = property.replace(/_/g, '_\.');
    property = property.replace(/\.\./g, '\.');
    return JsonProperty(obj, property, valueToSet, true);
}

function GetRelationshipName(property) {
    property = property.replace(/_/g, '_\.');
    property = property.replace(/\.\./g, '\.');
    return property;
}

function RemoveSpecialChars(id) {
    //remove all occurences of special chars (except _) (to remove # mainly)
    return id.replace(/[^\w\s]/gi, '');
}

function JsonProperty(obj, property, valueToSet, forceCreation) {
    const prop = property.split('.');
    var value = obj;
    for (let i = 0; i < prop.length; i++) {
        if (value.hasOwnProperty(prop[i])) {
            value = value[prop[i]];
        } else {
            if (valueToSet != undefined || forceCreation) {
                if (i == prop.length - 1) {
                    value[prop[i]] = valueToSet;
                } else {
                    value[prop[i]] = {};
                }
                value = value[prop[i]];
            } else {
                return null;
            }
        }
    }

    return value;
}

Date.prototype.mmddyyyy = Date.prototype.f = function () {
    const yyyy = this.getFullYear().toString();
    const mm = (this.getMonth() + 1).toString();
    // getMonth() is zero-based
    const dd = this.getDate().toString();
    return (mm[1] ? mm : "0" + mm[0]) + "/" + (dd[1] ? dd : "0" + dd[0]) + "/" + yyyy; // padding
};

/****************String functions****************************************************/

String.prototype.format = String.prototype.f = function () {
    var s = this,
    i = arguments.length;
    while (i--) {
        s = s.replace(new RegExp('\\{' + i + '\\}', 'gm'), arguments[i]);
    }
    return s;
};

String.prototype.nullOrEmpty = String.prototype.f = function () {
    const s = this;
    return s.trim().length == 0;
};

String.prototype.isEqual = String.prototype.f = function (other, ignoreCase) {
    const s = this;
    if (!ignoreCase) {
        return s === other;
    }
    if (other == null || !isString(other)) {
        return false;
    }

    return s.toLowerCase() === other.toLowerCase();
};

String.prototype.contains = function (str) {
    return this.indexOf(str) >= 0;
};


function nullOrCommaSplit(value) {
    if (value == null || value === "") {
        return null;
    }
    return value.split(",");
}

function emptyIfNull(value) {
    if (value == null) {
        return "";
    }
    return value;
}

function booleanEquals(value1, value2) {
    if (value1 === value2) {
        return true;
    }
    if (value1 == "1" || value1 == "true") {
        return value2 == "true" || value2 == "1";
    }

    if (value2 == "1" || value2 == "true") {
        return value1 == "true" || value1 == "1";
    }

    if (value1 == "0" || value1 == "false") {
        return value2 == "false" || value2 == "0";
    }

    if (value2 == "0" || value2 == "false") {
        return value1 == "false" || value1 == "0";
    }
    return false;


}

var nullOrEmpty = function (s) {
    return nullOrUndef(s) || String(s).trim().length == 0;
};

var isArrayNullOrEmpty = function (arr) {
    return nullOrUndef(arr) || arr.length == 0;
};

var hasSingleElement = function (arr) {
    return !nullOrUndef(arr) && arr.length == 1;
};

var safePush = function (baseObject, propertyName, item) {
    if (!item || !baseObject || !propertyName) return;

    if (!baseObject[propertyName]) {
        baseObject[propertyName] = [];
    }
    const arr = baseObject[propertyName];

    if (item.id == null) {
        arr.push(item);
    } else {
        const idx = arr.findIndex(a => (a.id != null && a.id === item.id));
        if (idx !== -1) {
            arr[idx] = item;
        } else {
            arr.push(item);
        }
    }

    
}

var nullifyProperties = function (baseObject, propertyArray) {
    if (!propertyArray || !baseObject) {
        return;
    }

    for (let i = 0; i < propertyArray.length; i++) {
        const propName = propertyArray[i];
        baseObject[propName] = null;
    }
}

String.format = function () {
    var s = arguments[0];
    for (let i = 0; i < arguments.length - 1; i++) {
        const reg = new RegExp("\\{" + i + "\\}", "gm");
        s = s.replace(reg, arguments[i + 1]);
    }
    return s;
};

$.extend({
    findFirst: function (elems, validateCb) {
        if (elems == null) {
            return undefined;
        }
        var i;
        for (i = 0 ; i < elems.length ; ++i) {
            if (validateCb(elems[i], i))
                return elems[i];
        }
        return undefined;
    }
});



function nullOrUndef(obj) {
    return obj === undefined || obj == null;
}

function insertOrUpdateArray(arr, item, property) {
    property = property || "id";
    var idx = -1;
    for (let i = 0; i < arr.length; i++) {
        if (arr[i][property] == item[property]) {
            idx = i;
            break;
        }
    }
    if (idx == -1) {
        arr.push(item);
    } else {
        arr[idx] = item;
    }
}

function lockCommandBars() {
    const bars = $('[data-classplaceholder=commandbar]');
    bars.each(function (index, element) {
        const buttons = $(element).find('button');
        for (let i = 0; i < buttons.length; i++) {
            const button = $(buttons[i]);
            if (button.prop('disabled') !== true) {
                //lets disable only those who arenÂ´t already disabled
                button.attr('disabled', 'disabled');
                button.attr('forceddisable', 'disabled');
            }
        }

    });
}

function unLockCommandBars() {
    const bars = $('[data-classplaceholder=commandbar]');
    bars.each(function (index, element) {
        const buttons = $(element).find('button');
        for (let i = 0; i < buttons.length; i++) {
            const button = $(buttons[i]);
            if (button.attr('forceddisable') === 'disabled') {
                button.removeAttr('disabled');
            }
        }
    });
}

function lockTabs() {
    const tabs = $('[data-toggle=tab]');
    tabs.each(function (index, element) {
        const jquery = $(element);
        jquery.removeAttr('data-toggle');
        jquery.attr('data-toggle', 'tab_inactive');
        //        jquery.css('cursor', 'no-drop');
    });
}

function unLockTabs() {
    const tabs = $('[data-toggle=tab_inactive]');
    tabs.each(function (index, element) {
        const jquery = $(element);
        jquery.removeAttr('data-toggle');
        jquery.attr('data-toggle', 'tab');
        //        jquery.css('cursor', null);
    });
}

function capitaliseFirstLetter(string) {
    const fullstring = string.split(/[ ]+/);
    var returnstring = '';
    for (let i = 0; i < fullstring.length; i++) {
        returnstring += fullstring[i].charAt(0).toUpperCase() + fullstring[i].slice(1);
        returnstring += (i + 1) == fullstring.length ? '' : ' ';
    }
    return returnstring;
}

// http://stackoverflow.com/questions/17907445/how-to-detect-ie11
function isIE11() {
    if (navigator.appName !== "Netscape") {
        return false;
    }
    const ua = navigator.userAgent;
    const re = new RegExp("Trident/.*rv:([0-9]{1,}[\.0-9]{0,})");
    return re.exec(ua) != null;
}

function isIE() {
    return BrowserDetect.browser === "Explorer" || isIE11();
}

function isIe9() {
    const mockie9 = sessionStorage["mockie9"];
    return (mockie9 === true || "true" === mockie9)
        ? true
        : isIE() && (BrowserDetect.version == '9' || BrowserDetect.version == '8' || BrowserDetect.version == '7');
};

function isChrome() {
    return BrowserDetect.browser === "Chrome";
};

function isFirefox() {
    return BrowserDetect.browser === "Firefox";
};

$.extend({
    keys: function (obj) {
        var a = [];
        $.each(obj, function (k) { a.push(k) });
        return a;
    }
});


function loadScript(baseurl, callback) {
    // Adding the script tag to the head as suggested before
    const head = document.getElementsByTagName('head')[0];
    const script = document.createElement('script');
    script.type = 'text/javascript';
    script.src = url(baseurl);

    // Then bind the event to the callback function.
    // There are several events for cross browser compatibility.
    script.onreadystatechange = callback;
    script.onload = callback;

    // Fire the loading
    head.appendChild(script);
}

function url(path) {
    if (angular.mock || window.cordova) {
        //this means weÂ´re running under test scenarios or on offline mode
        return path;
    }

    if (path == null) {
        return null;
    }
    if (path.endsWith("html")) {
        //replacing all the strings to lower was causing some issues with some http parameters which relied on case (ex: filter)
        // for the html templates, however, due to the template cache, we decided to have them all case-insensitive, thus this if
        path = path.toLowerCase();    
    }
    var root = location.protocol + '//' + location.hostname +
        (location.port ? ":" + location.port : "");

    if (root.search("localhost:") == -1) {
        root += "/softWrench";
    }

    if (path && path[0] != "/") {
        path = "/" + path;
    }
    const value = $(routes_basecontext)[0].value;
    if (value == "/") {
        return path;
    }
    return value + path;
}

function GetPopUpMode() {
    if (angular.mock) {
        //TODO: extract a service
        return "none";
    }

    var popupMode = $(hddn_popupmode)[0].value;
    if (popupMode === undefined || popupMode == 'null' || popupMode == "") {
        popupMode = 'none';
    }
    return popupMode;
}

function BuildDataObject() {
    const parameters = {};
    const data = $(crud_InitialData)[0].value;
    if (data === undefined || data == null || data == '') {
        return parameters;
    }
    parameters.data = data;
    return parameters;
}

function platformQS() {
    return "platform=" + platform();
}

function platform() {
    return "web";
}

function detailSchema() {
    return "detail";
}

function listSchema() {
    return "list";
}

function executeFunctionByName(functionName, context /*, args */) {
    const args = Array.prototype.slice.call(arguments).splice(2);
    const namespaces = functionName.split(".");
    const func = namespaces.pop();
    for (let i = 0; i < namespaces.length; i++) {
        context = context[namespaces[i]];
    }
    return context[func].apply(this, args);
}

function addCurrentSchemaDataToJson(json, schema) {
    json["%%currentschema"] = {};
    json["%%currentschema"].schemaId = schema.schemaId;
    json["%%currentschema"].mode = schema.mode;
    json["%%currentschema"].platform = platform();
    return json;
}

function addSchemaDataToJson(json, schema, nextSchemaObj) {
    json = addCurrentSchemaDataToJson(json, schema);
    if (nextSchemaObj) {
        json["%%nextschema"] = {};
        json["%%nextschema"].schemaId = nextSchemaObj.schemaId;
        if (nextSchemaObj.nextSchemaMode != null) {
            json["%%nextschema"].mode = nextSchemaObj.schemaMode;
        }
        json["%%nextschema"].platform = platform();
    }

    else if (schema.properties != null && schema.properties['nextschema.schemaid'] != null) {
        const nextschemaId = schema.properties['nextschema.schemaid'];
        json["%%nextschema"] = {};
        json["%%nextschema"].schemaId = nextschemaId;
        if (schema.properties['nextschema.schemamode'] != null) {
            json["%%nextschema"].mode = schema.properties['nextschema.schemamode'];
        }
        json["%%nextschema"].platform = platform();
    }
    return json;
}



function removeEncoding(crudUrl) {
    //this first one indicates an []
    crudUrl = replaceAll(crudUrl, "%5B%5D", "");
    crudUrl = replaceAll(crudUrl, "%5B", ".");
    crudUrl = replaceAll(crudUrl, "%5D", "");
    return crudUrl;
}

function getCurrentDate() {
    var today = new Date();
    var dd = today.getDate();
    var mm = today.getMonth() + 1; //January is 0!
    const yyyy = today.getFullYear();
    if (dd < 10) {
        dd = '0' + dd
    }

    if (mm < 10) {
        mm = '0' + mm
    }

    today = mm + '/' + dd + '/' + yyyy;
    return today;
}

function replaceAll(str, find, replace) {
    if (str == null) {
        return null;
    }
    return str.replace(new RegExp(find, 'g'), replace);
}

function imgToBase64(img) {
    const canvas = document.createElement("canvas");
    canvas.width = img.width;
    canvas.height = img.height;

    // Copy the image contents to the canvas
    const ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0);

    // Get the data-URL formatted image
    // Firefox supports PNG and JPEG. You could check img.src to
    // guess the original format, but be aware the using "image/jpg"
    // will re-encode the image.
    const dataURL = canvas.toDataURL("image/png");
    return dataURL;
}







function printWindow() {
    window.print();
}

function isEmpty(obj) {

    // null and undefined are "empty"
    if (obj == null) return true;

    // Assume if it has a length property with a non-zero value
    // that that property is correct.
    if (obj.length > 0) return false;
    if (obj.length === 0) return true;
    if (obj === "") return true;


    // Otherwise, does it have any properties of its own?
    // Note that this doesn't handle
    // toString and valueOf enumeration bugs in IE < 9
    for (let key in obj) {
        if (hasOwnProperty.call(obj, key)) return false;
    }

    return true;
}

/**
* Removes duplicates in object arrays. 
* ex.: var arr = [{id:1}, {id:2}, {id:1}, {id:3}];
* removeDuplicatesOnArray(arr, "id");  -----> [{id:1}, {id:2}, {id:3}]
* 
* @param {Object[]} array 
* @param {string} the name of unique key of the object to verify dulicates
* @returns {Object[]} Array without duplicates
*/
function removeDuplicatesOnArray(array, keyProp) {
    if (!array || !keyProp) {
        return array;
    }
    var indexes = [];
    var withoutDuplicates = [];
    array.forEach(function (option) {
        const index = option[keyProp];
        if (indexes.indexOf(index) >= 0) {
            return;
        }
        indexes.push(index);
        withoutDuplicates.push(option);
    });
    return withoutDuplicates;
}

/**
 * Generates a globally unique identifier (GUID)
 */
function guid() {
    function s4() {
        return Math.floor((1 + Math.random()) * 0x10000)
            .toString(16)
            .substring(1);
    }
    return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
        s4() + '-' + s4() + s4() + s4();
}

/* Base64 encode / decode http://www.webtoolkit.info/ */
var Base64 = {
    // private property
    _keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

    // public method for encoding
    encode: function (input) {
        var output = "";
        var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
        var i = 0;

        while (i < input.length) {

            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);

            enc1 = chr1 >> 2;
            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            enc4 = chr3 & 63;

            if (isNaN(chr2)) {
                enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
                enc4 = 64;
            }

            output = output +
            this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +
            this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);

        }

        return output;
    },

    // public method for decoding
    decode: function (input) {
        var output = "";
        var chr1, chr2, chr3;
        var enc1, enc2, enc3, enc4;
        var i = 0;

        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

        while (i < input.length) {

            enc1 = this._keyStr.indexOf(input.charAt(i++));
            enc2 = this._keyStr.indexOf(input.charAt(i++));
            enc3 = this._keyStr.indexOf(input.charAt(i++));
            enc4 = this._keyStr.indexOf(input.charAt(i++));

            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;

            output = output + String.fromCharCode(chr1);

            if (enc3 != 64) {
                output = output + String.fromCharCode(chr2);
            }
            if (enc4 != 64) {
                output = output + String.fromCharCode(chr3);
            }

        }

        return output;

    },

    // private method for UTF-8 encoding
    _utf8_encode: function (string) {
        string = string.replace(/\r\n/g, "\n");
        var utftext = "";

        for (let n = 0; n < string.length; n++) {
            const c = string.charCodeAt(n);
            if (c < 128) {
                utftext += String.fromCharCode(c);
            }
            else if ((c > 127) && (c < 2048)) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            }
            else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }

        }

        return utftext;
    },

    // private method for UTF-8 decoding
    _utf8_decode: function (utftext) {
        var string = "";
        var i = 0;
        var c = c1 = c2 = 0;

        while (i < utftext.length) {

            c = utftext.charCodeAt(i);

            if (c < 128) {
                string += String.fromCharCode(c);
                i++;
            }
            else if ((c > 191) && (c < 224)) {
                c2 = utftext.charCodeAt(i + 1);
                string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
                i += 2;
            }
            else {
                c2 = utftext.charCodeAt(i + 1);
                c3 = utftext.charCodeAt(i + 2);
                string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
                i += 3;
            }

        }

        return string;
    }

}


// only create debounce function if underscore is not present
if (typeof (window.debounce !== "function") && (!window._ || typeof (window._.debounce) !== "function")) {
    /**
     * Returns a function, that, as long as it continues to be invoked, will not
     * be triggered. The function will be called after it stops being called for
     * N milliseconds. If `immediate` is passed, trigger the function on the
     * leading edge, instead of the trailing. 
     * (from http://davidwalsh.name/javascript-debounce-function)
     * 
     * @param Function func 
     * @param Long wait milliseconds
     * @param Boolean immediate 
     * @returns debounced function 
     */
    window.debounce = function debounce(func, wait, immediate) {
        var timeout;
        return function() {
            var context = this, args = arguments;
            const later = function() {
                timeout = null;
                if (!immediate) func.apply(context, args);
            };
            const callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) func.apply(context, args);
        };
    };
} else {
    window.debounce = window._.debounce;
}

// only create throttle function if underscore is not present
if (typeof (window.throttle !== "function") && (!window._ || typeof (window._.throttle) !== "function")) {

    /**
     * Creates and returns a new, throttled version of the passed function, that, 
     * when invoked repeatedly, will only actually call the original function at most once per every wait milliseconds. 
     * Useful for rate-limiting events that occur faster than you can keep up with. 
     * By default, throttle will execute the function as soon as you call it for the first time, 
     * and, if you call it again any number of times during the wait period, as soon as that period is over. 
     * If you'd like to disable the leading-edge call, pass {leading: false}, 
     * and if you'd like to disable the execution on the trailing-edge, pass {trailing: false}.
     * (http://underscorejs.org/#throttle)
     * 
     * @param Function fn function to throttle
     * @param Number threshhold throttle interval in milliseconds
     * @param {} options
     * @returns Function throttle function 
     */
    window.throttle = function throttle(func, wait, options) {
        var context, args, result;
        var timeout = null;
        var previous = 0;
        if (!options) options = {};
        var later = function() {
            previous = options.leading === false ? 0 : Date.now();
            timeout = null;
            result = func.apply(context, args);
            if (!timeout) context = args = null;
        };
        return function() {
            const now = Date.now();
            if (!previous && options.leading === false) previous = now;
            const remaining = wait - (now - previous);
            context = this;
            args = arguments;
            if (remaining <= 0 || remaining > wait) {
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = null;
                }
                previous = now;
                result = func.apply(context, args);
                if (!timeout) context = args = null;
            } else if (!timeout && options.trailing !== false) {
                timeout = setTimeout(later, remaining);
            }
            return result;
        };
    }
} else {
    window.throttle = window._.throttle;
}

// returns the value of the given parameter name from the current url
window.getUrlParameter = function getUrlParameter(sParam) {
    const sPageUrl = decodeURIComponent(window.location.search.substring(1));
    const sUrlVariables = sPageUrl.split("&");
    var sParameterName;

    for (let i = 0; i < sUrlVariables.length; i++) {
        sParameterName = sUrlVariables[i].split("=");

        if (sParameterName[0] === sParam) {
            return sParameterName[1] === undefined ? true : sParameterName[1];
        }
    }

    return null;
}

if (typeof (Object.values !== "function")) {
    Object.values = function(obj) {
        return Object.keys(obj).map(function(key) {
            return obj[key];
        });
    };
}

jQuery.fn.extend({
    exists: function() {
        return this.length > 0;
    }
});
Array.prototype.subarray = function (start, end) {
    if (!end) {
        end = -1;
    }
    return this.slice(start, this.length + 1 - (end * -1));
}

/**
 * Flattens a nested array (works with any level of 'nestedness') e.g.
 * [1, [2, 3, [4, 5]], 6, [7, [8, [9]]]].flatten() === [1, 2, 3, 4, 5, 6, 7, 8, 9]
 * @see http://stackoverflow.com/questions/27266550/how-to-flatten-nested-array-in-javascript 
 * @returns flattened array 
 */
Array.prototype.flatten = function () {
    var toString = Object.prototype.toString;
    var arrayTypeStr = "[object Array]";

    var result = [];
    var nodes = this;
    var node;

    if (!this.length) {
        return result;
    }

    node = nodes.pop();

    do {
        if (toString.call(node) === arrayTypeStr) {
            nodes.push.apply(nodes, node);
        } else {
            result.push(node);
        }
    } while (nodes.length && (node = nodes.pop()) !== undefined);

    result.reverse(); // we reverse result to restore the original order
    return result;
};


Array.prototype.find = Array.prototype.find || function(fn) {
    var arr = this;
    for (var i = 0; i < arr.length; i++) {
        var item = arr[i];
        if (fn(item)) {
            return item;
        }
    }
    return null;
}


Array.prototype.firstOrDefault = function (fn) {
        var arr = this;
        for (var i = 0; i < arr.length; i++) {
            var item = arr[i];
            if (fn(item)) {
                return item;
            }
        }
        return null;
    }


Array.prototype.findIndex = Array.prototype.findIndex || function (predicate, thisArg) {
    "use strict";
    //TODO: Check predicate is a function.
    var lastIndex = -1;
    if (!Array.prototype.some.call(this, function (val, index, arr) {
        return predicate.call(thisArg, val, lastIndex = index, arr);
    })) {
        return -1;
    }

    return lastIndex;
}

Array.prototype.equals = function (array) {
    return this.length == array.length &&
           this.every(function (this_i, i) { return this_i == array[i] })
}


if (typeof (Array.prototype.distinct) !== "function") {
    // from http://stackoverflow.com/questions/9229645/remove-duplicates-from-javascript-array#answer-9229821
    Array.prototype.distinct = function () {
        var seen = {};
        var out = [];
        var len = this.length;
        var j = 0;
        for (var i = 0; i < len; i++) {
            var item = this[i];
            if (seen[item] !== 1) {
                seen[item] = 1;
                out[j++] = item;
            }
        }
        return out;
    }
};
/// <summary>
/// Copy all of the matching properties of the src object into the destination object
/// </summary>
/// <param name="src"></param>
/// <param name="destination"></param>
function mergeObjects(src, destination) {

    for (var prop in src) {
        if (!src.hasOwnProperty(prop)) {
            continue;
        }
        if (destination.hasOwnProperty(prop)) {
            destination[prop] = src[prop];
        }
    }
    return destination;

}

var isObjectEmpty = function (ob) {
    for (var prop in ob) {
        if (ob.hasOwnProperty(prop)) {
            return false;
        }
    }
    return true;
}


function setDeep(el, key, value) {
    key = key.split('.');
    var i = 0, n = key.length;
    for (; i < n - 1; ++i) {
        el = el[key[i]];
    }
    return el[key[i]] = value;
}

function getDeep(el, key) {
    key = key.split('.');
    var i = 0, n = key.length;
    for (; i < n; ++i) {
        el = el[key[i]];
    }
    return el;
}

;
/*
    cycle.js
    2017-02-07

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.
*/

// The file uses the WeakMap feature of ES6.

/*jslint es6, eval */

/*property
    $ref, decycle, forEach, get, indexOf, isArray, keys, length, push,
    retrocycle, set, stringify, test
*/

if (typeof JSON.decycle !== "function") {
    JSON.decycle = function decycle(object, replacer) {
        "use strict";

        // Make a deep copy of an object or array, assuring that there is at most
        // one instance of each object or array in the resulting structure. The
        // duplicate references (which might be forming cycles) are replaced with
        // an object of the form

        //      {"$ref": PATH}

        // where the PATH is a JSONPath string that locates the first occurance.

        // So,

        //      var a = [];
        //      a[0] = a;
        //      return JSON.stringify(JSON.decycle(a));

        // produces the string '[{"$ref":"$"}]'.

        // If a replacer function is provided, then it will be called for each value.
        // A replacer function receives a value and returns a replacement value.

        // JSONPath is used to locate the unique object. $ indicates the top level of
        // the object or array. [NUMBER] or [STRING] indicates a child element or
        // property.

        var objects = new WeakMap();     // object to path mappings

        return (function derez(value, path) {

            // The derez function recurses through the object, producing the deep copy.

            var old_path;   // The path of an earlier occurance of value
            var nu;         // The new object or array

            // If a replacer function was provided, then call it to get a replacement value.

            if (replacer !== undefined) {
                value = replacer(value);
            }

            // typeof null === "object", so go on if this value is really an object but not
            // one of the weird builtin objects.

            if (
                typeof value === "object" && value !== null &&
                !(value instanceof Boolean) &&
                !(value instanceof Date) &&
                !(value instanceof Number) &&
                !(value instanceof RegExp) &&
                !(value instanceof String)
            ) {

                // If the value is an object or array, look to see if we have already
                // encountered it. If so, return a {"$ref":PATH} object. This uses an
                // ES6 WeakMap.

                old_path = objects.get(value);
                if (old_path !== undefined) {
                    return { $ref: old_path };
                }

                // Otherwise, accumulate the unique value and its path.

                objects.set(value, path);

                // If it is an array, replicate the array.

                if (Array.isArray(value)) {
                    nu = [];
                    value.forEach(function (element, i) {
                        nu[i] = derez(element, path + "[" + i + "]");
                    });
                } else {

                    // If it is an object, replicate the object.

                    nu = {};
                    Object.keys(value).forEach(function (name) {
                        nu[name] = derez(
                            value[name],
                            path + "[" + JSON.stringify(name) + "]"
                        );
                    });
                }
                return nu;
            }
            return value;
        }(object, "$"));
    };
}


if (typeof JSON.retrocycle !== "function") {
    JSON.retrocycle = function retrocycle($) {
        "use strict";

        // Restore an object that was reduced by decycle. Members whose values are
        // objects of the form
        //      {$ref: PATH}
        // are replaced with references to the value found by the PATH. This will
        // restore cycles. The object will be mutated.

        // The eval function is used to locate the values described by a PATH. The
        // root object is kept in a $ variable. A regular expression is used to
        // assure that the PATH is extremely well formed. The regexp contains nested
        // * quantifiers. That has been known to have extremely bad performance
        // problems on some browsers for very long strings. A PATH is expected to be
        // reasonably short. A PATH is allowed to belong to a very restricted subset of
        // Goessner's JSONPath.

        // So,
        //      var s = '[{"$ref":"$"}]';
        //      return JSON.retrocycle(JSON.parse(s));
        // produces an array containing a single element which is the array itself.

        var px = /^\$(?:\[(?:\d+|"(?:[^\\"\u0000-\u001f]|\\([\\"\/bfnrt]|u[0-9a-zA-Z]{4}))*")\])*$/;

        (function rez(value) {

            // The rez function walks recursively through the object looking for $ref
            // properties. When it finds one that has a value that is a path, then it
            // replaces the $ref object with a reference to the value that is found by
            // the path.

            if (value && typeof value === "object") {
                if (Array.isArray(value)) {
                    value.forEach(function (element, i) {
                        if (typeof element === "object" && element !== null) {
                            var path = element.$ref;
                            if (typeof path === "string" && px.test(path)) {
                                value[i] = eval(path);
                            } else {
                                rez(element);
                            }
                        }
                    });
                } else {
                    Object.keys(value).forEach(function (name) {
                        var item = value[name];
                        if (typeof item === "object" && item !== null) {
                            var path = item.$ref;
                            if (typeof path === "string" && px.test(path)) {
                                value[name] = eval(path);
                            } else {
                                rez(item);
                            }
                        }
                    });
                }
            }
        }($));
        return $;
    };
};
!(function (modules, angular) {
    "use strict";

    modules.rootCommons.service("contextService", ["$log", "$rootScope", function ($log, $rootScope) {

        return {
            //using sessionstorage instead of rootscope, as the later would be lost upon F5.
            //see SWWEB-239
            insertIntoContext: function (key, value, userootscope) {
                const urlContext = url("");
                if (userootscope) {
                    $rootScope[urlContext + ':ctx_' + key] = value;
                } else {
                    if (value != null && !isString(value)) {
                        value = JSON.stringify(value);
                    }
                    sessionStorage[urlContext + ':ctx_' + key] = value;
                }
                return value;
            },

            set: function (key, value, userootscope) {
                return this.insertIntoContext(key, value, userootscope);
            },

            get: function (key, isJson, userootscope) {
                return this.fetchFromContext(key, isJson, userootscope);
            },

            fetchFromContext: function (key, isJson, userootscope, removeentry) {
                //shortcut method
                const value = this.retrieveFromContext(key, userootscope, removeentry);
                if (value == "undefined") {
                    return undefined;
                }
                if (value != null && isJson == true && isString(value)) {
                    return JSON.parse(value);
                }
                return value;
            },

            //shortcut method
            getFromContext: function (key, isJson, userootscope) {
                return this.fetchFromContext(key, isJson, userootscope);
            },

            retrieveFromContext: function (key, userootscope, removeentry) {
                const urlContext = url("");
                if (userootscope) {
                    const object = $rootScope[urlContext + ':ctx_' + key];
                    if (removeentry) {
                        delete $rootScope[urlContext + ':ctx_' + key];
                    }
                    return object;
                }
                const sessionContextValue = sessionStorage[urlContext + ':ctx_' + key];
                if (removeentry) {
                    sessionStorage.removeItem([urlContext + ':ctx_' + key]);
                }
                if (sessionContextValue == "null") {
                    return null;
                }
                return sessionContextValue;
            },

            deleteFromContext: function (key) {
                const urlContext = url("");
                delete sessionStorage[urlContext + ":ctx_" + key];
                delete $rootScope[urlContext + ":ctx_" + key];
            },

            isLocal: function () {
                if (localStorage.mocknonlocal || sessionStorage.mocknonlocal) {
                    return false;
                }
                if (angular.mock) {
                    //unit tests should be considerered local too
                    return true;
                }
                const contextValue = this.retrieveFromContext("isLocal");
                return !!contextValue && contextValue === "true";
            },

            isDev: function () {
                //return this.retrieveFromContext('environment') == "dev";

                //return true if the environment begins with dev
                const environment = this.retrieveFromContext("environment");
                return !environment || environment.indexOf("dev") === 0;
            },

            client: function () {
                return this.retrieveFromContext("clientName");
            },

            isClient: function (name) {
                const clientName = this.client();
                if (name === clientName) {
                    return true;
                }
                if (angular.isArray(name)) {
                    if (jQuery.inArray(clientName, name)) {
                        return true;
                    }
                }
                if (!name) {
                    $log.getInstance('contextService#isClient').warn("asked for null client name")
                    return false;
                }
                return false;
            },
            getUserData: function () {
                if (angular.mock) {
                    //for unit tests letÂ´s return a mocked user
                    return { login: "testuser" };
                }

                if ($rootScope.user != null) {
                    //caching
                    return $rootScope.user;
                }
                const userData = this.retrieveFromContext('user');
                if (userData == null) {
                    return null;
                }
                const user = JSON.parse(userData);
                $rootScope.user = user;
                return user;
            },

            InModule: function (moduleArray) {
                if (moduleArray == null) {
                    return false;
                }
                var result = false;
                var currModule = this.currentModule();
                if (nullOrUndef(currModule)) {
                    return false;
                }
                $.each(moduleArray, function (key, value) {
                    if (value.equalIc(currModule)) {
                        result = true;
                        return;
                    }
                });
                return result;

            },

            //determines whether the current user has one of the roles specified on the array
            HasRole: function (roleArray) {
                if (roleArray == null) {
                    return true;
                }
                const user = this.getUserData();
                var userroles = user.roles;
                var result = false;
                $.each(roleArray, function (key, value) {
                    $.each(userroles, function (k, v) {
                        if (v.name == value) {
                            result = true;
                            return;
                        }
                    });
                });
                return result;
            },

            loadUserContext: function (userData) {
                //clear cache
                $rootScope.user = userData;
                this.insertIntoContext('user', JSON.stringify(userData));
                $rootScope.userContextDate = new Date();
            },

            loadConfigs: function (config) {
                this.insertIntoContext('clientName', config.clientName);
                this.insertIntoContext('environment', config.environment);
                this.insertIntoContext('isLocal', config.isLocal);
                this.insertIntoContext('i18NRequired', config.i18NRequired);
                this.insertIntoContext('systeminittime', config.initTimeMillis);
                this.insertIntoContext('successMessageTimeOut', config.successMessageTimeOut);
                if (!config.clientSideLogLevel.equalsAny('warn', 'debug', 'info', 'error', 'none')) {
                    //to avoid the change of server side setting it to invalid
                    //TODO: config should allow list of options
                    config.clientSideLogLevel = 'warn';
                }
                this.insertIntoContext('defaultlevel', config.clientSideLogLevel.toLowerCase());
                this.insertIntoContext('invbalancesListScanOrder', config.invbalancesListScanOrder);
                // Add additional scan config keys here
                this.insertIntoContext('newInvIssueDetailScanOrder', config.newInvIssueDetailScanOrder);
                this.insertIntoContext('invIssueListScanOrder', config.invIssueListScanOrder);
                this.insertIntoContext('physicalcountListScanOrder', config.physicalcountListScanOrder);
                this.insertIntoContext('physicaldeviationListScanOrder', config.physicaldeviationListScanOrder);
                this.insertIntoContext('matrectransTransfersListScanOrder', config.matrectransTransfersListScanOrder);
                this.insertIntoContext('reservedMaterialsListScanOrder', config.reservedMaterialsListScanOrder);
                this.insertIntoContext('invIssueListBeringScanOrder', config.invIssueListBeringScanOrder);
                this.insertIntoContext('newKeyISsueDetailScanOrder', config.newKeyIssueDetailScanOrder);

                this.insertIntoContext("activityStreamFlag", config.activityStreamFlag, true);
                this.insertIntoContext("crudSearchFlag", config.crudSearchFlag, true);
                this.insertIntoContext("UIShowClassicAdminMenu", config.uiShowClassicAdminMenu, true);
                this.insertIntoContext("UIShowToolbarLabels", config.uiShowToolbarLabels, true);
                this.insertIntoContext("isLocal", config.isLocal);

                let dateTimeFormat = config.displayableFormats.dateTimeFormat;

                if (!!dateTimeFormat && dateTimeFormat.indexOf("hh") !== -1 && dateTimeFormat.indexOf("a") === -1) {
                    dateTimeFormat += " a";
                }

                this.insertIntoContext('dateTimeFormat', dateTimeFormat);

                $rootScope.defaultEmail = config.defaultEmail;
                $rootScope.clientName = config.clientName;
                $rootScope.environment = config.environment;
                $rootScope.i18NRequired = config.i18NRequired;
            },

         

            getResourceUrl: function (path) {
                const baseURL = url(path);
                if (!this.isLocal()) {
                    const initTime = this.getFromContext("systeminittime");
                    if (baseURL.indexOf("?") == -1) {
                        return baseURL + "?" + initTime;
                    }
                    return baseURL + "&" + initTime;
                }
                return baseURL;
            },


            currentModule: function () {
                return this.retrieveFromContext('currentmodule');
            },

            clearContext: function () {
                const urlContext = url("");
                var i = sessionStorage.length;
                while (i--) {
                    const key = sessionStorage.key(i);
                    if (key.startsWith(urlContext + ':ctx_')) {
                        sessionStorage.removeItem(key);
                    }
                }
            },

            insertReportSearchDTO: function (reportSchemaId, searchDTO) {
                this.insertIntoContext('repSearchDTO_' + reportSchemaId, searchDTO);
            },

            retrieveReportSearchDTO: function (reportSchemaId) {
                return this.retrieveFromContext('repSearchDTO_' + reportSchemaId);
            },

            setActiveTab: function (tabId) {
                this.insertIntoContext('currenttab', tabId);
            },

            getActiveTab: function () {
                return this.fetchFromContext('currenttab');
            },
        }

    }]);

})(modules, angular);;
(function (angular,modules) {
    "use strict";
        
    modules.webcommons.service('tabsService', ["fieldService", "i18NService", function (fieldService, i18NService) {

    var buildTabObjectForPrint = function (datamap, tabSchema, schema) {
        const result = {};        

        result.items = [];
        result.items.push(datamap);
        result.schema = tabSchema;
        result.title = i18NService.getTabLabel(tabSchema, schema);

        return result;
    };

    const isTabSection = function(section) {
        return section.rendererParameters && section.rendererParameters["tabsection"] === "true";
    }

    return {

        hasCount: function (tab) {
            if (!tab) {
                return false;
            }

            return tab.type === "ApplicationCompositionDefinition" ||
                (tab.type === "ApplicationTabDefinition" && !!tab.countRelathionship);
        },

        getCompositionSchema: function (baseSchema, compositionKey, schemaId) {
            var schemas = this.nonInlineCompositionsDict(baseSchema);
            const thisSchema = schemas[compositionKey];
            schemas = thisSchema.schema.schemas;
            if (schemaId === "print") {
                if (schemas.print) {
                    return schemas.print;
                }
                return schemas.detail;
            }

            return schemas.list;
        },

        getCompositionIdName:  function (baseSchema, compositionKey, schemaId) {
            return this.getCompositionSchema(baseSchema, compositionKey, schemaId).idFieldName;
        },

        hasTabs: function (schema) {
            if (schema.hasTabs != undefined) {
                //cache
                return schema.hasTabs;
            }
            const length = this.tabsDisplayables(schema).length;
            schema.hasTabs = length > 0;
            return length;
        },

        tabsDisplayablesForPrinting: function (schema, datamap) {
            if (schema.tabsDisplayablesForPrinting != undefined) {
                //cache
                return schema.tabsDisplayablesForPrinting;
            }
            var resultList = [];
            const displayables = this.tabsDisplayables(schema);
            $.each(displayables, function (key, displayable) {
                const value = datamap[displayable.relationship];
                if (value != undefined && value.length > 0) {
                    resultList.push(displayable);
                }
            });
            schema.tabsDisplayablesForPrinting = resultList;
            return resultList;
        },

        filterTabs: function (displayables, includeSubTabs = false) {
            var resultList = [];
            angular.forEach(displayables, function (displayable) {
                if (fieldService.isTabOrComposition(displayable) && !displayable.isHidden) {
                    resultList.push(displayable);
                    if (includeSubTabs) {
                        // only add subtabs if includeSubTabs equals true
                        resultList = resultList.concat(this.tabsDisplayables(displayable, includeSubTabs));
                    }
                } else if (fieldService.isSection(displayable) && (!isTabSection(displayable) || includeSubTabs)) {
                    // only add subtabs if includeSubTabs equals true
                    resultList = resultList.concat(this.tabsDisplayables(displayable, includeSubTabs));
                }
            }, this);
            return resultList;
        },

        /**
         * 
         * @param {} container a DisplayableContainer, either a schema or a section or any other implementation
         * @returns {} 
         */
        tabsDisplayables: function (container, includeSubTabs = false) {
            if (!includeSubTabs && container.tabsDisplayables != undefined) {
                //cache
                return container.tabsDisplayables;
            }
            if (includeSubTabs && container.allTabsDisplayables != undefined) {
                //cache
                return container.allTabsDisplayables;
            }

            const resultList = this.filterTabs(container.displayables, includeSubTabs);

            if (!includeSubTabs) {
                container.tabsDisplayables = resultList;
            } else {
                container.allTabsDisplayables = resultList;
            }
            return resultList;
        },

        tabsPrintDisplayables: function (container) {
            return this.tabsDisplayables(container).filter(function(displayable) {
                return !displayable.isHidden && displayable.isPrintEnabled;
            });
        },

        nonInlineCompositionsDict: function (schema) {
            if (schema.nonInlineCompositionsDict != undefined) {
                //caching
                return schema.nonInlineCompositionsDict;
            }
            var resultDict = {};

            // all tabs, including subtabs
            const allTabs = this.tabsDisplayables(schema, true);
            allTabs.forEach(function(tab) {
                resultDict[tab.relationship] = tab;
            });

            schema.nonInlineCompositionsDict = resultDict;
            return resultDict;
        },

        /*
        * param notExpansible = array of compositions that we do not need to hit the server, since they are not expandable
        *
        *
        * Returns a string in the same format the server expects for expanding the compositions on the Composition.ExpandCompositions method
        *
        */
        buildCompositionsToExpand: function (compositionsToExpandObj, schema, datamap, schemaId, notExpansible) {
            var resultString = "";
            if (compositionsToExpandObj == null) {
                return "";
            }
            var self = this;
            $.each(compositionsToExpandObj, function (key, obj) {
                if (obj.value == false) {
                    return;
                }

                const displayable = fieldService.getDisplayableByKey(schema, key);

                if (fieldService.isTab(displayable)) {
                    notExpansible.push({ key: key, tabObject: buildTabObjectForPrint(datamap, displayable, schema) });
                    return;
                }

                const compositionData = datamap[key];

                if (compositionData == undefined) {
                    //this happens when the composition data has not been fetch yet,due to a lazy strategy
                    resultString += key + "=lazy,,,";
                    return;
                }

                //now, we are retrieving data for printing
                const currentSchema = self.getCompositionSchema(schema, key, obj.schema);
                if (currentSchema.properties.expansible != undefined && currentSchema.properties.expansible == "false") {
                    if (notExpansible != undefined && compositionData.length > 0) {
                        //only adding if thereÂ´s actual at least one element of this nonExpansible composition
                        notExpansible.push({ key: key, schema: currentSchema });
                    }
                    return;
                }

                const compositionIdField = self.getCompositionIdName(schema, key, schemaId);
                const compositionIdArray = [];

                for (let i = 0; i < compositionData.length; i++) {
                    const composition = compositionData[i];
                    compositionIdArray.push(composition[compositionIdField]);
                }
                if (compositionIdArray.length > 0) {
                    resultString += key + "=" + compositionIdArray.join(",") + ",,,";
                }
            });
            if (resultString != "") {
                resultString = resultString.substring(0, resultString.length - 3);
            }
            return resultString;
        },

        locatePrintSchema: function (baseSchema, compositionKey) {
            const schemas = nonInlineCompositionsDict(baseSchema);
            const thisSchema = schemas[compositionKey];
            return thisSchema.schema.schemas.print;
        },

        getTitle: function (baseSchema, compositionKey) {
            const schemas = nonInlineCompositionsDict(baseSchema);
            const thisSchema = schemas[compositionKey];
            return thisSchema.label;
        },

        hasTab: function(baseSchema, tabid) {
            const displayable = fieldService.getDisplayableByKey(baseSchema, tabid);
            if (!displayable) {
                return false;
            }
            return fieldService.isTabOrComposition(displayable);
        }

    };
}]);

})(angular,modules);;
(function (modules) {
    "use strict";
        
    modules.webcommons.service('i18NService', ["$rootScope", "contextService", function ($rootScope, contextService) {

    var verifyKeyInAllCatalogsButEn = function (key) {
        const catalogs = $rootScope['sw_i18ncatalogs'];
        var all = true;
        $.each(catalogs, function (language, catalog) {
            if (language == 'en') {
                return;
            }
            all = all && hasKey(key, catalog);
        });
        return all;
    }

    var hasKey = function (key, catalog) {
        var catalogValue = null;
        if (catalog != null) {
            catalogValue = JsonProperty(catalog, key);
        }
        return catalogValue != null;
    };

    var doGetValue = function (key, defaultValue, isMenu) {
        if (!nullOrUndef(contextService.retrieveFromContext('currentmodule')) && !isMenu) {
            return defaultValue;
        }
        const catalog = $rootScope['sw_currentcatalog'];
        var catalogValue = null;
        if (catalog != null) {
            catalogValue = JsonProperty(catalog, key);
        }
        if (catalogValue != null) {
            return catalogValue;
        }
        if (contextService.isLocal() && $rootScope.i18NRequired == true) {
            if (defaultValue == null) {
                return null;
            }

            if (sessionStorage['ignorei18n'] == undefined && !verifyKeyInAllCatalogsButEn(key)) {
                return "??" + defaultValue + "??";
            }
        }
        return defaultValue;
    };

    var valueConsideringSchemas = function (value, schema) {
        if (value == undefined) {
            return null;
        }

        if (typeof value == "string") {
            //single option goes here
            return value;
        }
        //but we can have multiple definitions, one for each schema...
        if (value.hasOwnProperty(schema.schemaId)) {
            return value[schema.schemaId];
        }
        //default declaration
        return value["_"];
    };

    //??
    function fillattr(fieldMetadata) {
        var attr;
        if (fieldMetadata.attribute == null && fieldMetadata.label != undefined) {
            attr = fieldMetadata.label.replace(":", "");
        } else {
            attr = fieldMetadata.attribute;
        }
        return attr;
    }

    return {

        getI18nLabel: function (fieldMetadata, schema) {
            if (fieldMetadata.type === "ApplicationCompositionDefinition" || fieldMetadata.type === "ApplicationSection") {
                const headerLabel = this.getI18nSectionHeaderLabel(fieldMetadata, fieldMetadata.header, schema);
                if (headerLabel != null && headerLabel !== "") {
                    return headerLabel;
                }
            }

            if (fieldMetadata.isHidden) {
                return "";
            }

            const applicationName = schema.applicationName;
            const attr = fillattr(fieldMetadata);
            var key = applicationName + "." + attr;
            if (fieldMetadata.type === "OptionField") {
                key += "._label";
            }
            const value = doGetValue(key, fieldMetadata.label);
            return valueConsideringSchemas(value, schema);
        },

        getI18nLabelTooltip: function (fieldMetadata, schema) {
            const applicationName = schema.applicationName;
            const attr = fillattr(fieldMetadata);
            var key = applicationName + "." + attr + "._tooltip";
            if (!hasKey(key, $rootScope['sw_currentcatalog'])) {
                //fallbacks to default label strategy
                key = applicationName + "." + attr;
                if (fieldMetadata.type == "OptionField") {
                    key += "._label";
                }
            }
            var defaultValue = fieldMetadata.toolTip;
            if (defaultValue == undefined) {
                defaultValue = fieldMetadata.label;
            }
        
            var value = doGetValue(key, defaultValue);

            //if the tooltip and label are the same, don't show tooltips
            if (value === fieldMetadata.label) {
                value = '';
            }

            return valueConsideringSchemas(value, schema);
        },

        getI18nOptionField: function (option, fieldMetadata, schema) {
            if (fieldMetadata.type != "OptionField" || fieldMetadata.providerAttribute != null) {
                //case thereÂ´s a providerattribute, 118N makes no sense
                return option.label;
            }
            const applicationName = schema.applicationName;
            const attr = fieldMetadata.attribute;
            const val = option.value == '' ? option.label : option.value;
            const key = applicationName + "." + attr + "." + val;
            const value = doGetValue(key, option.label);
            return valueConsideringSchemas(value, schema);
        },

        getI18nCommandLabel: function (command, schema) {
            const applicationName = schema.applicationName;
            const key = applicationName + "._commands." + command.id;
            const value = doGetValue(key, command.label);
            return valueConsideringSchemas(value, schema);
        },

        getI18nInputLabel: function (fieldMetadata, schema, avoidColon=false) {
            var label = this.getI18nLabel(fieldMetadata, schema);
            if (label === "" || label == null) {
                return "";
            }
            const lastChar = label.charAt(label.length - 1);
            if (lastChar === ":" || lastChar === "?" || fieldMetadata.type === 'ApplicationSection') {
                return label;
            }
            if (!avoidColon) {
                label = label + ':';    
            }
            return label;
        },

        getI18nMenuLabel: function (menuitem, tooltip) {
            if (nullOrUndef(menuitem.id)) {
                return tooltip ? menuitem.tooltip : menuitem.title;
            }
            var defaultValue = menuitem.title;
            var key = "_menu." + menuitem.id;
            if (tooltip) {
                key += "_tooltip";
                defaultValue = menuitem.tooltip;
            }
            return doGetValue(key, defaultValue, true);
        },
        getI18nMenuIcon: function (menuitem) {
            if (nullOrUndef(menuitem.id)) {
                return menuitem.icon;
            }
            const defaultValue = menuitem.icon;
            const key = "_menu." + menuitem.id + "_icon";
            return doGetValue(key, defaultValue, true);
        },

        getI18nPlaceholder: function (fieldMetadata) {
            const label = fieldMetadata.label;
            const lastChar = label.charAt(label.length - 1);
            if (lastChar != ":") {
                return label;
            }
            const placeholder = label.substr(0, label.length - 1);
            return placeholder
        },

        getI18nRecordLabel: function (schema, datamap) {
            if (datamap == null || schema == null) {
                return "";
            }
            const userIdFieldName = schema.userIdFieldName;
            const userId = datamap[userIdFieldName];
            if (schema.idDisplayable && userId != null) {
                return '{0} {1}'.format(schema.idDisplayable, userId);

                //TODO: evaluate returning the userId as fallback, unless a schema property is set to hide the id lable
                //if (userId != null) {
                //    if (schema.idDisplayable) {
                //        return '{0} {1}'.format(schema.idDisplayable, userId);
                //    }
                //    return ' ' + userId;
            }
            return "";
        },

        getI18nTitle: function (schema) {
            const applicationName = schema.applicationName;
            const key = applicationName + "._title." + schema.schemaId;
            return doGetValue(key, schema.title);
        },

        get18nValue: function (key, defaultValue, paramArray) {
            const isHeaderMenu = (key!=null && key.indexOf("_headermenu") > -1) ? true : false;
            const unformatted = doGetValue(key, defaultValue, isHeaderMenu);
            if (paramArray == undefined) {
                return unformatted;
            }
            const formatFn = unformatted.format;
            return formatFn.apply(unformatted, paramArray);
        },

        getI18nSectionHeaderLabel: function (section, header, schema) {
            if (header == undefined) {
                return "";
            }
            const applicationName = schema.applicationName;
            section = !nullOrUndef(section.id) ? section.id : section.relationship;
            const key = applicationName + "." + section + "._header";
            const value = doGetValue(key, header.label);
            return valueConsideringSchemas(value, schema);
        },

        getTabLabel: function (tab, schema) {
            const applicationName = tab.applicationName;
            const key = applicationName + "." + tab.id + "._title";
            const value = doGetValue(key, tab.label);
            return valueConsideringSchemas(value, schema);
        },

        getLookUpDescriptionLabel: function(fieldMetadata){
                
            if (fieldMetadata && fieldMetadata.rendererParameters && fieldMetadata.rendererParameters.columnlabel) {
                return fieldMetadata.rendererParameters.columnlabel.toUpperCase();
            }
            
            return this.get18nValue('general.description', 'Description', null);
            
        },
       
        load: function (jsonString, language) {
            const languages = JSON.parse(jsonString);
            var catalogs = {};
            $.each(languages, function (key, value) {
                catalogs[key] = value;
            });
            $rootScope['sw_i18ncatalogs'] = catalogs;
            this.changeCurrentLanguage(language);
        },

        getCurrentLanguage: function () {
            return $rootScope['sw_userlanguage'];
        },

        changeCurrentLanguage: function (language) {
            $rootScope['sw_userlanguage'] = language;
            const normalizedLanguage = language != null ? language.toLowerCase() : '';
            $rootScope['sw_currentcatalog'] = $rootScope['sw_i18ncatalogs'][normalizedLanguage];
            //broadcast language changed event to update filter label translations.
            $rootScope.$broadcast("sw_languageChanged", normalizedLanguage);
        }


    };

}]);

})(modules);;
(function (modules, angular) {
    "use strict";

    modules.webcommons.service('schemaService', ["$q", "fieldService", "expressionService", "schemaCacheService", "restService", function ($q, fieldService, expressionService, schemaCacheService, restService) {

        //#region private methods

        /// <summary>
        /// builds a cache of the grid qualified displayables to show on small grids
        /// </summary>
        /// <param name="schema"></param>
        function buildQualifierCache(schema) {
            schema.jscache = schema.jscache || {};
            if (schema.jscache.griddisplayables) {
                //already cached
                return;
            }
            schema.jscache.qualifiercache = {};
            const displayables = schema.displayables;
            for (let i = 0; i < displayables.length; i++) {
                const displayable = displayables[i];
                if (displayable.qualifier) {
                    schema.jscache.qualifiercache[displayable.qualifier] = displayable;
                }
            }
        };



        //#endregion


        /// <summary>
        /// 
        /// </summary>
        /// <param name="schemaKey">a string representing a full schema, with or without reference to the application</param>
        /// <returns type="">an object with the following properties
        /// app: the application name (could be null)
        /// schemaId: the schema Id (canÂ´t be null)
        /// mode: the mode of the schema(or null)
        /// 
        /// </returns>
        function parseAppAndSchema(schemaKey) {
            if (schemaKey == null) {
                return null;
            }
            const keys = schemaKey.split('.');
            if (keys.length == 1) {
                //in this case we are passing only the schemaId  
                return { app: null, schemaId: schemaKey, mode: null };
            }
            var mode = null;
            const application = keys[0];
            const schemaId = keys[1];
            if (keys.length == 3) {
                mode = keys[2];
            }
            return { app: application, schemaId: schemaId, mode: mode };
        };

        function getId(datamap, schema) {
            return datamap[schema.idFieldName];
        };

        function getUserId(datamap, schema) {
            return datamap[schema.userIdFieldName];
        };

        /**
         * Returns a jquery element (section) considering the path passed as parameter.
         * 
         * That is needed on circumstances in which you want to search for elements inside of a given section.For example:
         * 
         * You need to update the assets lookup element inside of a composition row
         * 
         * 
         * 
         * @param {} schema 
         * @param {} datamap
         * @param {} path 
         * @returns {} 
         */
        function locateJquerySectionElementByApp(schema, datamap, path) {

        }

        function allFieldsIncludingTabs(schema) {
            return flattenDisplayables(schema.displayables);
        }

        function nonTabFields(schema) {
            return flattenDisplayables(fieldService.nonTabFields(schema.displayables, true));
        };

        function nonTabFieldsFromDisplayables(displayables) {
            return flattenDisplayables(fieldService.nonTabFields(displayables, true));
        };

        function hasAnyFieldOnMainTab(schema) {
            if (!schema) {
                return false;
            }

            schema.jscache = schema.jscache || {};
            if (schema.jscache.hasAnyFieldOnMainTab) {
                return schema.jscache.hasAnyFieldOnMainTab;
            }
            const fields = fieldService.nonTabFields(schema.displayables, false);
            const result = fields.length > 0;
            schema.jscache.hasAnyFieldOnMainTab = result;
            return result;
        };

        function isPropertyTrue(schema, propertyName) {
            if (!schema) {
                return false;
            }
            return schema.properties && "true" == schema.properties[propertyName];
        };

        function getProperty(schema, propertyName) {
            if (!schema) {
                return false;
            }
            schema.properties = schema.properties || {};
            return schema.properties[propertyName];
        };

        function buildApplicationKey(schema) {
            var basekey = schema.applicationName + "." + schema.schemaId;
            if (schema.mode && schema.mode !== "none") {
                basekey += "." + schema.mode;
            }
            return basekey;
        };

        function buildApplicationMetadataSchemaKey(schema) {
            return {
                applicationName: schema.applicationName,
                schemaId: schema.schemaId,
                mode: schema.mode,
                platform: platform()
            }
        };

        function getTitle(schema, datamap, smallDevices) {
            if (!schema) {
                return null;
            }

            if (!datamap) {
                return "New " + schema.title;
            }
            const fields = datamap;
            if (schema.properties['detail.titleexpression'] != null) {
                return expressionService.evaluate(schema.properties['detail.titleexpression'], fields);
            }
            const titleId = schema.idDisplayable;
            if (titleId == null) {
                return schema.title;
            }
            var result;
            var idValue = fields[schema.userIdFieldName];
            if (!idValue) {

                idValue = "New " + schema.title;
            }
            if (smallDevices) {
                result = idValue;
            } else {
                result = titleId + " " + idValue;
            }

            return result;
        };

        function getSummary(schema, datamap, smallDevices) {
            if (!schema || !datamap) {
                return null;
            }
            const field = locateDisplayableByQualifier(schema, "summary");
            if (!field) {
                return datamap.description;
            }
            return datamap[field.attribute] || datamap.description;
        };

        function locateDisplayableByQualifier(schema, qualifier) {
            schema.jscache = schema.jscache || {};
            if (schema.jscache.qualifiercache) {
                //already cached
                return schema.jscache.qualifiercache[qualifier];
            }
            buildQualifierCache(schema);
            return schema.jscache.qualifiercache[qualifier];
        };

        function hasEditableProperty(schema) {
            if (schema.mode === "input") {
                return true;
            }
            schema.jscache = schema.jscache || {};
            if (schema.jscache.editable) {
                return schema.jscache.editable;
            }
            const editable = allDisplayables(schema).some(function (displayable) {
                return fieldService.isPropertyTrue(displayable, "editable");
            });
            schema.jscache.editable = editable;
            return editable;
        }

        /**
         * @param {} schema 
         * @param Array<String>|String values 
         * @param {} emptyAsTrue (optional: defaults to false) whether or not a null/undefined/empty/"None" stereotype should be considered as the one being evaluated
         * @returns Boolean whether or not the schema is any of the values stereotype
         */
        function isStereotype(schema, values, emptyAsTrue) {
            var stereotype = schema.stereotype;
            if (!stereotype || stereotype === "None") return emptyAsTrue || false;
            if (!angular.isArray(values)) return stereotype.contains(values);
            return values.some(function (value) {
                return stereotype.contains(value);
            });
        }

        /**
         * @param {} schema 
         * @param Boolean emptyAsTrue (optional: defaults to false) whether or not a null/undefined/empty/"None" stereotype should be considered as detail
         * @returns Boolean whether or not the schema is of detail stereotype
         */
        function isDetail(schema, emptyAsTrue) {
            return isStereotype(schema, ["detail", "Detail"], emptyAsTrue);
        }

        /**
         * @param {} schema 
         * @param Boolean emptyAsTrue (optional: defaults to false) whether or not a null/undefined/empty/"None" stereotype should be considered as list
         * @returns Boolean whether or not the schema is of list stereotype
         */
        function isList(schema, emptyAsTrue) {
            return isStereotype(schema, ["list", "List"], emptyAsTrue);
        }

        function areTheSame(schema1, schema2) {
            if (schema1 == null) {
                return schema2 == null;
            }

            else if (schema2 == null) {
                return false;
            }

            return this.buildApplicationKey(schema1) === this.buildApplicationKey(schema2);
        }

        /**
         * @param {} schemaA
         * @param {} schemaB
         * @returns Boolean whether or not the schemas have same applicationName and schemaId
         */
        function isSameSchema(schemaA, schemaB) {
            return schemaA.applicationName === schemaB.applicationName && schemaA.schemaId === schemaB.schemaId;
        }

        function flattenDisplayables(fields, context, datamap) {
            if (!fields) return [];
            context = context || [];
            fields.forEach(function (f) {
                if (fieldService.isNullInvisible(f, datamap)) {
                    return;
                }
                if (angular.isArray(f.displayables)) {
                    flattenDisplayables(f.displayables, context, datamap);
                } else {
                    context.push(f);
                }
            });
            return context;
        }

        /**
         * Returns all displayable fields in a single array i.e. expands all sections.
         * 
         * @param {} schema 
         * @returns Array<FieldMetadata> 
         */
        function allDisplayables(schema) {
            return flattenDisplayables(schema.displayables);
        }

        function allNonHiddenDisplayables(datamap, schema) {
            return flattenDisplayables(schema.displayables).filter(f => {
                return !fieldService.isFieldHidden(datamap, schema.applicationName, f);
            });
        }



        function getSchema(application, schemaId) {
            const cachedSchema = schemaCacheService.getCachedSchema(application, schemaId);
            if (cachedSchema) {
                return $q.when(cachedSchema);
            }

            const parameters = {
                applicationName: application,
                targetSchemaId: schemaId
            }
            const promise = restService.getPromise("Metadata", "GetSchemaDefinition", parameters);
            return promise.then(function (result) {
                schemaCacheService.addSchemaToCache(result.data);
                return result.data;
            });
        }

        return {
            areTheSame: areTheSame,
            allNonHiddenDisplayables,
            buildApplicationKey: buildApplicationKey,
            buildApplicationMetadataSchemaKey: buildApplicationMetadataSchemaKey,
            getId,
            getUserId,
            getProperty: getProperty,
            getSummary: getSummary,
            getTitle: getTitle,
            hasAnyFieldOnMainTab: hasAnyFieldOnMainTab,
            hasEditableProperty: hasEditableProperty,
            isPropertyTrue,
            locateDisplayableByQualifier: locateDisplayableByQualifier,
            locateJquerySectionElementByApp: locateJquerySectionElementByApp,
            allFieldsIncludingTabs: allFieldsIncludingTabs,
            nonTabFields: nonTabFields,
            nonTabFieldsFromDisplayables: nonTabFieldsFromDisplayables,
            parseAppAndSchema: parseAppAndSchema,
            isStereotype: isStereotype,
            isDetail: isDetail,
            isList: isList,
            isSameSchema: isSameSchema,
            allDisplayables: allDisplayables,
            flattenDisplayables: flattenDisplayables,
            getSchema
        };

    }]);

})(modules, angular);;
(function (angular, modules) {
    "use strict";

    modules.webcommons.service('fieldService', ["$injector", "$log", "$filter", "expressionService", "eventService", "userService", "formatService", function ($injector, $log, $filter, expressionService, eventService, userService, formatService) {


        var isFieldHidden = function (datamap, schema, fieldMetadata) {
            fieldMetadata.jscache = fieldMetadata.jscache || {};
            if (fieldMetadata.jscache.isHidden != undefined) {
                return fieldMetadata.jscache.isHidden;
            }
            const baseHidden = fieldMetadata.isHidden || (fieldMetadata.type != "ApplicationSection" && isIdFieldAndNotReadOnly(fieldMetadata, schema));
            const isTabComposition = fieldMetadata.type == "ApplicationCompositionDefinition" && !fieldMetadata.inline;
            if (baseHidden || isTabComposition) {
                fieldMetadata.jscache.isHidden = true;
                return true;
            } else if (fieldMetadata.type === "ApplicationSection" && fieldMetadata.resourcepath == null &&
                (fieldMetadata.displayables.length === 0
                    || $.grep(fieldMetadata.displayables, function (e) {
                        return !isFieldHidden(datamap, schema, e);
                    }).length === 0)) {

                const enableControlFlag = fieldMetadata.header != null &&
                    fieldMetadata.attribute !== null &&
                    fieldMetadata.header.parameters["enablecontrol"] === "true";

                return !enableControlFlag;
            }
            //the opposite of the expression: showexpression --> hidden
            const result = !expressionService.evaluate(fieldMetadata.showExpression, datamap);
            if (schema.stereotype == "List") {
                //list schemas can be safely cached since if the header is visible the rest would be as well
                fieldMetadata.jscache.isHidden = result;
            }
            return result;
        };

        var isIdField = function (fieldMetadata, schema) {
            return fieldMetadata.attribute == schema.idFieldName;
        };

        var isIdFieldAndNotReadOnly = function (fieldMetadata, schema) {
            if (!isIdField(fieldMetadata, schema) || fieldMetadata.showExpression === "!false") {
                return false;
            }
            return (schema.stereotype == "Detail" && schema.mode == "input" || schema.stereotype == "DetailNew") && !fieldMetadata.isReadOnly;
        }


        var parseBooleanValue = function (attrValue) {
            return attrValue == undefined || attrValue === "" ? true : attrValue.toLowerCase() === "true";
        }


        var api = {
            isFieldHidden: function (datamap, application, fieldMetadata) {
                if (fieldMetadata == null) {
                    return false;
                }
                return isFieldHidden(datamap, application, fieldMetadata);
            },

            getParameter: function (fieldMetadata, key) {
                return fieldMetadata.rendererParameters[key];
            },

            isFieldRequired: function (fieldMetadata, datamap) {
                if (fieldMetadata.type === "ApplicationSection" && fieldMetadata.parameters) {
                    return "true" === fieldMetadata.parameters["required"];
                }
                const requiredExpression = fieldMetadata.requiredExpression;
                if (requiredExpression != undefined) {
                    return expressionService.evaluate(requiredExpression, datamap);
                }
                return requiredExpression;
            },

            /**
             * 
             * @param {} datamap 
             * @param {} application 
             * @param {} fieldMetadata 
             * @param {} scope 
             * @param {} staticcheck if true, we should only consider this field readonly if it comes from the server as redaonly, i.e, leaving no chance for a dynamic expressionService evaluation
             * @returns {} 
             */
            isFieldReadOnly: function (datamap, application, fieldMetadata, scope, staticcheck = false) {
                //test the metadata read-only property
                const isReadOnly = fieldMetadata.isReadOnly;

                //check if field is diable via other means
                if (isReadOnly) {
                    return true;
                }
                if (fieldMetadata.enableExpression == null) {
                    return false;
                }

                return staticcheck ? false : !expressionService.evaluate(fieldMetadata.enableExpression, datamap, scope);



            },

            fieldHasValue: function (datamap, fieldMetadata) {
                //if the message field doesn't have a value
                if (fieldMetadata.attribute === 'message' && !!datamap.message && datamap.message === '\n                                    ') {
                    return false;
                }

                return !!datamap[fieldMetadata.attribute];
            },

            isPropertyTrue: function (field, propertyName) {
                if (!field) {
                    return false;
                }
                return field.rendererParameters && "true" == field.rendererParameters[propertyName];
            },

            nonTabFields: function (displayables, includeHiddens) {
                /// <summary>
                /// 
                /// </summary>
                /// <param name="displayables"></param>
                /// <param name="includeHiddens">whether hidden fields should be included or not</param>
                /// <returns type=""></returns>
                includeHiddens = includeHiddens == undefined ? true : includeHiddens;
                const result = [];
                for (let i = 0; i < displayables.length; i++) {
                    const displayable = displayables[i];
                    if (!this.isTabOrComposition(displayable)) {
                        if (includeHiddens || !displayable.isHidden) {
                            result.push(displayable);
                        }
                    }
                }
                return result;
            },

            fillDefaultValues: function (displayables, datamap, scope) {
                $.each(displayables, function (key, value) {
                    const target = value.attribute;
                    if (value.displayables && value.displayables.length > 0) {
                        //section
                        api.fillDefaultValues(value.displayables, datamap, scope);
                    }

                    //Only continues if datmap for the current attribute is null
                    if (target != undefined && datamap[target] == null) {
                        let expressionResult = null;
                        const displayable = displayables[key];
                        if (displayable.evalExpression != null) {
                            expressionResult = expressionService.evaluate(displayable.evalExpression, datamap, scope, displayable);
                            datamap[target] = expressionResult;
                        } else if (displayable.defaultExpression != null) {
                            expressionResult = expressionService.evaluate(displayable.defaultExpression, datamap, scope, displayable);
                            datamap[target] = expressionResult;
                        }
                        if (expressionResult == null && value.defaultValue != null) {
                            if (value.defaultValue == "@now") {
                                datamap[target] = formatService.format("@now", value, null);
                                //                            datamap[target] = $filter('date')(new Date(), dateFormat)
                            } else {
                                let parsedUserValue = userService.readProperty(value.defaultValue);
                                if (displayable.rendererType === "numericinput" && parsedUserValue) {
                                    parsedUserValue = parseInt(parsedUserValue);
                                }
                                if (displayable.rendererType === "checkbox" && parsedUserValue) {
                                    parsedUserValue = parseBooleanValue(parsedUserValue);
                                }
                                datamap[target] = parsedUserValue;
                            }
                        }
                    }
                });
                return datamap;
            },

            isAssociation: function (displayable) {
                const type = displayable.type;
                return type === "ApplicationAssociationDefinition";
            },

            isLazyAssociation: function (displayable) {
                return this.isAssociation && displayable.schema.isLazyLoaded;
            },

            isTabComposition: function (displayable) {
                const type = displayable.type;
                return type === "ApplicationCompositionDefinition" && !displayable.inline;
            },

            isSection: function (displayable) {
                const type = displayable.type;
                return type === "ApplicationSection";
            },

            isInlineComposition: function (displayable) {
                const type = displayable.type;
                return type === "ApplicationCompositionDefinition" && displayable.inline;
            },

            isListOnlyComposition: function (displayable) {
                const type = displayable.type;
                return type === "ApplicationCompositionDefinition" && displayable.schema.schemas.detail == null;
            },

            isTabOrComposition: function (displayable) {
                return this.isTab(displayable) || this.isTabComposition(displayable);
            },

            isTab: function (displayable) {
                if (displayable == null) {
                    return false;
                }
                const type = displayable.type;
                return type === "ApplicationTabDefinition";
            },

            getDisplayableByKey: function (schema, key) {
                schema.jscache = schema.jscache || {};
                schema.jscache.fieldsByKey = schema.jscache.fieldsByKey || {};
                if (schema.jscache.fieldsByKey[key] != undefined) {
                    return schema.jscache.fieldsByKey[key];
                }
                const displayables = schema.displayables;
                for (let i = 0; i < displayables.length; i++) {
                    const displayable = displayables[i];
                    if ((displayable.attribute && displayable.attribute === key) || (displayable.tabId && displayable.tabId === key) || (displayable.id && displayable.id === key)) {
                        schema.jscache.fieldsByKey[key] = displayable;
                        return displayable;
                    }
                    if (displayable.displayables != undefined) {
                        const innerDisplayables = this.getDisplayableByKey(displayable, key);
                        if (innerDisplayables != undefined
                            && ((innerDisplayables.attribute && innerDisplayables.attribute === key) || (innerDisplayables.tabId && innerDisplayables.tabId === key) || (innerDisplayables.id && innerDisplayables.id === key))) {
                            schema.jscache.fieldsByKey[key] = innerDisplayables;
                            return innerDisplayables;
                        }
                    }
                }
                return null;
            },

            getDisplayablesByAssociationKey: function (schema, associationKey) {
                schema.jscache = schema.jscache || {};
                const cacheEntry = schema.jscache.displayablesByAssociation = schema.jscache.displayablesByAssociation || {};
                if (cacheEntry[associationKey] != undefined) {
                    return cacheEntry[associationKey];
                }

                var result = [];
                var fn = this;
                $.each(schema.displayables, function (index, value) {
                    if (value.associationKey == associationKey) {
                        result.push(value);
                    } else if (value.displayables != undefined) {
                        const innerDisplayables = fn.getDisplayablesByAssociationKey(value, associationKey);
                        if (innerDisplayables != null) {
                            result = result.concat(innerDisplayables);
                        }
                    }
                });
                cacheEntry[associationKey] = result;
                return result;
            },

            countVisibleDisplayables: function (datamap, application, displayables) {
                var count = 0;
                for (let i = 0; i < displayables.length; i++) {
                    if (!this.isFieldHidden(datamap, application, displayables[i])) {
                        count++;
                    }
                }
                return count;
            },

            getVisibleDisplayables: function (datamap, schema) {
                const displayables = schema.displayables;
                const result = [];
                for (let i = 0; i < displayables.length; i++) {
                    if (!this.isFieldHidden(datamap, schema, displayables[i])) {
                        result.push(displayables[i]);
                    }
                }
                return result;
            },

            getDisplayableIndexByKey: function (schema, key) {
                const displayables = schema.displayables;
                for (let i = 0; i < displayables.length; i++) {
                    //is this the current field?
                    const fieldMetadata = displayables[i];
                    if (fieldMetadata.attribute && fieldMetadata.attribute === key) {
                        return i;
                    }
                }
                return -1;
            },

            replaceOrRemoveDisplayableByKey: function (displayableContainer, itemOrKey, newdisplayable) {
                /// <summary>
                /// Get the index for the supplied attribute key, skipping hidden fields.
                /// </summary>
                if (!displayableContainer) {
                    return false;
                }

                const displayables = displayableContainer.displayables;
                var idxToRemove = -1;
                const innerContainers = [];
                for (let i = 0; i < displayables.length; i++) {
                    const item = displayables[i];
                    if (!isString(itemOrKey) && item === itemOrKey) {
                        idxToRemove = i;
                        break;
                    }
                    else if (item.attribute === itemOrKey || item.target === itemOrKey || item.role === itemOrKey) {
                        idxToRemove = i;
                        break;
                    }
                    if (item.displayables) {
                        innerContainers.push(item);
                    }
                }

                if (idxToRemove !== -1) {
                    if (!newdisplayable) {
                        displayables.splice(idxToRemove, 1);
                    } else {
                        displayables[idxToRemove] = newdisplayable;
                    }

                    return true;
                }

                for (let i = 0; i < innerContainers.length; i++) {
                    const container = innerContainers[i];
                    const removed = this.replaceOrRemoveDisplayableByKey(container, itemOrKey, newdisplayable);
                    if (removed) {
                        return true;
                    }
                }
                return false;

            },


            locateFirstOuterVerticalSection: function (container, currentField) {
                const displayables = container.displayables;
                for (let i = 0; i < displayables.length; i++) {
                    const displayable = displayables[i];
                    if (displayable.displayables) {
                        const result = this.locateOuterSection(container, currentField);
                        if (!result) {
                            //field wasnÂ´t present at this given section
                            continue;
                        }

                        if (result.found) {
                            //just returning from inner call invocations what was already found
                            return result;
                        }

                        if (result.container.orientation !== "horizontal") {
                            //either a vertical section or the root schema found, returning it!
                            return { container: result.container, found: true, idx: result.idx };
                        }
                        //searching the parent of the given section
                        return this.locateFirstOuterVerticalSection(container, result.container);

                    }
                    if (displayable === currentField) {
                        return { container, idx: i, found: false };
                    }

                }
                //nothing was found
                return { container, idx: i, found: true };
            },


            locateCommonContainer: function (container, fields) {
                const results = new Set();
                let minIdx = 1000;

                for (let i = 0; i < fields.length; i++) {
                    const field = fields[i];
                    const outerContainerResult = this.locateOuterSection(container, field);
                    const outerContainer = outerContainerResult ? outerContainerResult.container : null;
                    minIdx = outerContainerResult.idx < minIdx ? outerContainerResult.idx : minIdx;
                    results.add(outerContainer);
                }
                const arr = Array.from(results);

                if (results.size === 1) {
                    const resultContainer = arr[0];
                    if (resultContainer === container) {
                        //schema was hit as the common container
                        return { container, idx: minIdx }
                    }

                    const idx = this.getVisibleDisplayableIdxByKey(container, resultContainer, false, true);
                    return { container: resultContainer, idx }
                }
                return this.locateCommonContainer(container, arr);

            },

            /**
             * Given a container (schema or section) and a field, returns the container that encloses the given field (either a section or the root schema itself)
             * @param {} container 
             * @param {} currentField 
             * @returns {} 
             */
            locateOuterSection: function (container, currentField) {
                if (currentField && currentField.schemaId) {
                    //no point in searching an outer section for a schema
                    return { container: currentField, idx: 0 };
                }

                const displayables = container.displayables;
                for (let i = 0; i < displayables.length; i++) {
                    const displayable = displayables[i];
                    if (displayable.displayables) {
                        const result = this.locateOuterSection(displayable, currentField);
                        if (result) {
                            if (result.fieldLoop === true) {
                                //the field was already found, and now we return the container itself
                                return { idx: result.idx, fieldLoop: false, container: displayable };
                            }
                            return result;
                        }
                    }
                    if (displayable === currentField) {
                        return { fieldLoop: true, idx: i, container };
                    }

                }
                //field not found on the given container
                return null;

            },

            injectServerTypesIntoDisplayables: function (container) {
                this.getLinearDisplayables(container, true, true, (displayable) => {
                    const type = `softwrench.sW4.Shared2.Metadata.Applications.Schema.${displayable.type}, softwrench.sw4.Shared2`;
                    const associationOptionType = `softwrench.sw4.Shared2.Data.Association.AssociationOption, softwrench.sw4.Shared2`;
                    //TODO: updgrade newtonsoft.json so that this is no longer needed
                    displayable["$type"] = type;
                    if (displayable.type === "TableDefinition") {
                        var partialFakeContainerDisplayablesResult = [];
                        displayable.rows.forEach(row => {
                            var partialFakeContainerDisplayables = [];
                            row.forEach(column => {
                                partialFakeContainerDisplayables.push(column);
                            });
                            var ob = { displayables: partialFakeContainerDisplayables };
                            this.injectServerTypesIntoDisplayables(ob);
                            partialFakeContainerDisplayablesResult.push(ob.displayables);
                        });
                        displayable.rows = partialFakeContainerDisplayablesResult;

                    }
                    if (displayable.type === "OptionField" && displayable.options) {
                        const injectedOptions = [];
                        displayable.options.forEach(o => {
                            o["$type"] = associationOptionType;
                            injectedOptions.push(Object.assign({ "$type": associationOptionType }, o));
                        });
                        displayable.options = injectedOptions;
                    }

                    return Object.assign({ "$type": type }, displayable);
                    //                    return displayable;
                });
            },

            getVisibleDisplayableIdxByKey: function (schema, attributeOrField, ignoreCache = false, includeSections = false) {
                /// <summary>
                /// Get the index for the supplied attribute key, skipping hidden fields.
                /// </summary>
                if (!schema) {
                    return -1;
                }
                schema.jscache = schema.jscache || {};
                const results = this.getLinearDisplayables(schema, ignoreCache, includeSections);
                for (let i = 0; i < results.length; i++) {
                    const result = results[i];
                    if (!isString(attributeOrField) && result === attributeOrField) {
                        return i;
                    }
                    else if (result.associationKey === attributeOrField || result.target === attributeOrField || result.attribute === attributeOrField && !result.isHidden) {
                        return i;
                    }
                }
                return -1;
            },

            sortBySchemaIdx: function (schema, fields) {
                const idxArray = [];
                fields.forEach(field => {
                    const idx = this.getVisibleDisplayableIdxByKey(schema, field);
                    idxArray.push({ idx, field });
                });

                idxArray.sort((a, b) => {
                    return a.idx - b.idx;
                });

                return idxArray.map(a => a.field);

            },



            getLinearDisplayables: function (container, ignoreCache = false, includeSections = false, lambdaFn = null) {
                /// <summary>
                /// gets a list of all the displayables of the current schema/section in a linear mode, excluding any sections/tabs themselves.
                /// </summary>
                /// <param name="container">either a schema or a section</param>
                /// <returns type=""></returns>
                container.jscache = container.jscache || {};
                if (container.jscache.alldisplayables && !ignoreCache && !lambdaFn) {
                    return container.jscache.alldisplayables;
                }
                const displayables = container.displayables;
                var result = [];
                for (let i = 0; i < displayables.length; i++) {
                    const displayable = displayables[i];
                    if (displayable.displayables) {
                        if (includeSections) {
                            if (lambdaFn) {
                                displayables[i] = lambdaFn(displayables[i]);
                            }
                            result.push(displayable);

                        }
                        //at this point displayable is a section, calling recursively
                        result = result.concat(this.getLinearDisplayables(displayable, ignoreCache, includeSections, lambdaFn));

                    } else {
                        if (lambdaFn) {
                            displayables[i] = lambdaFn(displayables[i]);
                        }
                        result.push(displayable);

                    }
                }
                container.jscache.alldisplayables = result;
                return result;
            },

            getNextVisibleDisplayableIdx: function (datamap, schema, key) {
                //all fields, regardless of sections
                const displayables = this.getLinearDisplayables(schema);
                const fieldIdx = this.getVisibleDisplayableIdxByKey(schema, key);
                if (fieldIdx == -1 || fieldIdx == displayables.length) {
                    //no such field, or last field
                    return -1;
                }

                for (let i = fieldIdx + 1; i < displayables.length; i++) {
                    //is this the current field?
                    const fieldMetadata = displayables[i];

                    // also verifies if the field is actualy displayed on screen
                    if ($('[data-field="' + fieldMetadata.attribute + '"]').is(":hidden")) {
                        continue;
                    }

                    //if the current field is found, get the next visible and editable field
                    if (!this.isFieldHidden(datamap, schema, fieldMetadata) && !this.isFieldReadOnly(datamap, schema, fieldMetadata)) {
                        $log.getInstance("fieldService#getNextVisibleDisplayable").debug('found', fieldMetadata.attribute, fieldMetadata);
                        return i;

                    }
                }
                return -1;
            },

            getRequiredDisplayables: function (schema) {
                const displayables = schema.displayables;
                const result = [];
                for (let i = 0; i < displayables.length; i++) {
                    if (displayables[i].required) {
                        result.push(displayables[i]);
                    }
                }
                return result;
            },

            getId: function (datamap, schema) {
                return datamap[schema.idFieldName];
            },

            getDisplayablesOfTypes: function (displayables, types) {
                var result = [];
                var fn = this;
                $.each(displayables, function (key, value) {
                    const type = value.type;
                    if ($.inArray(type, types) != -1) {
                        result.push(value);
                    }
                    if (value.displayables != undefined) {
                        const innerDisplayables = fn.getDisplayablesOfTypes(value.displayables, types);
                        result = result.concat(innerDisplayables);
                    }
                });

                return result;
            },

            getDisplayablesOfRendererTypes: function (displayables, types) {
                var result = [];
                var fn = this;
                $.each(displayables, function (key, value) {
                    const type = value.rendererType;
                    if ($.inArray(type, types) != -1) {
                        result.push(value);
                    }
                    if (value.displayables != undefined) {
                        result = result.concat(fn.getDisplayablesOfRendererTypes(value.displayables, types));
                    }
                });

                return result;

            },

            getFilterDisplayables: function (displayables) {
                var result = [];
                var fn = this;
                $.each(displayables, function (key, value) {
                    if (value.filter != null && value.filter.operation != null) {
                        result.push(value);
                    }
                    if (value.displayables != undefined) {
                        result = result.concat(fn.getFilterDisplayables(value.displayables));
                    }
                });

                return result;

            },

            ///return if a field which is not on screen (but is not a hidden instance), and whose value is null from the datamap, avoiding sending useless (and wrong) data
            isNullInvisible: function (displayable, datamap) {
                if (displayable.showExpression == undefined || displayable.showExpression == "true" || displayable.isHidden) {
                    return false;
                }
                return !expressionService.evaluate(displayable.showExpression, datamap);
            },

            onFieldChange: function (fieldMetadata, event) {
                $log.getInstance("sw4.fieldservice#onFieldChange").debug("Invoking before field change event");
                const result = eventService.beforechange(fieldMetadata, event);
                if (result === null) {
                    event.continue();
                    return;
                }

                //sometimes the event might be syncrhonous, returning either true of false
                if (result != undefined && result == false) {
                    event.interrupt();
                } else if (result != undefined && result == true) {
                    event.continue();
                }
            },

            postFieldChange: function (field, scope, oldValue, newValue) {
                const parameters = {
                    fields: scope.datamap,
                    target: field,
                    scope: scope,
                    oldValue: oldValue,
                    newValue: newValue
                };
                $log.get("sw4.fieldservice#postfieldchange", ["event", "field", "afterchange"]).debug("Invoking post field change event.");
                eventService.afterchange(field, parameters);
            },

            /// <summary>
            /// simple function to allow mocking of dates on unittests
            /// </summary>
            currentDate: function () {
                return new Date();
            },

            getQualifier: function (field, datamap) {
                const qualifier = field.qualifier;
                if (!qualifier || !qualifier.startsWith("expression=")) return qualifier;

                var expression = qualifier.replace("expression=", "");
                expression = replaceAll(expression, "\'", "\"");

                var expressionObject;
                try {
                    expressionObject = JSON.parse(expression);
                } catch (e) {
                    console.error("Invalid qualifier expression for field", field, ":", expression);
                    throw e;
                }
                const currentValue = datamap[field.attribute];

                // immediate lookup
                if (expressionObject.hasOwnProperty(currentValue)) {
                    return expressionObject[currentValue];
                }

                for (let key in expressionObject) {
                    if (!expressionObject.hasOwnProperty(key)) continue;
                    let attribute = key.match(/@.+/g);
                    if (!attribute) continue;

                    // number of '!' is even (or zero)
                    const affirmative = (key.match(/!/g) || []).length % 2 === 0;

                    // attribute name from expression (without @ and !)
                    // TODO: add support for expressions with boolean operators (===, >=, <=, etc)
                    attribute = attribute[0].replace("@", "");
                    attribute = replaceAll(attribute, "!", "");
                    let evaluated = datamap[attribute];
                    evaluated = [false, 0, undefined, null, "false"].indexOf(evaluated) >= 0 ? false : true;
                    const value = expressionObject[key];
                    if (affirmative && evaluated) {
                        return value;
                    } else if (!affirmative && !evaluated) {
                        return value;
                    }
                }

                return expressionObject["#default"];
            }
        };



        return api;

    }]);

})(angular, modules);
;
(function (angular, $) {
    "use strict";

    function passwordValidationService($log, $http, $injector) {
        //#region Utils
        class PasswordConfig {
            constructor() {
                this.min = 6;
                this.adjacent = 3;
                this.uppercase = true;
                this.lowercase = true;
                this.number = true;
                this.special = true;
                this.blacklist = [];
                this.login = true,
                this.placement = {
                    number: { first: false, last: false },
                    special: { first: false, last: false }
                }
            }
        }

        var config = {
            promise: null,
            'default': new PasswordConfig(),
            keys: {
                min: "/Global/Password/Min",
                adjacent: "/Global/Password/Adjacent",
                uppercase: "/Global/Password/Uppercase",
                lowercase: "/Global/Password/Lowercase",
                number: "/Global/Password/Number",
                special: "/Global/Password/Special",
                blacklist: "/Global/Password/BlackList",
                numberFirst: "/Global/Password/PlacementNumberFirst",
                numberLast: "/Global/Password/PlacementNumberLast",
                specialFirst: "/Global/Password/PlacementSpecialFirst",
                specialLast: "/Global/Password/PlacementSpecialLast",
                login: "/Global/Password/Login"
            }
        }

        var configurationService = null;

        function getConfigurationService() {
            return configurationService = (configurationService || $injector.get("configurationService"));
        }

        function formatConfig(configDictionary) {
            return {
                min: parseInt(configDictionary[config.keys.min]),
                adjacent: parseInt(configDictionary[config.keys.adjacent]),
                uppercase: "true".equalIc(configDictionary[config.keys.uppercase]),
                lowercase: "true".equalIc(configDictionary[config.keys.lowercase]),
                number: "true".equalIc(configDictionary[config.keys.number]),
                special: "true".equalIc(configDictionary[config.keys.special]),
                blacklist: window.isString(configDictionary[config.keys.blacklist]) ? configDictionary[config.keys.blacklist].split(",") : [],
                login: "true".equalIc(configDictionary[config.keys.login]),
                placement: {
                    number: {
                        first: "true".equalIc(configDictionary[config.keys.numberFirst]),
                        last: "true".equalIc(configDictionary[config.keys.numberLast])
                    },
                    special: {
                        first: "true".equalIc(configDictionary[config.keys.specialFirst]),
                        last: "true".equalIc(configDictionary[config.keys.specialLast])
                    }
                }
            }    
        }

        function fetchPasswordConfiguration() {
            const log = $log.get("passwordValidationService#fetchPasswordConfiguration", ["validation", "config", "password"]);

            const keys = Object.values(config.keys);
            const configurl = url("/api/generic/Configuration/GetConfigurations?") + $.param({ fullKeys: keys });

            config.promise = $http.get(configurl)
                .then(r => formatConfig(r.data))
                .catch(e => {
                    log.error("Error fetching password configuration\n", e, "\nusing default configuration");
                    return config.default;
                })
                .finally(() => config.promise = null);

            return config.promise;
        }

        function doValidatePassword(password, passwordConfig, extra) {
            password = password || "";
            extra = extra || {};
            const validations = [];
            if (angular.isNumber(passwordConfig.min) && passwordConfig.min > 0 && password.length < passwordConfig.min) {
                validations.push(`Lenght must greater than or equal to ${passwordConfig.min}`);
            }
            if (angular.isNumber(passwordConfig.adjacent) && passwordConfig.adjacent > 0) {
                // base regex: '(.)\1\1\1 ... +' (repeating \1 as much as you want to detect - 1 e.g. 
                // allows 3 -> want to detect 4 -> repeat 3 times i.e. always repeat passwordConfig.adjancent times)
                const adjancentregexp = new RegExp(`(.)${"\\1".repeat(passwordConfig.adjacent)}+`, "g");
                if (adjancentregexp.test(password)) {
                    validations.push(`Cannot have more than ${passwordConfig.adjacent} identical adjacent characters`);
                }
            }
            if (angular.isArray(passwordConfig.blacklist) && passwordConfig.blacklist.some(c => c === password)) {
                validations.push(`Password cannot be any of the following: ${passwordConfig.blacklist.join(", ")}`);
            }
            if (passwordConfig.uppercase && !/[A-Z]/.test(password)) {
                validations.push("Requires at least one uppercase letter");
            }
            if (passwordConfig.lowercase && !/[a-z]/.test(password)) {
                validations.push("Requires at least one lowercase letter");
            }
            const numberRegexp = /[0-9]/;
            if (passwordConfig.number && !numberRegexp.test(password)) {
                validations.push("Requires at least one number character");
            }
            const regularCharactersRegexp = /^[a-zA-Z0-9- ]*$/;
            if (passwordConfig.special && regularCharactersRegexp.test(password)) {
                validations.push("Requires at least one special character");
            }
            const username = extra.username;
            if (!passwordConfig.login && !!username && password.contains(username)) {
                validations.push("Cannot contain user's username");
            }

            if (!passwordConfig.placement) return validations;

            const firstCharacter = password.charAt(0);
            const lastCharacter = password.charAt(password.length - 1);
            if (!!passwordConfig.placement.number && !passwordConfig.placement.number.first && numberRegexp.test(firstCharacter)) {
                validations.push("First character cannot be a number");
            }
            if (!!passwordConfig.placement.number && !passwordConfig.placement.number.last && numberRegexp.test(lastCharacter)) {
                validations.push("Last character cannot be a number");
            }
            if (!!passwordConfig.placement.special && !passwordConfig.placement.special.first && !regularCharactersRegexp.test(firstCharacter)) {
                validations.push("First character cannot be a special character");
            }
            if (!!passwordConfig.placement.special && !passwordConfig.placement.special.last && !regularCharactersRegexp.test(lastCharacter)) {
                validations.push("Last character cannot be a special character");
            }

            return validations;
        }

        //#endregion

        //#region Public methods
        
       /**
        * Fetches configuration from the server.
        * Guarantees there's only one ongoing request at a time.
        * 
        * @returns {Promise<PasswordConfig>} 
        */
        function getPasswordConfigurationAsync() {
            return config.promise || fetchPasswordConfiguration();
        }

        /**
         * Get the configuration already available to the client.
         * 
         * @returns {PasswordConfig} 
         */
        function getPasswordConfiguration() {
            const configDict = {};
            Object.values(config.keys).forEach(key => configDict[key] = getConfigurationService().getConfigurationValue(key));
            const passwordConfig = formatConfig(configDict);
            return passwordConfig;
        }

        /**
         * Returns validation violation messages the password has 
         * (according to {@link #getPasswordConfiguration}).
         * 
         * @param {string} password 
         * @param {Object} extra
         * @returns {Array<string>} 
         */
        function validatePassword(password, extra) {
            const passwordConfig = this.getPasswordConfiguration();
            return doValidatePassword(password, passwordConfig, extra);
        }
        
        /**
         * Returns promise resolved with validation violation messages the password has 
         * (according to {@link #getPasswordConfigurationAsync}).
         * 
         * @param {String} password 
         * @param {Object} extra
         * @returns {Promise<Array<string>>} 
         */
        function validatePasswordAsync(password, extra) {
            return this.getPasswordConfigurationAsync().then(c => doValidatePassword(password, c, extra));
        }
        
        //#endregion

        //#region Service Instance
        const service = {
            validatePassword,
            validatePasswordAsync,
            getPasswordConfiguration,
            getPasswordConfigurationAsync
        };
        return service;
        //#endregion
    }

    //#region Service registration
    angular.module("webcommons_services").service("passwordValidationService", ["$log", "$http", "$injector", passwordValidationService]);
    //#endregion

})(angular, jQuery);;
(function (angular) {
    'use strict';

    angular.module('webcommons_services').service('validationService', ['$log','$q', 'i18NService', 'fieldService', '$rootScope', 'dispatcherService', 'expressionService', 'eventService', 'compositionCommons', 'schemaService', 'alertService', 'crudContextHolderService', "passwordValidationService", validationService]);

    function validationService($log,$q, i18NService, fieldService, $rootScope, dispatcherService, expressionService, eventService, compositionCommons, schemaService, alertService, crudContextHolderService, passwordValidationService) {

        /**
         * Similar to the validate method, but only returning the array of items, for custom handling
         * 
         * @param {Array<FieldMetadata>} displayables 
         * @param {Datamap} datamap 
         * @returns {Array<String>} 
         */
        function getInvalidLabels(displayables, datamap) {
            var validationArray = [];
            displayables.forEach(displayable => {
                var label = displayable.label;
                if (fieldService.isNullInvisible(displayable, datamap)) {
                    return;
                }
                var isRequired = !!displayable.requiredExpression ? expressionService.evaluate(displayable.requiredExpression, datamap) : false;
                if (isRequired && nullOrEmpty(datamap[displayable.attribute])) {
                    validationArray.push(label);
                }
                if (!!displayable.displayables) {
                    // validating section
                    const innerArray = this.validate(displayable.displayables, datamap);
                    validationArray = validationArray.concat(innerArray);
                }
            });

            return validationArray;
        };

        function getValidationPatternByType(validationType, customPattern, customFlags) {
            let regexPattern = '';
            switch (validationType) {
            case "number":
                regexPattern = new RegExp(/^\d+$/);
                break;

            case "phonenumber":
                regexPattern = new RegExp(/^\d+$/);
                break;

            case "email":
                regexPattern = new RegExp(/^(([^<>()\[\]\.,;:\s@\"]+(\.[^<>()\[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/, 'i');
                break;

            case "custom":
                    regexPattern = new RegExp(customPattern, customFlags);
                break;
            }

            return regexPattern;
        }

        function getValidationPattern(fieldMetadata) {
            return getValidationPatternByType(fieldMetadata.rendererParameters["valtype"], fieldMetadata.rendererParameters["valpattern"], fieldMetadata.rendererParameters["valflags"]);
        }

        function getValidationPatterString(fieldMetadata) {
            const validationType = fieldMetadata.rendererParameters["valtype"];
            switch (validationType) {
                case "number":
                    return "^\\d+$";
                case "phonenumber":
                    return "^\\d+$";

                case "email":
                    return "^(([^<>()\\[\\]\\.,;:\\s@\\\"]+(\\.[^<>()\\[\\]\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([^<>()[\\]\\.,;:\\s@\\\"]+\\.)+[^<>()[\\]\\.,;:\\s@\\\"]{2,})$";

                case "custom":
                    return fieldMetadata.rendererParameters["valpattern"] || "";
            }
            return "";
        }

        function validateInlineComposition(compositionDisplayable, mainDatamap) {
            if (!compositionDisplayable.schema.schemas) {
                return [];
            }
            const listSchema = compositionDisplayable.schema.schemas.list;
            if (!listSchema) {
                return [];
            }

            const rows = mainDatamap[compositionDisplayable.relationship];
            var result = [];
            if (!rows) {
                return result;
            }
            for (let i = 0; i < rows.length; i++) {
                const row = rows[i];
                const mergedDatamap = compositionCommons.buildMergedDatamap(row, mainDatamap);
                mergedDatamap["#rownum"] = i;
                result = result.concat(this.validate(listSchema, listSchema.displayables, mergedDatamap, null, true));
            }
            return result;
        }

        function validateCurrent(panelId) {
            const schema = crudContextHolderService.currentSchema(panelId);
            var datamap = crudContextHolderService.rootDataMap(panelId);
           
            return this.validate(schema, schema.displayables, datamap);
        }

        function validatePromise(schema,datamap,crudFormErrors) {
            if (schema == null || datamap == null) {
                return $q.when();
            }
            if (sessionStorage.mockclientvalidation === "true") {
                //ignoring validation due to presence of flag
                return $q.when();
            }

            const arr = this.validate(schema, schema.displayables, datamap,crudFormErrors);
            const deferred =$q.defer();
            if (arr.length > 0) {
                return $q.reject(arr);
            } 
            return $q.when();
            
        }

        function validate(schema, displayables, datamap, angularformerrors={}, innerValidation=false) {
            const log = $log.get("validationService#validate",["validation"]);

            if (!innerValidation) {
                $log.get("validationService#validate",["save"]).info(`init validation for schema ${schema.schemaId} of application ${schema.applicationName}`);
            }
            

            let validationArray = [];
            const allDisplayables = schemaService.flattenDisplayables(displayables, null, datamap);

            /**
             * Resolves a NgModel that has validation errors from a form's validation error array.
             * 
             * @param {Array<NgForm.$error>} validation errors from an NgForm 
             * @param {String} type type of the validation error e.g. "email", "password"
             * @param {String} name name of the form field 
             * @returns {NgModel} controller instance with validation error (null if it has no error).
             */
            const getNgModel = (errors, type, name) => {
                const typedError = errors[type];
                if (!typedError) return null;
                // in case it's an array of NgModel or an array of NgForm
                const error = /*[ngModel]*/ typedError.find(e => e.$name === name) || /*[ngForm]*/ typedError[0][name];
                return !error && angular.isArray(typedError) && !!typedError[0].$error // search did not match but has child forms
                    ? getNgModel(typedError[0].$error, type, name) // recursively search child forms
                    : error; // end of search
            };

            const isInvalidEmail = (errors, name) => {
                const error = getNgModel(errors, "email", name);
                return !!error && error.$invalid;
            };

            allDisplayables.forEach(displayable => {
                var label = displayable.label;
                log.debug("performing validation on field {0}".format(label));
                var isRequired = !!displayable.requiredExpression
                    ? expressionService.evaluate(displayable.requiredExpression, datamap)
                    : false;

                var defaultTitleValue = schema.title ? schema.title : schema.applicationName;
                var applicationName = i18NService.get18nValue(schema.applicationName + ".name", defaultTitleValue);

                if (displayable.rendererType === "email" && angularformerrors.email && isInvalidEmail(angularformerrors, displayable.attribute)) {
                    //TODO: make this a bit more generic
                    validationArray.push(i18NService.get18nValue("messagesection.validation.requiredExpression", "Invalid email at field {0} for {1}", [label, applicationName]));
                    return;
                }

                // validate password: if it is required or is not required but was filled any way
                if (displayable.rendererType === "password") {
                    const password = getNgModel(angularformerrors, "password", displayable.attribute);
                    if (!!password) {
                        const passwordValue = password.$viewValue;
                        const username = datamap[displayable.rendererParameters["usernameFieldName"]];
                        if (isRequired || !nullOrEmpty(passwordValue)) {
                            const passwordValidation = passwordValidationService.validatePassword(passwordValue, { username: username });
                            validationArray = validationArray.concat(passwordValidation.map(v => `<br><strong>${label}</strong>: ${v}`));
                        }
                    }
                }

                if (fieldService.isInlineComposition(displayable) || (fieldService.isListOnlyComposition(displayable) && schemaService.hasEditableProperty(displayable.schema.schemas.list))) {
                    validationArray = validationArray.concat(this.validateInlineComposition(displayable, datamap));
                }

                if (isRequired && nullOrEmpty(datamap[displayable.attribute])) {
                    if (!nullOrEmpty(datamap.docinfoid)) {
                        //Existing Attachment
                        return;
                    }
                    const qualifier = !!datamap["#rownum"] ? `(${datamap["#rownum"]})` : "";

                    if (displayable.rendererType === "upload" && nullOrEmpty(datamap.newattachment_path)) {
                        validationArray.push(i18NService.get18nValue("messagesection.validation.requiredExpression", "<strong>{0}{1}</strong> is required", [label, qualifier]));
                        return;
                    }

                    if (!label.equalIc("alias") && (label.endsWith("s") || label.endsWith("S"))) {
                        validationArray.push(i18NService.get18nValue("messagesection.validation.requiredExpression", "<strong>{0}{1}</strong> are required", [label, qualifier]));
                    } else {
                        validationArray.push(i18NService.get18nValue("messagesection.validation.requiredExpression", "<strong>{0}{1}</strong> is required", [label, qualifier]));
                    }
                }
            });

            if (innerValidation == undefined || !innerValidation) {
                const customErrorArray = eventService.beforesubmit_onvalidation(schema, datamap);
                if (customErrorArray != null && Array.isArray(customErrorArray)) {
                    validationArray = validationArray.concat(customErrorArray);
                }
                if (validationArray.length > 0) {
                    //TODO: replace ntification message with in-line error messages
                    alertService.notifymessage("error", validationArray.join(", "));

                    //TODO: scroll to the first error message
                    $("html, body").animate({ scrollTop: 0 }, "fast");
                }
            }
            return validationArray;
        };

        const service = {
            getInvalidLabels,
            validate,
            validateCurrent,
            validatePromise,
            validateInlineComposition,
            getValidationPattern,
            getValidationPatternByType,
            getValidationPatterString
        };

        return service;
    }

})(angular);;
(function (angular) {
    "use strict";

    angular.module('webcommons_services')
        .service('alertService', ["$rootScope", "$timeout", "i18NService", "notificationViewModel", "$log", "$q", alertService]);

    function alertService($rootScope, $timeout, i18NService, notificationViewModel, $log, $q) {
        /**
        * @param {string} msg
        * @param {string} applicationName
        * @param {string} applicationId
        */
        const confirm = function (msg, applicationName, applicationId) {
            var deferred = $q.defer();
            const defaultConfirmMsg = !applicationName ? "Are you sure you want to delete this?" : "Are you sure you want to delete {0} {1}?".format(applicationName, applicationId);
            const alertMessage = !msg ? i18NService.get18nValue('general.defaultcommands.delete.confirmmsg', defaultConfirmMsg, [applicationName, applicationId]) : msg;

            bootbox.setDefaults({ locale: i18NService.getCurrentLanguage() });
            bootbox.confirm({
                templates: {
                    header:
                        "<div class='modal-header'>" +
                            "<i class='fa fa-question-circle'></i>" +
                            "<h4 class='modal-title'></h4>" +
                            "</div>"
                },
                message: alertMessage,
                title: i18NService.get18nValue('general.defaultcommands._confirmationtitle', 'Confirm...'),
                className: 'smallmodal',
                callback: function (result) {
                    result ? deferred.resolve() : deferred.reject();
                }
            });

            return deferred.promise;
        };

        /**
        * @param {string} msg
        * @param {string} applicationName
        * @param {string} applicationId
        */
        const confirmCancel = function (msg, applicationName, applicationId) {
            var deferred = $q.defer();
            const defaultConfirmMsg = !applicationName ? "Are you sure you want to cancel this?" : "Are you sure you want to cancel {0} {1}?".format(applicationName, applicationId);
            const alertMessage = !msg ? i18NService.get18nValue('general.defaultcommands.delete.confirmmsg', defaultConfirmMsg, [applicationName, applicationId]) : msg;

            bootbox.setDefaults({ locale: i18NService.getCurrentLanguage() });
            bootbox.cancelDialog({
                templates: {
                    header:
                        "<div class='modal-header'>" +
                            "<i class='fa fa-question-circle'></i>" +
                            "<h4 class='modal-title'></h4>" +
                            "</div>"
                },
                message: alertMessage,
                title: i18NService.get18nValue('general.defaultcommands._confirmationtitle', 'Confirm...'),
                className: 'smallmodal',
                callback: function (result) {
                    result ? deferred.resolve() : deferred.reject();
                }
            });

            return deferred.promise;
        };

        /**
        * @param {string} msg
        */
        const alert = function (msg) {
            var deferred = $q.defer();

            bootbox.setDefaults({ locale: i18NService.getCurrentLanguage() });
            bootbox.alert({
                templates: {
                    header:
                        "<div class='modal-header'>" +
                            "<i class='fa fa-times-circle'></i>" +
                            "<h4 class='modal-title'></h4>" +
                            "</div>"
                },
                message: msg,
                title: i18NService.get18nValue('general.defaultcommands._alert', 'Sorry...'),
                className: 'smallmodal error',
                callback: function () {
                    deferred.resolve();
                }
            });
            return deferred.promise;
        };

        const notifymessage = function (type, body, title, exceptionType, exceptionOutline, exceptionStack) {
            notificationViewModel.createNotification(type, null, body, exceptionType, exceptionOutline, exceptionStack);
        };

        const success = (body) => {
            notificationViewModel.createNotification("success", null, body);
        };

        const buildException = function (data) {
            //process the innerException, if present
            var innerException;
            const limit = 3; // to avoid unwanted infinite recursion
            var i = 0;
            const prependMessage = data.prependMessage;

            while (data.hasOwnProperty('innerException') && i < limit) {
                innerException = data.innerException;
                data = data.innerException;
                i++;
            }

            if (innerException != null) {
                data = {};
                data.errorStack = innerException.stackTrace;
                data.errorMessage = innerException.message;
            }

            if (prependMessage) {
                data.errorMessage = prependMessage + ' --> ' + data.errorMessage;
            }

            //get the message data
            const message = data.errorMessage || data.exceptionMessage;
            const exception = {};
            exception.type = data.errorType || data.exceptionType;
            exception.outline = data.outlineInformation;
            exception.stack = data.errorStack || (data.fullStack || data.stackTrace);
            exception.message = message;
            return exception;
        };

        /// <summary>
        /// Use this method to convert an exception to an error notification with more info
        /// </summary>
        /// <param name="data" type="object">The exception infomation</param>
        /// <returns></returns>
        const notifyexception = function (data) {
            if (typeof (data) == 'undefined') {
                return;
            }
            //get the message data
            const exception = this.buildException(data);
            notificationViewModel.createNotification('error', null, exception.message, exception.type, exception.outline, exception.stack);
        };

        const notifyWarning = function (data) {
            if (typeof (data) == 'undefined' || !data.warningDto) {
                return;
            }
            //get the message data
            let message = "";
            //get the message data
            message += data.warningDto.warnMessage;
            const exception = this.buildException(data.warningDto);
            if (data.successMessage) {
                this.notifymessage('success', data.successMessage);
            }


            notificationViewModel.createNotification('warning', null, message, exception.type, exception.message, exception.stack);
        };

        const buildCenteredTemplate = function (msg) {
            return `<div style='text-align: center;vertical-align: middle;'>${msg}</div>`;
        }

        const service = {
            confirm,
            confirmCancel,
            buildException,
            alert,
            notifymessage,
            notifyexception,
            notifyWarning,
            success,
            buildCenteredTemplate
        };

        //display notification on JS error
        $(window).on('error', function (evt) {
            notificationViewModel.processJsError(evt);
        });

        return service;
    }
})(angular);
;
(function (angular) {
    "use strict";

    function formatService($filter, i18NService, dispatcherService, contextService) {
        //#region Utils

        var doFormatDate = function (value, dateFormat, forceConversion, contextService) {
            if (value == null) {
                return null;
            }

            if (angular.isString(value) && value.equalsAny("@now", "@currentdatetime", "@currentdate")) {
                return $filter('date')(new Date(), dateFormat);
            }

            try {
                return $filter('date')(value, dateFormat);
            } catch (e) {
                value = new Date(value);
                return $filter('date')(value, dateFormat);
            }
        };

        var descriptionDataHandler = function (value, column) {
            if (value == null) {
                return "";
            }
            try {
                var unformatteddate = value.split('Logged Date:')[1];
                if (!nullOrUndef(unformatteddate)) {
                    var unformatteddatenospaces = unformatteddate.replace(/ /g, '');
                    var dateFormat = column.rendererParameters['format'];
                    var formatteddate = doFormatDate(unformatteddatenospaces, dateFormat, false);
                    value = value.replace(unformatteddatenospaces, formatteddate);
                }
            } catch (e) {
                return value;
            }
            return value;
        };

        //#endregion

        //#region Public methods

        function format(value, field, datamap) {
            if (field == undefined || value == null) {
                return value;
            }

            if (field.rendererParameters['formatter'] != undefined) {
                //If the formatter starts with an @ symbol
                if (field.rendererParameters['formatter'].startsWith("@")) {
                    var formatter = field.rendererParameters['formatter'];
                    formatter = formatter.substring(1); //Removes the leading '@' symbol
                    var serviceCall = formatter.split('.');
                    var serviceName = serviceCall[0];
                    var serviceMethod = serviceCall[1];

                    var fn = dispatcherService.loadService(serviceName, serviceMethod);

                    var parameters = {
                        'value': value,
                        'column': field,
                        'datamap': datamap
                    };
                    return fn(parameters);
                }
                else if (field.rendererParameters['formatter'] === "lower") {
                    return value.toLowerCase().trim();
                }
                else if (field.rendererParameters['formatter'] === "upper") {
                    return value.toUpperCase().trim();
                }

            }

            var dateFormat;
            if ((field.rendererType && field.rendererType.equalsAny("datetime", 'date','time'))
                && (field.rendererParameters['formatter'] == null || field.rendererParameters['formatter'] === "datetime")) {
                if (value != null) {
                    dateFormat = field.rendererParameters['format'];
                    if (dateFormat == null) {
                        //TODO: make default client specific
                        dateFormat = contextService.retrieveFromContext('dateTimeFormat');;
                    }
                    return doFormatDate(value, dateFormat, false);
                }
            } else if (field.type === "ApplicationSection" && field.parameters['format']) {
                if (field.parameters['format'] != null && value != null) {
                    dateFormat = field.parameters['format'];
                    return doFormatDate(value, dateFormat, false);
                }
            } else if (field.rendererParameters != undefined && field.rendererParameters['formatter'] != null) {
                if (field.rendererParameters['formatter'] === 'numberToBoolean') {
                    value = value == 1 ? i18NService.get18nValue('general.yes', 'Yes') : i18NService.get18nValue('general.no', 'No');
                }

                if (field.rendererParameters['formatter'] === 'booltostring') {
                    value = (value === true || value === 1)? "true" : "false";
                }

                if (field.rendererParameters['formatter'] === 'stringtonumberbool') {
                    value = (value === "1" || value === "true") ? 1 : 0;
                }

                else if (field.rendererParameters['formatter'] === 'numberToAbs') {
                    if (!isNaN(value)) {
                        value = Math.abs(value);
                    }
                }
                else if ('doubleToTime'.equalsIc(field.rendererParameters['formatter'])) {
                    if (value == null) {
                        return "";
                    }
                    //Converting to hh:mm
                    var time = value.toString();
                    if (time.length > 0 && time.indexOf('.') === -1) {
                        if (time === "0") {
                            return "00 : 00";
                        }

                        return value + " : 00";
                    }
                    var hours = time.split('.')[0];
                    var tempMins = time.split('.')[1];
                    hours = parseInt(hours);
                    var mins = Math.round(Math.round(parseFloat(0 + '.' + tempMins) * 60 * 100) / 100);
                    return (hours < 10 ? "0" + hours : hours) + " : " + (mins < 10 ? "0" + mins : "" + mins);
                }
                else if (field.rendererParameters['formatter'] === 'doubleToTimeExt') {
                    if (value == null) {
                        return "";
                    }
                    // Convert hours to milliseconds
                    var milliseconds = value * 3600000;
                    var time = new Date(milliseconds);
                    var days = Math.floor(value / 24);
                    var hours = time.getUTCHours();
                    var mins = time.getUTCMinutes();
                    var secs = time.getUTCSeconds();

                    return (days < 10 ? "0" + days : days) + " : " + (hours < 10 ? "0" + hours : hours) + " : " + (mins < 10 ? "0" + mins : "" + mins) + " : " + (secs < 10 ? "0" + secs : "" + secs);
                }
                else if (field.rendererParameters['formatter'] == 'descriptionDataHandler') {
                    return descriptionDataHandler(value, field);
                }
                else if (field.rendererParameters['formatter'] == 'money') {
                    return $filter('currency')(value, '$', 2);
                }
            } else if (field.rendererParameters != undefined && field.rendererParameters['limit'] != null) {
                //format the word to only display the first n characters based on the limit 
                //once its formatted, also need to register a custom html but may not be here 
                if (typeof value != 'undefined') {
                    var val = value.toString();
                    var limit = field.rendererParameters['limit'];
                    var truncatedText = val.substring(0, field.rendererParameters['limit']);
                    if (val.length > limit) {
                        truncatedText += "...";
                    }
                    return truncatedText;
                }
            }

            return value;
        };


        function formatDate(value, dateFormat) {
            if (!dateFormat) {
                dateFormat = contextService.retrieveFromContext('dateTimeFormat');
            }
            return doFormatDate(value, dateFormat, true);
        };

        function adjustDateFormatForAngular(dateFormat, showTime) {
            if (!dateFormat) {
                var globalDateTimeFormat = contextService.retrieveFromContext('dateTimeFormat');
                //default ==> should be client specific
                return showTime ? globalDateTimeFormat : globalDateTimeFormat.replace('hh:mm', '');
            } else {
                return dateFormat.trim();
            }
        };


        function adjustDateFormatForPicker(dateFormat, showTime, showMinutes=true) {
            /// <summary>
            ///  Bootstrap picker uses mm for month, and ii for minutes.
            ///  Angular, however, uses MM for month and hh mm for minutes.
            /// </summary>
            /// <param name="dateFormat"></param>
            /// <param name="showTime"></param>
            /// <returns type=""></returns>
            if (!dateFormat) {
                dateFormat = contextService.retrieveFromContext('dateTimeFormat');
                dateFormat = dateFormat.replace('dd', 'DD');
                dateFormat = dateFormat.replace('yyyy', 'YYYY');
//                dateFormat = dateFormat.replace('hh', 'HH');
                //default ==> should be client specific
                if (!showTime) {
                    dateFormat = dateFormat.replace('HH:mm', '');
                    dateFormat =dateFormat.replace('hh:mm', '');
                    dateFormat =dateFormat.replace('a', '');
                   
                }
                if (!showMinutes) {
                    dateFormat = dateFormat.replace(':mm', ':00');
                }
                return dateFormat;
            } else {
                dateFormat = dateFormat.replace('dd', 'DD');
                dateFormat = dateFormat.replace('yyyy', 'YYYY');
                if (!showTime) {
                    //the format and the showtime flag are somehow conflitant, letÂ´s adjust the format
                    dateFormat = dateFormat.replace('HH:mm', '');
                    dateFormat = dateFormat.replace('hh:mm', '');
                    dateFormat =dateFormat.replace('a', '');
                }
                if (!showMinutes) {
                    dateFormat = dateFormat.replace(':mm', ':00');
                }
                return dateFormat.trim();
            }
        };

        function doContentStringConversion(datamap) {
            angular.forEach(datamap, function (value, index) {
                datamap[index] = value == null
                   ? null
                   : angular.isArray(value)
                       ? value
                       : value.toString();
            });

            return datamap;
        }

        function isChecked(content) {

            switch (typeof content) {
                case "boolean":
                    return content;
                case "number":
                    return content === 1;
                case "string":
                    return content.equalsIc("y") || content.equalsIc("yes") || content.equalsIc("true") || content.equalsIc("1");
            }

            return false;
        }

        //#endregion

        //#region Service Instance

        const service = {
            format,
            formatDate,
            adjustDateFormatForAngular,
            adjustDateFormatForPicker,
            doContentStringConversion,
            isChecked
        };

        return service;


        //#endregion
    }

    //#region Service registration

    angular.module("webcommons_services").service("formatService", ['$filter', 'i18NService', 'dispatcherService', 'contextService', formatService]);

    //#endregion

})(angular);;
(function (modules) {
    "use strict";

    modules.webcommons.service('eventService', ["$log", "$q", "dispatcherService", "crudContextHolderService", "expressionService", function ($log, $q, dispatcherService, crudContextHolderService, expressionService) {
        const loadEvent = function (schemaOrDisplayable, eventName) {
            if (!schemaOrDisplayable || schemaOrDisplayable.events === undefined) {
                return null;
            }
            return schemaOrDisplayable.events[eventName];
        }

        const logMsg = function (type, msg) {
            const prefix = type ? type + " - " : "";
            return prefix + msg;
        }

        const execute = function (event, eventParameters) {
            if (!event) {
                return null;
            }

            const type = event;
            const log = $log.getInstance("eventService#execute");

            const hasService = event.service && event.method;
            if (!hasService && !event.expression) {
                log.warn(logMsg(type, "the event has not service and method or expression."));
                return null;
            }

            if (hasService) {
                const fn = dispatcherService.loadService(event.service, event.method);
                if (!fn) {
                    log.warn(logMsg(type, `method ${event.method} from service ${event.service} not found.`));
                    return null;
                }
                log.debug(logMsg(type, `invoking method ${event.method} from service ${event.service}.`));
                const serviceParameters = Object.keys(eventParameters).map(key => eventParameters[key]);
                return fn.apply(null, serviceParameters);
            }

            var expression = event.expression;
            log.debug(logMsg(type, `evaluating the expression ${expression}.`));

            //constant evaluations
            if (expression === "true" || expression === true) {
                return true;
            }
            if (expression == null || expression === "false" || expression === false) {
                return false;
            }

            expression = expression.replace(/\$e/g, "eventParameters");

            try {
                return eval(expression);
            } catch (e) {
                log.error(e);
                return false;
            }
        }

        return {
            dispatch: function(eventName, holder, parameters) {
                const event = loadEvent(holder, eventName);
                if (!event) {
                    return null;
                }
                return execute(event, parameters);
            },
            onload: function (scope, schema, datamap, parameters) {
                const event = loadEvent(schema, "onload");
                if (!event) {
                    return;
                }
                parameters.tabid = parameters.tabid || crudContextHolderService.getActiveTab();
                parameters.applicationName = parameters.applicationName || crudContextHolderService.currentApplicationName();
                parameters.schemaId = parameters.schemaId || crudContextHolderService.currentSchema().schemaId;
                execute(event, { scope, schema, datamap, parameters });
            },
            onviewdetail: function (schema, parameters) {
                const event = loadEvent(schema, "onviewdetail");
                if (!event) {
                    return;
                }
                execute(event, { parameters });
            },
            beforesubmit_onvalidation: function (schema, datamap, parameters) {
                const event = loadEvent(schema, "beforesubmit.onvalidation");
                if (!event) {
                    return [];
                }
                return execute(event, { schema, datamap, parameters });
            },
            beforesubmit_prevalidation: function (schema, datamap, parameters) {
                const event = loadEvent(schema, "beforesubmit.prevalidation");
                if (!event) {
                    return null;
                }
                return execute(event, { schema, datamap, parameters });
            },
            beforesubmit_postvalidation: function (schema, datamap, parameters) {
                const event = loadEvent(schema, "beforesubmit.postvalidation");
                if (!event) {
                    return $q.when(null);
                }
                return $q.when(execute(event, { schema, datamap, parameters }));
            },
            onedit_validation: function (datamap, schema) {
                const event = loadEvent(schema, "onedit.validation");
                if (!event) {
                    return $q.when(null);
                }
                return execute(event, { datamap, schema });
            },
            onremoval_validation: function (datamap, schema) {
                const event = loadEvent(schema, "onremoval.validation");
                if (!event) {
                    return $q.when(null);
                }
                return execute(event, { datamap, schema });
            },
            providerloaded: function (displayable, providerLoadedParameters) {
                const event = loadEvent(displayable, "providerloaded");
                if (!event) {
                    return null;
                }
                return execute(event, { providerLoadedParameters });
            },
            afterchange: function (displayable, parameters = {}) {
                const event = loadEvent(displayable, "afterchange");
                if (!event) {
                    return null;
                }
                parameters.fieldMetadata = displayable;
                return execute(event, { parameters });
            },
            beforechange: function (displayable, event) {
                const metadataEvent = loadEvent(displayable, "beforechange");
                if (!metadataEvent) {
                    return true;
                }
                return execute(metadataEvent, { event });
            },
            onassociationsloaded: function (schema) {
                const metadataEvent = loadEvent(schema, "onassociationsloaded");
                if (!metadataEvent) {
                    return null;
                }
                return execute(metadataEvent, {});
            },
            onschemafullyloaded: function (schema) {
                const metadataEvent = loadEvent(schema, "onschemafullyloaded");
                if (!metadataEvent) {
                    return null;
                }
                return execute(metadataEvent, {});
            }
        };
    }]);
})(modules);;
(function (modules) {
    "use strict";

modules.rootCommons.service('restService', ["$http", "$log","$q", "contextService", function ($http, $log,$q, contextService) {

    const anonymousControllers = [
    "Signin",
    "FirstSolarEmail",
    "FirstSolarWpGenericEmail",
    "UmcRequestController",
    "SwgasRequestController",
    "UserSetup/DefinePassword",
    "UserSetup/DoSetPassword",
    "UserSetupWebApi/ForgotPassword",
    "UserSetupWebApi/SendActivationEmail",
    "UserSetupWebApi/NewUserRegistration",
    "FSDBackendController"

    ];

    return {

        
        validateAnonymous: function (controller, action) {
            if (anonymousControllers.some(a=> a === controller)) {
                return true;
            }
            if (anonymousControllers.some(a => a === (controller + "/" + action))) {
                return true;
            }
            return false;
        },

        getActionUrl: function (controller, action, parameters) {
            action = (action === undefined || action == null) ? 'get' : action;
            const params = parameters == null ? {} : parameters;
            let serverUrl = contextService.getFromContext("serverurl");
            if (params["_customurl"]) {
                serverUrl = params["_customurl"];
                delete params["_customurl"];
            }
            
            if (serverUrl) {
                return serverUrl + "/api/generic/" + controller + "/" + action + "?" + $.param(params, false);
            }
            return url("/api/generic/" + controller + "/" + action + "?" + $.param(params, false));
        },
        /**
         * Deprecated: use postPromise instead
         * @deprecated 
         */
        invokePost: function (controller, action, queryParameters, json, successCbk, failureCbk) {
            this.postPromise(controller, action, queryParameters, json)
                .then(function (response) {
                    if (successCbk != null) {
                        successCbk(response.data);
                    }
                })
                .catch(function (response) {
                    if (failureCbk != null) {
                        failureCbk(response.data);
                    }
                });
        },
        /**
         * Deprecated: use getPromise instead
         * @deprecated
         */
        invokeGet: function (controller, action, queryParameters, successCbk, failureCbk) {
            const url = this.getActionUrl(controller, action, queryParameters);
            const log = $log.getInstance("restService#invokeGet");
            log.info("invoking get on url {0}".format(url));
            const getPromise = this.getPromise(controller, action, queryParameters);
            getPromise
                .then(function (response) {
                    if (successCbk != null) {
                        successCbk(response.data);
                    }
                })
                .catch(function (response) {
                    if (failureCbk != null) {
                        failureCbk(response.data);
                    }
                });
        },

        /**
         * Sends a POST request to an ASP.NET Controller. 
         * 
         * @param String controller ASP.NET Controller name 
         * @param String action ASP.NET Controller's action method's name
         * @param Object queryParameters dictionary of parameters to be passed as query string
         * @param Object json request's payload
         * @param Object config request's config
         * 
         * @returns HttpPromise
         */
        postPromise: function (controller, action, queryParameters, json, config) {
            const url = this.getActionUrl(controller, action, queryParameters);
            const log = $log.getInstance("restService#invokePost",["post","network"]);
            if (contextService.get("anonymous", false, true) && !this.validateAnonymous(controller, action)) {
                log.warn("mocking call to {0}. consider filtering that request off the stack".format(url));
                return $q.reject();
            } else {
                log.info("invoking post on url {0}".format(url));
                return $http.post(url, json, config);
            }
        },

        post: function () {
            return this.postPromise.apply(this, arguments);
        },

        putPromise: function (controller, action, queryParameters, json, config) {
            const url = this.getActionUrl(controller, action, queryParameters);
            const log = $log.getInstance("restService#invokePut", ["put", "network"]);

            if (contextService.get("anonymous", false, true) && !this.validateAnonymous(controller, action)) {
                log.info("mocking call to {0} consider filtering that request off the stack".format(url));
                return $q.reject();
            } else {
                log.info("invoking put on url {0}".format(url));
                return $http.put(url, json, config);    
            }
        },

        put: function () {
            return this.putPromise.apply(this, arguments);
        },



        /**
         * Sends a GET request to an ASP.NET Controller. 
         * 
         * @param String controller ASP.NET Controller name 
         * @param String action ASP.NET Controller's action method's name
         * @param Object queryParameters dictionary of parameters to be passed as query string
         * @param Object config request's config
         * @returns HttpPromise
         */
        getPromise: function (controller, action, queryParameters, config) {
            const url = this.getActionUrl(controller, action, queryParameters);
            const log = $log.getInstance("restService#invokeGet");

            if (contextService.get("anonymous", false, true) && !this.validateAnonymous(controller, action)) {
                log.info("mocking call to {0} consider filtering that request off the stack".format(url));
                return $q.reject();
            } else {
                log.info("invoking get on url {0}".format(url));
                return $http.get(url, config);
            }
        },

        getPromiseNoDigest: function (controller, action, queryParameters, config = {}) {
             const url = this.getActionUrl(controller, action, queryParameters);
             const log = $log.getInstance("restService#invokeGet");
             log.info("invoking get on url {0}".format(url));
             return $http.get("nodigest:"+url, config);
        },

        get: function() {
            return this.getPromise.apply(this, arguments);
        }

    };

}]);

})(modules);
;
(function (modules) {
    "use strict";

modules.webcommons.service('expressionService', ["$rootScope", "$log", "contextService", "dispatcherService", function ($rootScope, $log, contextService, dispatcherService) {

    var preCompiledReplaceRegex = /(?:^|\W)@(\#*)([\w+\.]+)(?!\w)/g;

    var compiledDatamapRegex = /(\@\#?)(\w+(\.?\w?)*)/g;
    //var datamapRegexString = "(\@\#?)(\w+(\.?\w?)*)";

    var datamapRegexString = "(\@\#?)" +
  //                                Looks leading @ or @#
                                    "(\w+(\.?\w?)*)";
    //                                At least one word, followed by unlimited number of .word
    //    
    //                      Examples:      https://www.regex101.com/r/fB6kI9/24
    //                                @inventory_.item_.itemnum                  
    //                                @assetnum                                  
    //                                @#customfield   

    var compiledScopeRegex = /\$\.(\w+)?((\.\w+)|(\[.*?\]+)|(\(.*?\)))*/g;
    //var scopeRegexString = "\$\.(\w+)?((\.\w+)|(\[.*?\]+)|(\(.*?\)))*";

    var scopeRegexString = "\$\.(\w+)?" +

  //                               Looks for leading $. that could be followed by a word 
  //                               ($. will translate into scope.)

  //                               The following three conditions are OR'd together 
  //                               and can be repeated 0 or more times

                                    "(" +
                                                "(\.\w+)" + "|" +
  //                                Condition 1: Looks for .word

                                                "(\[.*?\]+)" + "|" +
  //                                Condition 2: Looks for an open bracket [ and will accept
  //                                any characters until the first closing bracket ] is found.
  //                                There can be multiple closing brackets back to back. This
  //                                is sort of a hackey way of supporting nested dictionaries

                                                "(\(.*?\))" +
  //                                Condition 3: Looks for an open parenthesis ( and will accept
  //                                any characters until the first closing parenthesis ) is found

                                    ")*";

    //                          Examples:     https://www.regex101.com/r/fB6kI9/25
    /*                       $.previousdata.fields['wonum'].list[@assetnum]
                             $.previousdata.fields[wonum].list[key]
                             $.previousdata.fields('CAT')
                             $.previousdata.fields(@#assetnum)
                             $.previousdata.fields(var)
                             $.previousdata.fields(var,'CAT',@assetnum)
                             $.previousdata.fields('CAT', var, @assetnum).list[@assetnum]
                             $.previousdata.fields(@assetnum, 'CAT', var).update(@currentVariable)
                             $.previousdata.fields(var)
                             $.previousdata['@wonum'].fields
                             $.previousdata.fields.test
                             $.previousdata.fields[@assetnum]
                             $.lookupAssociationCode[@#lookupCode]
                             $.currentfunction($.datamap[@assetnum])
                             $.scope.datamap[@assetnum]                  */


    var compiledServiceRegex = /fn\:\w+\.\w+(\(.*?\)((\s?\,\s?.*?)*\))*)((\.\w+)|(\[.*?\])|\)|(\(.*?\)((\s?\,\s?.*?)*\))*))*/g;
    //var serviceRegexString = "fn\:\w+\.\w+(\(.*?\)((\s?\,\s?.*?)*\))*)((\.\w+)|(\[.*?\])|\)|(\(.*?\)((\s?\,\s?.*?)*\))*))*";

    var serviceRegexString = "fn\:\w+\.\w+" +
  //                                Looks for leading fn:word.word (will translate into service.method call)

                                    "(\(.*?\)" + "((\s?\,\s?.*?)*\))*)" +
  //                                - Looks for an open parenthesis ( and will accept
  //                                  any characters until the first closing parenthesis ) is found
  //                                - Next, the above pattern could be followed with an unlimited number of
  //                                  commas that are followed by a word. Finally, this condition would expect
  //                                  a closed parenthesis. This part of the condition can occur 0 to unlimited number of times
  //                                  This case will allow for all variables nested within ( ) i.e. $.test($.test(), $.test())

  //                                The following four conditions are OR'd together 
  //                                and can be repeated 0 or more times

                                    "(" +

                                               "(\.\w+)" + "|" +
  //                                Condition 1: Looks for .word


                                               "(\[.*?\])" + "|" +
  //                                Condition 2: Looks for an open bracket [ and will accept
  //                                any characters until the first closing bracket ] is found.
  //                                This allows for you to call a function, and then refer to a 
  //                                key in its result. For example, 
  //                                     fn:contextService.getCurrentDatamap()[@assetnum]


                                               "\)" + "|" +
  //                                Condition 3: This OR with a close parenthesis ) will help when
  //                                capturing variables nested within parenthesis.

                                               "(\(.*?\)" + "(\s?\,\s?.*?\))*)" +
  //                                Condition 4:
  //                                - Looks for an open parenthesis ( and will accept
  //                                  any characters until the first closing parenthesis ) is found
  //                                - Next, the above pattern could be followed with an unlimited number of
  //                                  commas that are followed by a word. Finally, this condition would expect
  //                                  a closed parenthesis. This part of the condition can occur 0 to unlimited number of times
  //                                  This case will allow for identifying variables nested within ( ) i.e. $.test($.test(), $.test())

                                    ")*";

    /*            Examples:                 https://www.regex101.com/r/fB6kI9/21                
                    fn:customService.getTransformation(@assetnum) + fn:customService.getTransformation(@binnum)
                    fn:inventoryService.retrieveCost($.datamap[@assetnum], $.test(@assetnum), $.test()).parseDouble(fn:test.method(@assetnum))
                    fn:inventoryService.addition(@#refsiteid, fn:inventoryService.getint('test, test')) + fn:test.function()
                    fn:inventoryService.addition($.test(), fn:inventoryService.getint('test, test'))
                    fn:inventoryService.retrieveCost($.datamap[@assetnum]).parseDouble()
                    fn:inventoryService.retrieveCost($.datamap[@assetnum], $.test()).parseDouble()
                    fn:contextService.getCurrentDatamap()[@assetnum]                                    */


    function buildScopeVariables(variables, scopeVariables, datamap, onlyReturnRootNode, scope) {
        for (let i = 0; i < scopeVariables.length; i++) {
            const referenceVariable = scopeVariables[i]; //If the referenceVariable is simply $. (i.e. is not followed with a word)
            //replace with 'scope' instead of 'scope.'
            const scopeReplaceStr = referenceVariable.length == 2 ? 'scope' : 'scope.';
            var realVariable = referenceVariable.replace(/\$\./, scopeReplaceStr);

            //Remove white spaces from expression. This is needed when passing parameters to a function.
            realVariable = realVariable.replace(/\s/g, '');

            //Tests whether or not the realVariable has a subVariable within it
            const subVariable = compiledScopeRegex.test(realVariable) || compiledServiceRegex.test(realVariable);
            if (subVariable == true) {
                //Updates the realValue of current with the evaluation of its child nodes
                const subVariables = getVariables(realVariable, datamap, onlyReturnRootNode, scope); //For each sub variable, updated the real variable reference
                //(the variable's true reference upon being evaluated) and add
                // the variable sub variable to our current variables list.
                $.each(subVariables, function (key, value) {
                    //Updates the realValue of current with the evaluation of its child nodes
                    realVariable = realVariable.replace(key, eval(value));

                    //Deletes subVariable keys from resulting Dictionary if
                    //onlyReturnRootNode flag is true
                    if (variables[key] != undefined && onlyReturnRootNode == true) {
                        delete variables[key];
                    }
                });
            }

            variables[referenceVariable] = realVariable;
        }
    }


    function buildServiceVariables(variables, serviceVariables, datamap, onlyReturnRootNode, scope) {
        for (let i = 0; i < serviceVariables.length; i++) {
            var referenceVariable = serviceVariables[i];
            var realVariable = referenceVariable.replace(/fn\:/, '');

            //Remove white spaces from expression. This is needed when passing parameters to a function.
            realVariable = realVariable.replace(/\s/g, '');

            //Extracts all function signatures from the match
            var declaration = extractFnSignatureFromExpression(realVariable);

            //Tests whether or not the realVariable has a $. or fn: subVariable within it
            const subVariable = compiledScopeRegex.test(realVariable) || compiledServiceRegex.test(realVariable);
            if (subVariable == true) {
                const subVariables = getVariables(realVariable, datamap, onlyReturnRootNode, scope); //For each sub variable, updated the real variable reference
                //(the variable's true reference upon being evaluated) and add
                // the variable sub variable to our current variables list.
                $.each(subVariables, function (key, value) {
                    //Updates the realValue of current with the evaluation of its child nodes
                    realVariable = realVariable.replace(key, value);

                    //Updates the current declaration with evaluation of its child nodes.
                    //This will be used to identify/parse the parameters when injecting
                    //the custom service
                    declaration = declaration.replace(key, eval(value));

                    //Deletes subVariable keys from resulting Dictionary if
                    //onlyReturnRootNode flag is true
                    if (variables[key] != undefined && onlyReturnRootNode == true) {
                        delete variables[key];
                    }
                });
            }

            //Captures character up to the first open parenthises (
            const functionCallStr = realVariable.substring(0, realVariable.indexOf('('));
            const functionCall = functionCallStr.split('.');
            const service = functionCall[0];
            const method = functionCall[1]; //Regex to identify commas that are not within a nested string or parenthesis. This
            //will be used to extract the parameters from the custom service's function declaration
            const functionParameterRegex = new RegExp(/,(?=[^\)]*(?:\(|$))(?=(?:[^']*'[^']*')*[^']*$)/g);
            const parameters = declaration.split(functionParameterRegex); //Calls dispatcherService to load the custom service
            realVariable = dispatcherService.invokeService(service, method, parameters)
        }

        //Updates the variables Dictionary with the evaluated value
        variables[referenceVariable] = realVariable;
    }

    function buildDatamapVariables(variables, datamapVariables, datamap) {
        var datamapPath = 'datamap';
        for (let i = 0; i < datamapVariables.length; i++) {
            const referenceVariable = datamapVariables[i];
            let realVariable = referenceVariable.replace(/\@/, '');
            realVariable = datamapPath + "['" + realVariable + "']";
            variables[referenceVariable] = realVariable;
        }
    }

    //Extracts the first signature from an expression
    //fn:service.method(parameter1, parameter2).delete(parameter3)
    //will return 'parameter1,parameter2'
    function extractFnSignatureFromExpression(expression) {
        var parenCount = 1;
        //remove text prior to first variable in signature
        expression = expression.substring(expression.indexOf('(') + 1);
        var i = 0;
        for (i; i < expression.length && parenCount > 0; i++) {
            if (expression[i] == '(') {
                parenCount++;
            } else if (expression[i] == ')') {
                parenCount--;
            }
        }
        const signature = expression.substring(0, i - 1);
        return signature;
    }

    /*  Returns a dictionary containing variables that are identified within the expression.
        The dictionary key for the variable is the expression's original value, where the 
        dictionary value is the evaluated/"mapped" value.

        The onlyReturnRootNode would be set to true when trying to evaluate an expression.
        When the flag is false, the resulting list will have all variables, including nested
        variables.                                                                     */
    function getVariables(expression, datamap, onlyReturnRootNode, scope) {
        const variables = {};
        const scopeVariables = expression.match(compiledScopeRegex);
        if (scopeVariables != null) {
            buildScopeVariables(variables, scopeVariables, datamap, onlyReturnRootNode, scope);
        }
        const serviceVariables = expression.match(compiledServiceRegex);
        if (serviceVariables != null) {
            buildServiceVariables(variables, serviceVariables, datamap, onlyReturnRootNode, scope);
        }
        const datamapVariables = expression.match(compiledDatamapRegex);
        if (datamapVariables != null) {
            buildDatamapVariables(variables, datamapVariables, datamap);
        }

        return variables;
    }

    return {
        getDatamapRegex: function () {
            return new RegExp("/" + datamapRegexString + "/g");
        },

        getScopeRegex: function () {
            return new RegExp("/" + scopeRegexString) + "/g";
        },

        getServiceRegex: function () {
            return new RegExp("/" + serviceRegexString + "/g");
        },

        getExpression: function (expression, datamap, scope) {
            /*  The third parameter (boolean flag) will force the getVariables
                  method to evaluate sub variables and only return a mapping for
                  the root nodes. This means that nested variables will not have
                  their own key/value pair in the resulting dictionary          */
            const variables = getVariables(expression, datamap, true, scope); /*  Each dictionary key is used to quickly update an expression with its
                true value. We loop through each variable, replacing any instance of the
                key (original reference in metadata) with an expression we can evaluate   */
            if (variables != null) {
                $.each(variables, function (key, value) {
                    expression = expression.replace(new RegExp(key, 'g'), value);
                });
            }

            expression = expression.replace(/ctx:/g, 'contextService.');

            return expression;
        },

        getVariables: function (expression,datamap) {
            return getVariables(expression, datamap, false, scope);
        },

        getVariablesBeforeJordanFuckedUp: function (expression) {
            const variables = expression.match(preCompiledReplaceRegex);
            if (variables != null) {
                for (let i = 0; i < variables.length; i++) {
                    variables[i] = variables[i].replace(/[\@\(\)]/g, '').trim();
                }
            }
            return variables;
        },

        getVariablesForWatch: function (expression, placeholder) {
            /// <summary>
            ///  Returns an array of variables that we need to watch for changes.
            ///  The placeholder parameter will be prepended on each variable.
            /// 
            ///  EX: (@item != null &amp;&amp; @bin == '1' --> ['datamap.item','datamap.bin'])
            ///  
            /// </summary>
            /// <param name="expression"></param>
            /// <param name="placeholder">if blank, than datamap. will be used, but this might not be what the scope needs for binding the watch</param>
            /// <returns type="Array"></returns>
            placeholder = placeholder || "datamap.";
            const variables = this.getVariablesBeforeJordanFuckedUp(expression);
            if (variables == null) {
                return null;
            }

            var collWatch = '[';
            for (let i = 0; i < variables.length; i++) {
                collWatch += placeholder + variables[i];
                if (i != variables.length - 1) {
                    collWatch += ",";
                }
            }

            collWatch += ']';
            return collWatch;
        },



        evaluate: function (expression, datamap, scope, displayable) {
            const log = $log.getInstance('expressionService#evaluate');
            //constant evaluations

            if (expression === "true" || expression === true) {
                return true;
            }
            if (expression == null || expression === "false" || expression === false) {
                return false;
            }


            if (expression.startsWith('service:')) {
                // Trim service: from the expression
                const realServiceDefinition = expression.substr(8);
                const targetFunction = dispatcherService.loadServiceByString(realServiceDefinition); // If the service.function is not found
                const schema = scope ? scope.schema : null;
                return targetFunction(datamap, schema, displayable);
            }
            



            expression = expression.replace(/\$/g, 'scope');


            const expressionToEval = this.getExpression(expression, datamap || {}, scope);

            if (!datamap && expressionToEval.indexOf("datamap") >= 0) {
                //if the datamap is undefined and we have a expression relying on datamap, thereÂ´s no point to evaluate it
                //TODO: review
                return true;
            }

            try {
                return eval(expressionToEval);
            } catch (e) {
                if (contextService.isLocal()) {
                    log.error(e);
                }
                return true;
            }
        },


    };

}]);

})(modules);;
(function (modules) {
    "use strict";


    modules.webcommons.service('dispatcherService', ["$injector", "$log", "$q", "$rootScope", function ($injector, $log, $q, $rootScope) {
    var loadService = function(service, method) {
        const log = $log.getInstance('dispatcherService#loadService');

        if (service === undefined || method === undefined) {
            return null;
        }
        //see clientawareserviceprovider.js
        const dispatcher = $injector.getInstance(service);
        if (!dispatcher) {
            log.warn(`Service ${service} missing`);
            return null;
        }
        const fn = dispatcher[method];
        if (!fn) {
            log.warn(`Method ${method} not found on service ${service}`);
            return null;
        }
        return fn.bind(dispatcher);
    };
    return {

        loadServiceByString: function (serviceString) {
            if (!serviceString) {
                return null;
            }

            var serviceArray = serviceString.split(".");
            if (serviceArray.length !== 2) {
                throw new Error("wrong metadata configuration. service string should be 'servicexxx.methodxxx'".format(serviceString));
            }
            return this.loadService(serviceArray[0], serviceArray[1]);
        },

        loadService: function(service, method) {
            return loadService(service, method);
        },

        invokeService: function(service, method, parameters) {
            var fn = this.loadService(service, method, parameters);
            if (fn == null) {
                return null;
            }
            if (parameters != null) {
                var args = [];
                for (var i = 0; i < parameters.length; i++) {
                    args.push(parameters[i]);
                }
                return fn.apply(this, args);
            } else {
                return fn.apply(this);
            }
        },

        /**
         * 
         * @param {} serviceString an angular name in the form servicename.methodname
         * @param {} parameters an array of parameters to invoke
         * @returns {} 
         */
        invokeServiceByString: function (serviceString, parameters) {
            if (serviceString == null) {
                return null;
            }

            var serviceArray = serviceString.split(".");
            if (serviceArray.length != 2) {
                return null;
            }
            return this.invokeService(serviceArray[0], serviceArray[1], parameters);
        },



        /// <summary>
        /// use to create a default instance of the deferred/promise instance, useful for transforming sync methods into async ones, and for chaining them.
        /// 
        /// Add success/error methods on top of the promise, to make it more uniform along with other jquery/angular services (such as $http)
        /// 
        /// </summary>
        /// <returns type="">a deferred object</returns>
        loadBaseDeferred: function () {
            
            var deferred = $q.defer();
            var promise = deferred.promise;

            promise.success = function (fn) {
                promise.then(fn);
                return promise;
            }
            promise.error = function (fn) {
                promise.catch(fn);
                return promise;
            }
            return deferred;
        },

        dispatchevent: function (eventName) {
            $rootScope.$broadcast(eventName, Array.prototype.slice.call(arguments, 1));
        }
    };

}]);

})(modules);;
(function (angular) {
    "use strict";

    //TODO: crudContextHolderService should be somehow on a dependant module...
    try {
        angular.module('sw_scan', []);
    } catch (e) {
        //already defined
    }

    //#region Service registration

    angular.module("sw_scan").service("scanningCommonsService", ["$rootScope", "crudContextHolderService", "$q", scanningCommonsService]);

    //#endregion

    function scanningCommonsService($rootScope, crudContextHolderService, $q) {

        $rootScope.$on(JavascriptEventConstants.AppChanged, function () {
            $(document).scannerDetection(null);
        });

        //#region Utils

        var timeBetweenCharacters = isMobile() ? 300 : 14; // Used by the jQuery scanner detection plug in to differentiate scanned data and data input from the keyboard
        if ("true" === sessionStorage.debugscanner) {
            timeBetweenCharacters = 30000;
        }

        var scanCallbackMap = {

        };

        //#endregion

        //#region Public methods

        /**
         * Register the given callback function to be executed upon a successful scanning on a context that matches the matchingparameters.
         * To simulate a scan event in a debugging evironment just call <code>$(document).scannerDetection("<data_being_scanned>")</code>. 
         * Remember that in order to trigger your callbacks they need to have been previously registered and the event needs to be fired
         * in the correct context (defined by the matchingparamenters argument).
         * 
         * @param {Object} matchingparameters dictionary in the format:
         *              {
         *                  applicationName: String, // the name of the application to register the scan,
         *                  schemaId: String, //the schemaId to register the scan
         *                  tabId: String // the id of the tab to register the scan (composition or tab)
         *              }
         * @param {Function<?, String>} callback receives the scanned data as it's single argument 
         */
        function registerScanCallBackOnSchema(matchingparameters, callback) {
            const registerApplication = matchingparameters.applicationName;
            const registerSchemaId = matchingparameters.schemaId;
            const registerTabId = matchingparameters.tabid || "";

            const deferred = $q.defer();
            const promise = deferred.promise;


            scanCallbackMap[`${registerApplication}.${registerSchemaId}.${registerTabId}`] = callback || deferred;


            $(document).scannerDetection({
                avgTimeByChar: timeBetweenCharacters,

                onComplete: function (data) {
                    const tabId = crudContextHolderService.getActiveTab() || "";
                    const schema = crudContextHolderService.currentSchema();
                    const applicationName = crudContextHolderService.currentApplicationName();
                    if (!applicationName || !schema) {
                        //weÂ´re not on a crud screen, letÂ´s take the chance to unregister the scanner detector
                        //whenever it reaches the proper screen it can then register it self again
                        $(document).scannerDetection(null);
                        return;
                    }

                    if (!Array.isArray(schema)) {
                        //sometimes we could have multiple schemas at the same time on screen, such as a master-detail for compositions 
                        const callbackFn = scanCallbackMap[`${applicationName}.${schema.schemaId}.${tabId}`];
                        if (angular.isFunction(callbackFn)) {
                            callbackFn(data);
                        } else if (angular.isFunction(callbackFn.resolve)) {
                            deferred.resolve(data);
                        }else {
                            //no call back defined, letÂ´s take the chance to unregister the scanner detector
                            //whenever it reaches the proper screen it can then register it self again
                            $(document).scannerDetection(null);
                        }
                        return;
                    }
                    //TODO: is this scenario here really important?

                    //if we have multiple schemas on screen, invoke both functions unless they are the same
                    const callbackFn1 = scanCallbackMap[`${applicationName}.${schema[0].schemaId}.${tabId}`];
                    const callbackFn2 = scanCallbackMap[`${applicationName}.${schema[1].schemaId}.${tabId}`];
                    if (!angular.isFunction(callbackFn1) && !angular.isFunction(callbackFn2)) {
                        //no call back defined, letÂ´s take the chance to unregister the scanner detector
                        //whenever it reaches the proper screen it can then register it self again
                        $(document).scannerDetection(null);
                        return;
                    }

                    if (callbackFn1 === callbackFn2) {
                        callbackFn1(data);
                        return;
                    }
                    if (angular.isFunction(callbackFn1)) {
                        callbackFn1(data);
                    }
                    if (angular.isFunction(callbackFn2)) {
                        callbackFn2(data);
                    }

                }
            });

            return promise;


        };

        function getTimeBetweenChars() {
            return timeBetweenCharacters;
        }

        //#endregion

        //#region Service Instance
        const service = {
            registerScanCallBackOnSchema,
            getTimeBetweenChars
        };
        return service;
        //#endregion
    }

})(angular);
;
(function (angular) {
    'use strict';

    class userService {
        constructor (contextService) {
            this.contextService = contextService;
        }

        locatePrimaryEmail(compositionEmails) {

            if (!compositionEmails) {
                return null;
            }
            for (let i = 0; i < compositionEmails.length; i++) {
                const email = compositionEmails[i];
                if (email.isprimary) {
                    return email.emailaddress;
                }
            }
            return null;
        }

        readProperty(propertyExpression) {
            if (propertyExpression == null) {
                return null;
            }
            if (!propertyExpression.startsWith("@")) {
                return propertyExpression;
            }
            const user = this.contextService.getUserData();
            if (propertyExpression.startsWith("@user.")) {
                const propName = propertyExpression.substring(6);
                if (user.hasOwnProperty(propName)) {
                    return user[propName];
                }
                return user.genericproperties[propName];
            }
            else if (propertyExpression.equalsAny("@userid")) {
                return user.username;
            }
            else if (propertyExpression.equalsAny("@personid", "@username")) {
                return user.maximoPersonId == null ? user.username : user.maximoPersonId;
            }
            //TODO: finish this;
            return propertyExpression;

        }

        isSysAdmin() {
            return this.hasRole(["sysadmin"]);
        }

        getPersonId() {
            const user = this.contextService.getUserData();
            const personId = user.maximoPersonId;
            if (!personId && this.contextService.isLocal() && "swadmin".equalsIc(user.login)) {
                return "SWADMIN";
            }
            return personId;
        }

        hasRole(roleArray) {
            if (roleArray == null) {
                return true;
            }
            const user = this.contextService.getUserData();
            var userroles = user.roles;
            var result = false;
            $.each(roleArray, function (key, value) {
                $.each(userroles, function (k, v) {
                    if (v.name == value) {
                        result = true;
                        return;
                    }
                });
            });
            return result;
        }

        inGroup(groupName, useMaximoGroups=false) {
            if (groupName == null) {
                return true;
            }
            const user = this.contextService.getUserData();
            
            if (useMaximoGroups) {
                const personGroups = user.personGroups;
                if (!personGroups || personGroups.length === 0) {
                    //fallingback to generic property
                    const groupsFromProperty = user.genericproperties["persongroups"] || [];
                    return groupsFromProperty.some(s => s === groupName);
                }
                for (let i = 0; i < personGroups.length; i++) {
                    const userGroup = personGroups[i];
                    if (userGroup.personGroup.name === groupName) {
                        return true;
                    }
                }
                return false;
            } 
            return user.profiles && user.profiles.some(p => groupName.equalIc(p.name));
        }

        }

        userService.$inject = ["contextService"];

        angular.module('webcommons_services').service('userService', userService);
        })(angular);;
(function (angular) {
    "use strict";


    // service.$inject = [];
    class compositionCommons {
        
        constructor(datamapSanitizeService) {
            this.datamapSanitizeService = datamapSanitizeService;
        }


        buildInlineDefinition(definition) {
            //this means that we recevived only the list schema, for inline compositions
            definition.schemas = {
                list: definition.compositionschemadefinition
            };
            definition.inline = true;
            definition.collectionProperties = {
                allowInsertion: "false",
                allowUpdate: "false",
                autoCommit:false
            }
            return definition;
        }

        /**
       * merges the parent datamap with a specific composition row data, making sure that, 
       * in case of conflicts, the composition data is preseverved and not the parent one (ex: both have assets)
       * @param {} datamap 
       * @param {} parentdata 
       * @returns {} 
       */
        buildMergedDatamap (datamap, parentdata) {
            const toClone = parentdata;
            let clonedDataMap = angular.copy(toClone);
            clonedDataMap = this.datamapSanitizeService.sanitizeDataMapToSendOnAssociationFetching(clonedDataMap);

            if (datamap) {
                const item = datamap;
                for (let prop in item) {
                    if (item.hasOwnProperty(prop)) {
                        clonedDataMap[prop] = item[prop];
                    }
                }
            }
            return clonedDataMap;
        }
    }

    compositionCommons.$inject = ["datamapSanitizeService"];

    angular.module("webcommons_services").service("compositionCommons", ['datamapSanitizeService', compositionCommons]);


})(angular);
;
(function (angular) {
    "use strict";

    /**
     * Requires LZString for compression and decompression.
     * 
     * @returns {CompressionService} instance 
     */
    function compressionService() {
        //#region Utils
        const compressor = window.LZString;
        //#endregion

        //#region Public methods
        function compress(data) {
            return compressor.compressToUTF16(data);
        }

        function decompress(data) {
            return compressor.decompressFromUTF16(data);
        }
        //#endregion

        //#region Service Instance
        const service = {
            compress,
            decompress
        };
        return service;
        //#endregion
    }

    //#region Service registration
    angular.module("sw_rootcommons").service("compressionService", [compressionService]);
    //#endregion

})(angular);;
(function (angular) {
    "use strict";

    function localStorageService(compressionService) {

        //#region Utils
        function buildEntry(data, options) {
            const ttl = options && options.ttl ? options.ttl : null;
            const compress = options && options.compress ? options.compress : false;
            const entry = { data: data };
            if (!!ttl) {
                entry.expires = new Date().getTime() + ttl;
            }
            if (compress) {
                entry.compressed = true;
                entry.parse = !angular.isString(data);
                // data as a compressed string
                const dataString = entry.parse ? JSON.stringify(data) : data;
                entry.data = compressionService.compress(dataString);
            }
            return JSON.stringify(entry);
        }

        function validateParam(name, value) {
            if (value !== 0 && !value) throw new Error(`${name} cannot be null nor undefined`);
        };

        function doGet(key) {
            const now = new Date().getTime();
            const entryString = localStorage.getItem(key);
            // no entry found for key
            if (!entryString) return null;

            const entry = JSON.parse(entryString);
            const expires = entry["expires"];

            // entry expired it's ttl
            if (!!expires && expires <= now) {
                localStorage.removeItem(key);
                return null;
            }
            // entry still within it's ttl or no ttl stablished
            const raw = entry["data"];
            if (entry.compressed) {
                const decompressed = compressionService.decompress(raw);
                return !!entry.parse ? JSON.parse(decompressed) : decompressed;
            }
            return raw;
        };
        //#endregion

        //#region Public Methods

        /**
         * Puts key-data pair in the localStorage.
         * The entry can be configured with the options parameter.
         * See {@link localStorageService#get} to better understand the TTL feature.
         * 
         * @param String key 
         * @param {} data 
         * @param {} options dictionary of options: 
         *          {
         *              ttl: Number //entry's time-to-live in the cache in milliseconds, defaults to null (infinite TTL)
         *              compress: Boolean // indicates whether or not the data should be compressed, defaults to false (don't compress)
         *          } 
         */
        function put(key, data, options) {
            validateParam("key", key);
            validateParam("data", data);
            const entry = buildEntry(data, options);
            localStorage.setItem(key, entry);
        };

        /**
         * Fetches the data of the entry with the corresponding key.
         * If the entry's TTL is expired will return null instead.
         * 
         * @param String key
         * @returns {} data set by {@link localStorageService#put} 
         */
        function get(key) {
            validateParam("key", key);
            return doGet(key);
        };

        /**
         * Removes entry with the corresponding key and return it's data.
         * If the entry's TTL is expired will return null instead.
         * 
         * @param String key
         * @returns {} data that was removed
         */
        function remove(key) {
            validateParam("key", key);
            const data = doGet(key);
            localStorage.removeItem(key);
            return data;
        };
        //#endregion

        //#region Service Instance
        const service = {
            put,
            get,
            remove
        };
        return service;
        //#endregion
    }

    //#region Service registration
    angular.module("sw_rootcommons").service("localStorageService", ["compressionService", localStorageService]);
    //#endregion

})(angular);
;

(function (angular) {
    "use strict";

    let customServiceName, customServiceCodeKeyName;

    /**
     * Manages the logic for custom angular services.
     * 
     * The codes are lazy loaded into angular context, hereÂ´s how it works in a glance
     * 
     * 
     * Upon each new login hits the server to fetch any script updates (on the offline, upon the sync)
     * 
     * These scripts are then stored into 2 main localstorage regions:
     * 
     *  1) to hold the script names, uncompressed
     *  2) another to hold each of the scripts code (one region each)
     * 
     * The codes and names are then stored, and upon the next refresh, when this class is reconstructed, the _loadedServices memory variable will be updated with the latest script names.
     * 
     * Note that, the real code will only get registered into angular container when itÂ´s asked for execution, i.e, upon injector.get called
     * 
     */
    class dynamicScriptsCacheService {

        constructor($rootScope,$q,$log,localStorageService,$injector, contextService) {
            this.localStorageService = localStorageService;
            this.$injector = $injector;
            //DO not inject this one, to reduce number of dependencies. Check clientawareserviceprovider.js
//            this.restService = restService;
            this.initEntriesFromLocalStorage();
            this.$q = $q;
            this.$rootScope = $rootScope;
            this.$log = $log;
            this.contextService = contextService;

            //#region private fns

            /**
             * Name of the custom service for the injector
             */
            customServiceName = (service) => {
                return "$sw:custom_" + service;
            }

            /**
             * Name of the code entry for the localstorage
             */
            customServiceCodeKeyName = (service) => {
                return "sw:customservice_" + service;
            }


            //#endregion
            
        }

        useCustomServiceIfPresent(serviceName) {
            const log = this.$log.get("dynamicScriptsCacheService#useCustomServiceIfPresent", ["dynscripts", "angular", "services"]);
            log.trace(`checking custom service + ${serviceName}`);

            const loadedService = this._loadedServices[serviceName];
            if (!!loadedService) {
                const serviceNameToCheck = loadedService.custom ? customServiceName(serviceName) : serviceName;
                if (this.$injector.has(serviceNameToCheck)) {
                    log.debug(`returning custom service + ${serviceName}`);
                    return this.$injector.get(serviceNameToCheck);
                }
                const code = this.localStorageService.get(customServiceCodeKeyName(serviceName));
                var script = this.registerScript(serviceNameToCheck, code);
                if (!script) {
                    //fallback to default implementation
                    return null;
                }
                log.debug(`returning custom service + ${serviceName}`);
                return this.$injector.get(serviceNameToCheck);
            }
            return null;
        }

        /**
         * Used also by the offline codebase
         * @returns {} 
         */
        getClientState() {
            const clientState = {};
            Object.keys(this._loadedServices).forEach(k => {
                clientState[k] = this._loadedServices[k].rowstamp;
            });
            return clientState;
        }

        /**
         * Method to be called once, after login authentication, to update the client side customscripts localstorage and inmemory structures
         * 
         * Note that thereÂ´s no easy way to unregister a service, so we shall rely on a browser refresh in order to have the services reloaded correctly
         * 
         * @param {} serverSideData 
         * @returns {} 
         */
        syncWithServerSideScripts(serverSideData = null) {
            const log = this.$log.get("dynamicScriptsCacheService#syncWithServerSideScripts", ["dynscripts","angular", "services"]);
            const contextService = this.contextService;
            //            const clientState = { "items": _loadedServices };
            const clientState = this.getClientState();
            if (!this.restService) {
                //Do not inject rest service as it would broad the dependency graph due to the presence of the ajax_interceptor class, making less important services candidates for replacement.
                this.restService = this.$injector.get("restService");
            }

            let promise;
            if (serverSideData) {
                //we already have the data resolved, no need to fetch it
                promise = this.$q.when({ data: serverSideData });
            } else {
                promise = this.restService.postPromise("Scripts", "BuildSyncMap", null,clientState );
            }
            //maps to ScriptSyncResultDTO    
        
            return promise.then(response => {
                    
                const items = response.data;
                var hasUpdate = items.length > 0;
             
                if (hasUpdate) {

                    items.forEach(script => {
                        if (script.toDelete) {
                            delete this._loadedServices[script.target];
                            this.localStorageService.remove("sw:customservice_" + script.target);
                        } else {
                            let loadedService = this._loadedServices[script.target];
                            if (!loadedService) {
                                this._loadedServices[script.target] = {};
                                loadedService = this._loadedServices[script.target];
                            }
                            loadedService.rowstamp = script.rowstamp;
                            loadedService.custom = this.$injector.has(script.target);
                            log.info("updating script cache for (refresh requested)" + script.target);
                            this.localStorageService.put(customServiceCodeKeyName(script.target), script.code, { compress: true });
                        }
                    });

                    this.localStorageService.put("sw:customservicesentries", this._loadedServices);
                    //true updates will only be applied upon next browser refresh, so forcing it, especially for offline scenarios
                    if (!!window.restartApplication) {
                        //notify a restart to be called by the end of the whole chain for the offline application
                        contextService.set("restartneeded", true);
                    } else {
                        //reload automatically on the online solution
                        window.location.reload(true);    
                    }
                    
                }
            });
        }

        


            registerScript($provide, scriptName,serviceClassBody) {
                const log = this.$log.get("dynamicScriptsCacheService#register", ["dynscripts","angular", "services"]);
                let evaluatedClass;
                try {
                    evaluatedClass = eval(serviceClassBody);
                } catch (err) {
                    evaluatedClass = null;
                }
                if (!evaluatedClass) {
                    log.warn(`error evaluating class for script ${scriptName}`);
                    return null;
                }

                const scriptInjections  = angular.injector.$$annotate(evaluatedClass);
                if (!!scriptInjections) {
                    evaluatedClass["$inject"] = scriptInjections;
                }

                log.warn(`registering script ${scriptName}`);

                return $provide.service(scriptName, evaluatedClass);
            }

            /**
             * Builds the cache of custom services that are present on the instance from the localstorage
             * 
             * Note that the actual script is evaluated lazily, at his first utilization, due to a performance hit it would imply on a Browser Refresh to uncompress potentially large javascript files.
             * 
             * Also, this is structure is yet to be merged with the server upon login to sync eventually out of date scripts
             * 
             * The main structure consists of the following object (name,rowstamp dict)
             * 
             * {
              * xxx: {
                     rowstamp:1231413141341
                     custom: true
                }
                yyy:{
                    rowstamp:1231413141344
                    custom:false
                }
               }
             */
            initEntriesFromLocalStorage() {
                const entries = this.localStorageService.get("sw:customservicesentries") || {};
                this._loadedServices = entries;
            }

            clearEntries() {
                this.localStorageService.remove("sw:customservicesentries");
                const hadKeys = this._loadedServices.length > 0;
                Object.keys(this._loadedServices).forEach(k => {
                    var name = customServiceCodeKeyName(k);
                    this.localStorageService.remove(name);
                });
                this._loadedServices = {};
                if (hadKeys) {
                    if (!!window.restartApplication) {
                        window.restartApplication();
                    }

                    window.location.reload(true);
                }
            }

     

        }

        dynamicScriptsCacheService["$inject"] = ["$rootScope","$q","$log","localStorageService", "$injector","contextService"];

        angular.module("sw_rootcommons").service("dynamicScriptsCacheService", dynamicScriptsCacheService);

        })(angular);;
(function (angular) {
    "use strict";

    function schemaCacheService($log, $q, $injector, contextService, localStorageService) {
        //#region Utils
        // schema's first-level cache
        var schemaCache = {};
        var restService = null;

        var keyRoot = url("") + ":schemaCache:";
        var systemInitTimeKey = keyRoot + "systeminitMillis";

        function restore() {
            delete localStorage[url("") + ":schemaCache"]; // deleting 'deprecated' cache model


            //wipe first-level cache
            schemaCache = {};
            // lazy schema fetch strategy: only restore the systeminitmillis
            schemaCache.systeminitMillis = localStorage.getItem(systemInitTimeKey);



            //var log = $log.get("schemaCacheService#restore", ["performance"]);
            //log.debug("starting schema restore process");
            //var urlContext = url("");
            //var schemaCacheJson = localStorage[urlContext + ":schemaCache"];
            //if (schemaCacheJson) {
            //    schemaCache = JSON.parse(schemaCacheJson);
            //}
            //log.debug("finished schema restore took ");
        }

        function schemaStorageKey(applicationName, schemaId) {
            const username = contextService.getUserData().login;
            return keyRoot + username + ":" + applicationName + "." + schemaId;
        }

        function getRestService() {
            if (!restService) {
                restService = $injector.get("restService");
            }
            return restService;
        }
        //#endregion

        //#region Public methods
        function getSchemaCacheKeys() {
            if (sessionStorage.ignoreSchemaCache === "true") {
                return ";";
            }
            const result = ";" + Object.keys(schemaCache).join(";") + ";";
            $log.get("schemaCacheService#getSchemaCacheKeys").debug("schema keys in cache {0}".format(result));
            return result;
        }

        function getSchemaFromResult(result) {
            if (result.cachedSchemaId) {
                const log = $log.get("schemaCacheService#getSchemaFromResult", ["performance"]);
                log.info("schema {0}.{1} retrieved from cache".format(result.applicationName, result.cachedSchemaId));
                const cachedSchema = getCachedSchema(result.applicationName, result.cachedSchemaId);
                log.info("finish retrieving from cache".format(result.applicationName, result.cachedSchemaId));
                return cachedSchema;
            }
            return result.schema;
        }

        function getCachedSchema(applicationName, schemaId) {
            const cacheKey = applicationName + "." + schemaId;
            var schema = schemaCache[cacheKey];
            if (!schema) {
                const storageKey = schemaStorageKey(applicationName, schemaId);
                schema = localStorageService.get(storageKey);
                if (!!schema) {
                    schemaCache[cacheKey] = schema;
                }
            }
            return schema;
        }

        function addSchemaToCache(schema) {
            if (!schema || !!schema.ignoreCache) return;
            const log = $log.get("schemaCacheService#addSchemaToCache", ["performance"]);
            const schemaKey = schema.applicationName + "." + schema.schemaId;
            if (!!schemaCache[schemaKey]) return; // already in the cache

            log.info("adding schema {0} retrieved to cache".format(schemaKey));
            const systeminitMillis = contextService.getFromContext("systeminittime");
            // letÂ´s force a wipe before we update the systeminitMillis time
            this.wipeSchemaCacheIfNeeded();
            // in-memory first-level cache
            schemaCache[schemaKey] = schema;
            schemaCache.systeminitMillis = systeminitMillis;
            const storageKey = schemaStorageKey(schema.applicationName, schema.schemaId);
            try {
                // localStorage as second-level cache
                localStorage.setItem(systemInitTimeKey, systeminitMillis); // plain localStorage for performance and simpler data-structure
                localStorageService.put(storageKey, schema, { compress: true });
                log.info("finishing adding schema {0} retrieved to cache".format(schemaKey));
            } catch (e) {
                log.warn("localStorage is full... avoiding cache");
            }
        }

        function wipeSchemaCacheIfNeeded(forceClean) {
            const systeminitMillis = contextService.getFromContext("systeminittime");
            if (forceClean || (schemaCache && schemaCache.systeminitMillis !== systeminitMillis)) {
                $log.get("schemaCacheService#wipeSchemaCacheIfNeeded").info("wiping out schema cache");

                delete localStorage[url("") + ":schemaCache"]; // deleting 'deprecated' cache model

                Object.keys(localStorage)
                    .filter(function (key) {
                        return key.startsWith(keyRoot);
                    })
                    .forEach(function (schemakey) {
                        delete localStorage[schemakey];
                    });
                //wipe first-level cache
                schemaCache = { systeminitMillis: systeminitMillis };
            }

        }


        function fetchSchema(applicationName, schemaId) {
            const schema = getCachedSchema(applicationName, schemaId);
            if (schema) {
                return $q.when(schema);
            }

            const parameters = {
                applicationName: applicationName,
                targetSchemaId: schemaId
            };
            const promise = getRestService().getPromise("Metadata", "GetSchemaDefinition", parameters);
            return promise.then((result) => {
                this.addSchemaToCache(result.data);
                return result.data;
            });
        }
        //#endregion

        //#region Service Instance
        restore();
        const service = {
            getSchemaCacheKeys,
            addSchemaToCache,
            getCachedSchema,
            getSchemaFromResult,
            wipeSchemaCacheIfNeeded,
            fetchSchema
        };
        return service;
        //#endregion
    }

    //#region Service registration
    angular.module("webcommons_services").service("schemaCacheService", ["$log", "$q", "$injector", "contextService", "localStorageService", schemaCacheService]);
    //#endregion

})(angular);;
(function (angular) {
    "use strict";

    // service.$inject = [];

    var service = function () {

        var sanitizeDataMapToSendOnAssociationFetching = function (datamap) {
            var result = {};
            angular.forEach(datamap, function (value, key) {
                if (key.indexOf("_") !== -1) {
                    //ignoring any relationship data
                    return;
                }
                result[key] = value;
            });
            return result;
        }

        var api = {
            sanitizeDataMapToSendOnAssociationFetching: sanitizeDataMapToSendOnAssociationFetching
        };

        return api;
    };

    angular.module("webcommons_services").service("datamapSanitizeService", service);

})(angular);
;
(function (angular) {
    "use strict";

    function commandCommonsService($log,$q, expressionService, contextService) {
        
        //#region Public methods

        /**
         * Resolves the correct set of commands from the commandBarRegistry 
         * based on the position and the schema.
         * 
         * @param {Schema} schema 
         * @param {String} position 
         * @param {Object} commandBarRegistry dictionary with cached command bars
         * @returns {Array<Command>} commands for the specific position and schema. 
         */
        function getCommands(schema, position, commandBarRegistry) {
            const hasPossibilityOfbeingOverriden = schema.commandSchema.hasDeclaration;
            const bar = commandBarRegistry;
            if (bar == null) {
                //for some scenarions such as anonymous visualization of a single detail item, the bars wonÂ´t be brought
                return null;
            }

            const fallbackKey = `#${position}`;
            var commandKey = hasPossibilityOfbeingOverriden ? `${schema.applicationName}_${schema.schemaId}_${schema.mode.toLowerCase()}.#${position}` : fallbackKey;
            var commandbar = bar[commandKey];
            if (commandbar == null) {
                if (hasPossibilityOfbeingOverriden && schema.mode.toLocaleLowerCase() !== "none") {
                    //letÂ´s give the none schema a shot
                    commandKey = `${schema.applicationName}_${schema.schemaId}_none.#${position}`;
                    commandbar = bar[commandKey];
                }
                if (commandbar == null) {
                    commandbar = bar[fallbackKey];
                    if (commandbar == null) {
                        $log.get("commandCommonsService#getCommands", ["commands", "metadata"])
                            .warn(`command bar ${commandKey}, and fallback ${fallbackKey} not found`);
                    }
                }
            }
            const commands = commandbar != null ? commandbar.commands : null;
            return commands;
        }

        function getBarCommands(schema, position) {
            if (schema == null) {
                return $q.reject();
            }
            schema.jscache = schema.jscache || {};
            schema.jscache.commandbars = schema.jscache.commandbars || {};
            if (schema.jscache.commandbars[position] !== undefined) {
                //null should be considered as a cache hit also
                return schema.jscache.commandbars[position];
            }
            const bars = contextService.fetchFromContext("commandbars", true);
            const commands = this.getCommands(schema, position, bars);
            schema.jscache.commandbars[position] = commands;

            return commands;
        }

        //tabId parameter can be used in showexpression, do not remove it
        function isCommandHidden(datamap, schema, command, tabId) {
            if (command.remove) {
                return true;
            }
            const expression = command.showExpression;
            if (expression == undefined || expression === "") {
                return false;
            }
            return !expressionService.evaluate(expression, datamap, { schema: schema }, null);
        }

        //#endregion

        //#region Service Instance
        const service = {
            getCommands,
            getBarCommands,
            isCommandHidden
        };
        return service;
        //#endregion
    }

    //#region Service registration

    angular.module("webcommons_services").service("commandCommonsService", ["$log", "$q", "expressionService", "contextService", commandCommonsService]);

    //#endregion

})(angular);;
(function (angular) {
    "use strict";

    function richTextService() {

        const invalidTagsConfig = {
            /**
             * text processors queue
             */
            processors: [],

            regex: {
                /**
                 * matches '<(email_pattern)<(mailto:)?(email pattern)+>>'
                 */
                nestedemailtags: /\<((([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,}))+(\<(mailto\:)?((([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,}))+\>)\>/g,
                /**
                 * matches '<(mailto:)?(email pattern)+>'
                 * email pattern (accepts unicode characters and '.' before domain name) from: http://stackoverflow.com/questions/46155/validate-email-address-in-javascript#answer-16181
                 * PS: for some reason, compiling the pattern from a String (using new RegExp(pattern, "g")) did not work (didn't match the pattern)
                 * that's why the regex is in it's literal format
                 */
                emailtags: /\<(mailto\:)?((([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,}))+\>/g,
                /**
                 * matches '<(url pattern)+>' (url pattern includes query string)
                 * from: mix of http://code.tutsplus.com/tutorials/8-regular-expressions-you-should-know--net-6149 with http://stackoverflow.com/questions/23959352/validate-url-query-string-with-regex#answer-23959662
                 */
                urltags: /\<(((https?|ftp):\/\/)([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)\/?(\?([\w-]+(=[\w-]*)?(&[\w-]+(=[\w-]*)?)*)?)?)+\>/g,
                /**
                 * matches <file://(/\\)?/(path pattern)>
                 */
                fileurltags: /\<(file:\/\/(\/\\\\)?([\da-zA-Z\.-]+)([(\/|\\)\w \.-]*)\/?(\?([\w-]+(=[\w-]*)?(&[\w-]+(=[\w-]*)?)*)?)?)+\>/g,
                /**
                 * matches '<![if ((!)?any characters)]>(any characters)<![endif]>'
                 * e.g. "<![if !supportLists]>Â· <![endif]>"
                 * Usually introduced by email applications around special rich text constructs (such as lists).
                 */
                iftags: /\<\!\[if\s\!?([^\<\>\[\]])+\]\>([^\<\>\[\]])+\<\!\[(endif)\]\>/g
            },
           
            /**
             * pattern to build a valid html link tag
             */
            htmlLinkPattern: "<a href='{1}{0}'>{0}</a>"
        };

        function buildHtmlLinkTag(url, prefix) {
            return invalidTagsConfig.htmlLinkPattern.format(url, prefix || "");
        }

        /**
         * Register a text processor to be executed for replacing invalid html tags on a source text.
         * It's an iterative process so the next processor in the queue always receives a 'partially processed'
         * (processed by the previously executed processor) text as parameter.
         * 
         * @param Array[RegExp] regex matchers of the invalid tags the processor handles 
         * @param Function processor receives the source (partially processed) text and a problematic tag and returns the processed text 
         */
        function registerInvalidTagProcessor(regex, processor) {
            angular.forEach(regex, function(r) {
                invalidTagsConfig.processors.push({ 'regex': r, 'processor': processor });
            });
        }

        function executeInvalidTagProcessors(text) {
            if (!text) return text;
            var processed = angular.copy(text);
            angular.forEach(invalidTagsConfig.processors, function(proc) {
                const regex = proc.regex;
                const processor = proc.processor;
                const tags = processed.match(regex);
                if (!tags || tags.length <= 0) return;
                angular.forEach(tags, function(tag) {
                    processed = processor(processed, tag);
                });
            });
            return processed;
        }

        /**
         * Replaces invalid tags (that would otherwise case parse errors) by their valid counterpart e.g.:
         * - Replaces all '<mailto:(email pattern)>' or '<(email pattern)>' tags on the text by '<a href="mailto:email address">email address</a>'.
         * - Replaces all '<(url pattern)>' tags on the text by '<a href="url">url</a>'
         * 
         * @param String text 
         * @returns text with replaced tags 
         */
        function replaceInvalidTags(text) {
            return executeInvalidTagProcessors(text);
        }

        function getDisplayableValue(content) {
            // replace text line-breaks by html entity line-feed + html entity carriage return 
            content = replaceAll(content, "\n", String.fromCharCode(10, 13));
            return content;
        }

        function getDecodedValue(content) {
            const decodedHtml = getDisplayableValue(content);
            return replaceInvalidTags(decodedHtml);
        }

        function init() {
            // nested email
            registerInvalidTagProcessor([invalidTagsConfig.regex.nestedemailtags],
                function(source, tag) {
                    // extract email address from tag
                    // between '<' (position = 1) and second '<' (last index of '<')
                    const email = tag.substring(1, tag.lastIndexOf("<"));
                    // valid email tag
                    const htmlLink = buildHtmlLinkTag(email, "mailto:");
                    return source.replace(tag, htmlLink);
                });
            // email
            registerInvalidTagProcessor([invalidTagsConfig.regex.emailtags],
                function (source, tag) {
                    // extract email address from tag: 
                    // between ':'(from '<mailto:') or '<'(first character) and '>'(last character)
                    const hasmailto = tag.indexOf("<mailto:") >= 0;
                    const start = hasmailto ? tag.indexOf(":") + 1 : 1;
                    const email = tag.substring(start, tag.length - 1);
                    // creating valid html link tag and replacing invalid tag by it
                    const htmlLink = buildHtmlLinkTag(email, "mailto:");
                    return source.replace(tag, htmlLink);
                });
            // url + fileurl
            registerInvalidTagProcessor([invalidTagsConfig.regex.urltags, invalidTagsConfig.regex.fileurltags],
                function (source, tag) {
                    // extract url from tag: between '<'(first character) and '>'(last character)
                    const url = tag.substring(1, tag.length - 1);
                    // creating valid html link tag and replacing invalid tag by it
                    const htmlLink = buildHtmlLinkTag(url);
                    return source.replace(tag, htmlLink);
                });
            // if
            registerInvalidTagProcessor([invalidTagsConfig.regex.iftags],
                function (source, tag) {
                    // extract text wrapped by the 'if' tag
                    const start = tag.indexOf("]>") + 2;
                    const end = tag.lastIndexOf("<![endif]>");
                    const wrapped = tag.substring(start, end);
                    // remove the surrounding if tag
                    return source.replace(tag, wrapped);
                });
        }

        const service = {
            getDecodedValue,
            replaceInvalidTags,
            getDisplayableValue
        };
        init();
        return service;
    }

    angular.module("webcommons_services").service("richTextService", [richTextService]);

})(angular);
;
(function (angular) {
    "use strict";

    angular.module("webcommons_services").directive("floatConverter", [function () {
        const directive = {
            restrict: "A",
            transclude: false,
            replace: false,
            require: "ngModel",
            // scope: true,
            link: function (scope, element, attrs, ngModel) {
                ngModel.$parsers.push(viewValue => {
                    const modelValue = parseFloat(viewValue);
                    return !angular.isNumber(modelValue) || isNaN(modelValue) ? 0 : modelValue;
                });

                ngModel.$formatters.push(modelValue => element[0].type === "number" ? modelValue : String(modelValue));
            }
        };

        return directive;
    }]);

})(angular);;
//base idea: http://blog.projectnibble.org/2013/12/23/enhance-logging-in-angularjs-the-simple-way/



class LogHelp {
    constructor(description) {
        this.description = description;
    }
}

class LogHelper {

    help() {
        const logs = {
            association: new LogHelp("logs association information"),
            composition: new LogHelp("logs composition information"),
            detail: new LogHelp("crud detail related information"),
            filter: new LogHelp("filter related logs"),
            grid: new LogHelp("crud grid related information"),
            init: new LogHelp("logs information about the initialization of the directives/controllers"),
            layout: new LogHelp("logs information related to the layout of the screen"),
            modal: new LogHelp("modal related logs"),
            route: new LogHelp("information about navigation of pages"),
            save: new LogHelp("log for saving entries"),
            search: new LogHelp("logs information about the search process")
        };

        console.log("**************************************************************************************aspects****************************************************************************************************************");
        console.table(logs);

        const fns = {
            debug: new LogHelp("set a log, or an array of logs to debug level."),
            display: new LogHelp("Displays all current log levels"),
            info: new LogHelp("set a log, or an array of logs to info level."),
            reset: new LogHelp("resets specified logs (or all if none specified) to warn level")
            
        }
        console.log("**************************************************************************************functions****************************************************************************************************************");
        console.table(fns);
    }

    level(items,level) {
        if (!items) {
            sessionStorage.loglevel = level;
            return;
        }

        if (items instanceof Array) {
            items.forEach(i => sessionStorage[`log_${i}`] = level);
        } else {
            sessionStorage[`log_${items}`] = level;
        }
    }

    info(items) {
        this.level(items,"info");
    }

    debug(items) {
        this.level(items,"debug");
    }

    trace(items) {
        this.level(items, "trace");
    }

    display() {
        let i = sessionStorage.length;
        const logs = {};
        while (i--) {
            const key = sessionStorage.key(i);
            if (key.startsWith("log_")) {
                logs[key] = new LogHelp(sessionStorage[key]);
            }
        }
        console.table(logs);
    }

    reset(items) {
        sessionStorage.loglevel = 'warn';
        if (!items) {
            let i = sessionStorage.length;
            const logs = {};
            while (i--) {
                const key = sessionStorage.key(i);
                if (key.startsWith("log_")) {
                    sessionStorage[key] = "warn";
                }
            }
            return;
        }

        if (items instanceof Array) {
            items.forEach(i => sessionStorage[`log_${i}`] = 'warn');
        } else {
            sessionStorage[`log_${items}`] = 'warn';
        }
    }



}


window.swlog = new LogHelper();


(function (angular, modules) {
    "use strict";


    /**
     * Enhancing $log with angular decorator so it can be further decorated with other decorators
     * (altering the singleton in 'module.run' makes it harder to chain decorators).
     */
    modules.rootCommons.config(["$provide", function ($provide) {
        $provide.decorator("$log", ["$delegate", "$injector", function ($delegate, $injector) {
            enhanceAngularLog($delegate, $injector);
            return $delegate;
        }]);
    }]);

    function ltEnabledLevel(currLevel, enabledLevel) {
        if (!enabledLevel) {
            return true;
        }

        if (enabledLevel === "none") {
            return true;
        }
        if (enabledLevel.equalsIc("trace")) {
            return false;
        }
        if (enabledLevel.equalsIc("debug")) {
            return currLevel.equalsAny('trace');
        }
        if (enabledLevel.equalsIc("info")) {
            return currLevel.equalsAny('trace', 'debug');
        }
        if (enabledLevel.equalsIc("warn")) {
            return currLevel.equalsAny('trace', 'debug', 'info');
        }
        if (enabledLevel.equalsIc("error")) {
            return currLevel.equalsAny('trace', 'debug', 'info', 'warn');
        }
        return true;
    }

    function formatToMessage(arg) {
        if (arg instanceof Error) {
            if (arg.stack) {
                arg = (arg.message && arg.stack.indexOf(arg.message) < 0)
                    ? `Error: ${arg.message}\n${arg.stack}`
                    : arg.stack;
            } else if (arg.sourceURL) {
                arg = `${arg.message}\n${arg.sourceURL}:${arg.line}`;
            }
            return arg;
        }
        if (!angular.isString(arg)) {
            try {
                const jsonValue = JSON.stringify(JSON.decycle(arg));
                return jsonValue;
            } catch (err) {
                return arg;
            }
            
        }
        return arg;
    }


    function getContextLevel(context, relatedContexts) {
        const methodLogLevel = sessionStorage[`log_${context}`];
        if (methodLogLevel) {
            return methodLogLevel;
        }
        var minLevel = "none";
        if (relatedContexts) {
            angular.forEach(relatedContexts, relatedContext => {
                var relatedContextLevel = sessionStorage[`log_${relatedContext}`];
                if (relatedContextLevel && ltEnabledLevel(relatedContextLevel, minLevel)) {
                    minLevel = relatedContextLevel;
                }
            });
        }

        const indexOf = context.indexOf("#");
        if (indexOf >= 0) {
            const serviceName = context.substr(0, indexOf);
            const serviceLogLevel = sessionStorage[`log_${serviceName}`];
            if (serviceLogLevel) {
                return serviceLogLevel;
            }
        }
        return minLevel;
    };

    function getMinLevel(globalLevel, contextLevel) {
        if (!contextLevel) {
            return globalLevel;
        }

        if (contextLevel === "trace") {
            return contextLevel;
        }

        if (contextLevel === "debug") {
            return globalLevel === "trace" ? globalLevel : contextLevel;
        }

        if (contextLevel === "info") {
            return globalLevel.equalsAny("trace", "debug") ? globalLevel : contextLevel;
        }

        if (contextLevel === "warn") {
            return globalLevel.equalsAny("trace", "debug", "info") ? globalLevel : contextLevel;
        }

        return globalLevel;
    }

    function enhanceAngularLog($log, $injector) {
        $log.enabledContexts = [];

        window.rootlogger = $log;


        var contextService;


        function enhanceLogging(loggingFunc, level, context, relatedContexts) {
            return function () {
                const isEnabled = isLevelEnabled(level, context, relatedContexts);
                if (!isEnabled) {
                    return [];
                }

                /* const message = [].slice.call(args).map(formatToMessage).join(" "); */

                const currentargs = [].slice.call(arguments).map(formatToMessage);
                const contextarg = [`[${level.toUpperCase()}] ${window.moment().format("DD/MM/YYYY hh:mm:ss:SSS a")}::[${context}]> `];
                const modifiedArguments = contextarg.concat(currentargs);


                loggingFunc.apply(null, modifiedArguments);

                return modifiedArguments;
            };
        }

        function globalLogLevel() {
            const enabledLevel = sessionStorage["loglevel"];
            return !enabledLevel
                ? contextService.retrieveFromContext("defaultlevel") || "warn"
                : enabledLevel;
        }

        function isLevelEnabled(level, context, relatedContexts) {
            var enabledLevel = globalLogLevel();

            const contextLevel = getContextLevel(context, relatedContexts);
            enabledLevel = getMinLevel(enabledLevel, contextLevel);

            return !ltEnabledLevel(level, enabledLevel);
        }

        $log.getInstance = function (context, relatedContexts) {
            // getting around circular deps: $rootScope <- contextService <- $log <- $exceptionHandler <- $rootScope
            if (!contextService) contextService = $injector.get("contextService");
            return {
                log: enhanceLogging($log.log, 'log', context, relatedContexts, contextService),
                info: enhanceLogging($log.info, 'info', context, relatedContexts, contextService),
                warn: enhanceLogging($log.warn, 'warn', context, relatedContexts, contextService),
                debug: enhanceLogging($log.debug, 'debug', context, relatedContexts, contextService),
                trace: enhanceLogging($log.debug, 'trace', context, relatedContexts, contextService),
                error: enhanceLogging($log.error, 'error', context, relatedContexts, contextService),
                enableLogging(enable) {
                    $log.enabledContexts[context] = enable;
                },
                isLevelEnabled(level) {
                    return isLevelEnabled(level, context, relatedContexts);
                },
                get globalLogLevel() {
                    return globalLogLevel();
                }
            };
        };

        $log.get = function (context, relatedContexts) {
            return this.getInstance(context, relatedContexts);
        };

    };



})(angular, modules);
;
(function (angular, modules) {
    "use strict";

    modules.webcommons.config(['$provide', function ($provide) {

        $provide.decorator('$rootScope', ["$delegate", "$log", function ($delegate, $log) {
        const _emit = $delegate.$emit;
        const _broadcast = $delegate.$broadcast;
        const _on = $delegate.$on;

        $delegate.constructor.prototype.$onRootScope = function (name, listener) {
            var unsubscribe = $delegate.$on(name, listener);
            this.$on('$destroy', unsubscribe);
            return $delegate;
        }

        $delegate.$emit = function () {
            const log = $log.get("rootscope#emit");
            if (!arguments[0]) {
                throw new Error("event broadcasted with null value. Check JAvascriptEventConstants");
            }
            log.info(arguments[0]);
            log.debug(...arguments);
//            console.log.apply(console, arguments);
            return _emit.apply(this, arguments);
        };


        $delegate.$broadcast = function () {
            const log = $log.get("rootscope#broadcast");
            if (!arguments[0]) {
                throw new Error("event broadcasted with null value. Check JAvascriptEventConstants");
            }
            log.info(arguments[0]);
            log.debug(...arguments);
            //            console.log.apply(console, arguments);
            return _broadcast.apply(this, arguments);
        };


        $delegate.$on = function () {
            const log = $log.get("rootscope#on");
            log.info(arguments[0]);
            log.debug(...arguments);
            //            console.log.apply(console, arguments);
            return _on.apply(this, arguments);
        };

        return $delegate;
    }]);
}]);

})(angular, modules);;
(function (angular) {
    "use strict";


    angular.module('webcommons_services').config(['$provide', function ($provide) {

        $provide.decorator('dynamicScriptsCacheService',  ["$delegate", "$injector", function ($delegate, $rootScope) {

            const _register = $delegate.registerScript;
            const _usecustom = $delegate.useCustomServiceIfPresent;

            $delegate.registerScript = function () {
                const args = [$provide, ...arguments];
                return _register.apply(this, args );
            };


            return $delegate;


        }]);

    }
    ]);


})(angular);;
//base idea: http://blog.projectnibble.org/2013/12/23/enhance-logging-in-angularjs-the-simple-way/
(function (angular, modules) {
    "use strict";


    modules.webcommons.run(["$injector", "contextService", "dynamicScriptsCacheService", "$log", enhanceInjector]);


    function enhanceInjector($injector, contextService, dynamicScriptsCacheService, $log) {

        var original = $injector.invoke;

        $injector.getInstance = function (serviceName, throwError) {
            const client = contextService.client();
            const clientServiceName = client + "." + serviceName;
            const log = $log.get("clientawareserviceprovider", ["services"]);
            // has client specific implementation
            if ($injector.has(clientServiceName)) {
                log.debug("Client specific service", clientServiceName, "found.");
                var clientService = $injector.get(clientServiceName);
                // delegate 'super' methods to the base implementation
                if ($injector.has(serviceName)) {
                    log.debug(serviceName, "base implementation found. Applying base property bindings to", clientServiceName);
                    var baseService = $injector.get(serviceName);
                    angular.forEach(baseService, function (property, name) {
                        // skip useless (prototypically inherited from JS runtime) properties and overriden properties
                        if (!baseService.hasOwnProperty(name) || clientService.hasOwnProperty(name)) return;
                        const overridenProperty = angular.isFunction(property) ? property.bind(baseService) : property;
                        clientService[name] = overridenProperty;
                    });
                    clientService.__super__ = baseService;
                }
                return clientService;
            }
            if (client && client !== "otb") {
                log.debug("Client specific service", clientServiceName, "not found. Attempting to instantiate base service", serviceName);
            }
            if (throwError) {
                // if there's no base implementation let the error go up
                return $injector.get(serviceName);
            }
            return !$injector.has(serviceName) ? null : $injector.get(serviceName);

        };


        $injector.invoke = function (fn, self, locals, serviceName) {
            const customService = dynamicScriptsCacheService.useCustomServiceIfPresent(serviceName);
            if (customService != null) {
                $log.get("clientawareserviceprovider", ["angular", "services"]).debug(`applying custom service for ${serviceName}`);
                return customService;
            }

            return original(fn, self, locals, serviceName);
        }

    };



})(angular, modules);;
(function (angular) {
    "use strict";

    function inventorySharedService() {

        //#region Public methods

        /**
         * TODO: remove when swoff 'invissue creation' is supported
         * @deprecated 
         * @param String application current application name
         * @param Schema schema current schema
         * @param Datamap datamap selected datamap
         * @returns String detail schema's id
         */
        function nextReadOnlyInvIssueDetailSchema(application, schema, datamap) {
            return datamap["issuetype"] === "ISSUE" ? "viewinvissuedetail" : "viewinvreturndetail";
        }

        /**
         * @param String application current application name
         * @param Schema schema current schema
         * @param Datamap datamap selected datamap
         * @returns String detail schema's id
         */
        function nextInvIssueDetailSchema(application, schema, datamap) {
            //Logic to determine whether the record is an ISSUE
            //and whether all of the issued items have been returned
            if (datamap["issuetype"] !== "ISSUE") {
                //if itÂ´s not an issue redirecting to return screen
                return "viewinvreturndetail";
            }

            //Sets qtyreturned to 0 if null
            //Parses the qtyreturned if its in a strng format
            var qtyreturned = 0;
            if (angular.isString(["qtyreturned"])) {
                qtyreturned = parseInt(datamap["qtyreturned"]);
            } else if (datamap["qtyreturned"] != null) {
                qtyreturned = datamap["qtyreturned"];
            }

            //For an issue, the quantity will be a negative number, representing the # of items issued
            //The below if statement will add the positive quantityreturned to the negative quantity.
            //If the result is negative, then are still items to be returned
            if (qtyreturned + datamap["quantity"] >= 0) {
                //If all of the items have been returned, show the viewdetail page for 'ISSUE' records
                return "viewinvissuedetail";
            }

            if (qtyreturned + datamap["quantity"] !== -1) {
                //There are still items to be returned
                return application === "invreturn" ? "editinvreturndetail" : "editinvissuedetail";
            }

            return null;
        }

        //#endregion

        //#region Service Instance
        var service = {
            nextInvIssueDetailSchema: nextInvIssueDetailSchema,
            nextReadOnlyInvIssueDetailSchema: nextReadOnlyInvIssueDetailSchema
        };
        return service;
        //#endregion
    }

    //#region Service registration
    angular.module("webcommons_services").service("inventorySharedService", [inventorySharedService]);
    //#endregion

})(angular);;
// Platform specific overrides will be placed in the merges folder versions of this file;
//#region 'deviceready' listener
document.addEventListener("deviceready", function () {
    // retrieve the DOM element that had the ng-app attribute
    // bootstrap angular app "softwrench" programatically
    angular.bootstrap(document.body, ["softwrench"]);
}, false);
//#endregion




//#region App Modules
var mobileServices = angular.module('sw_mobile_services', ['sw_rootcommons', 'webcommons_services', 'maximo_applications', 'persistence.offline', 'audit.offline', "rollingLog"]);
var offlineMaximoApplications = angular.module('maximo_offlineapplications', ['persistence.offline', 'audit.offline']);
var softwrench = angular.module('softwrench', ['ionic', 'ion-autocomplete', 'ngCordova', 'sw_mobile_services', 'webcommons_services', 'sw_rootcommons', 'maximo_applications', 'maximo_offlineapplications', 'sw_scan', 'ng-mfb', "ui.tinymce", "ngTouch"])
//#endregion

//#region App.run
.run(["$ionicPlatform", "swdbDAO", "$log", "securityService",
    "localStorageService", "menuModelService", "metadataModelService", "routeService",
    "crudContextService", "synchronizationNotificationService",
    "offlinePersitenceBootstrap", "offlineEntities", "configurationService", "$rootScope", "$q",
    "$cordovaSplashscreen", "$timeout", "offlineCommandService", "$ionicScrollDelegate", "trackingService", "initialRouterService",
    function ($ionicPlatform, swdbDAO, $log, securityService, localStorageService, menuModelService, metadataModelService, routeService, crudContextService, synchronizationNotificationService, offlinePersitenceBootstrap,
        entities, configService, $rootScope, $q, $cordovaSplashscreen, $timeout, offlineCommandService, $ionicScrollDelegate, trackingService, initialRouterService) {

        var initialHref = null;

        function initContext() {

            const localdata = window.localdevdata;
            if (localdata && !!localdata.debuglogs) {
                const debugarr = localdata.debuglogs;
                debugarr.forEach(log => {
                    swlog.debug(log);
                });
            }


            initialHref= window.location.href;
            trackingService.enable();
            return offlinePersitenceBootstrap.init().then(() => {
                const menuPromise = menuModelService.initAndCacheFromDB();
                const metadataPromise = metadataModelService.initAndCacheFromDB();
                const commandBarsPromise = offlineCommandService.initAndCacheFromDataBase();
                //server side + client side configs
                const serverConfigPromise = configService.loadConfigs();
                const clientConfigPromise = configService.loadClientConfigs();
                const restoreAuthPromise = securityService.restoreAuthCookie();

                return $q.all([menuPromise, metadataPromise, serverConfigPromise, commandBarsPromise, clientConfigPromise, restoreAuthPromise]).then(() => menuModelService.updateAppsCount());
            });
        }

        // keep startup url (in case your app is an SPA with html5 url routing)
        

        window.restartApplication= function () {
            // Show splash screen (useful if your app takes time to load) 
//            navigator.splashscreen.show();
            // Reload original app url (ie your index.html file)
            window.location = initialHref;
        }

        function disableRipplePopup() {
            const dialogBody = parent.document.getElementById("exec-dialog");
            if (!dialogBody) {
                return;
            }
            const overlay = parent.document.querySelector(".ui-widget-overlay");
            
            const ngDialog = angular.element(dialogBody.parentElement);
            const ngOverlay = angular.element(overlay);
            const hideRules = { "height": "0px", "width": "0px", "display": "none" };
            ngDialog.css(hideRules); // hide annoying popup
            ngOverlay.css(hideRules); // hide annoying popup's backdrop
        }

        function initCordovaPlugins() {
            const log = $log.get("bootstrap#initCordovaPlugins");
            log.info("init cordova plugins");

            // first of all let's schedule the disable of ripple's annoying popup 
            // that tells us about unregistered plugins
            if (isRippleEmulator()) $timeout(disableRipplePopup);

            // Show/Hide keyboard accessory bar
            if (window.cordova && window.cordova.plugins && window.cordova.plugins.Keyboard) {
                cordova.plugins.Keyboard.hideKeyboardAccessoryBar(ionic.Platform.isAndroid());
            }
            // necessary to set fullscreen on Android in order for android:softinput=adjustPan to work
            if (ionic.Platform.isAndroid()) {
                if (window.StatusBar) window.StatusBar.styleDefault();
                //ionic.Platform.isFullScreen = true;
            }
            // local notification 
            synchronizationNotificationService.prepareNotificationFeature();
        }

        /**
            * Handles Android's softinput covering inputs that are close to the bottom of the screen.
            */
        function adjustAndroidSoftInput() {
            window.adjustAndroidSoftInput = adjustAndroidSoftInput;
            if (!ionic.Platform.isAndroid()) return;

            // native.showkeyboard callback
            // e contains keyboard height
            window.addEventListener("native.showkeyboard", e => {
                $timeout(() => {
                    const focusedElement = document.activeElement;
                    if (!focusedElement) return;

                    // no need to subtract e.keyboardHeight: by this point window.innerHeight is the viewport's height which is equal to keyboard's top's position
                    const keyBoardTopPosition = window.innerHeight;
                    const rect = focusedElement.getBoundingClientRect();
                    const elementBottomPosition = rect.bottom;

                    // if input is hidden by keyboard (position is calculated top to bottom)
                    if (keyBoardTopPosition < elementBottomPosition) {
                        // scroll with animation
                        const scrollOffsetY = elementBottomPosition - keyBoardTopPosition;
                        $ionicScrollDelegate.scrollBy(0, scrollOffsetY, true);
                    }
                }, 0, false);
            });

            window.addEventListener('native.hidekeyboard', e => {
                // remove focus from activeElement 
                // which is naturally an input since the nativekeyboard is hiding
                const focusedElement = document.activeElement;
                if (focusedElement) focusedElement.blur();
                // resize scroll after keyboard is gone
                $timeout(() => $ionicScrollDelegate.resize(), 0, false);
            });
        }

        function attachEventListeners() {
            // don't allow going to 'login' or 'settings' if the user is still logged
            $rootScope.$on("$stateChangeStart", function (event, toState, toParams, fromState, fromParams) {
                // not going to 'login' nor 'settings' -> do nothing
                if (toState.name.indexOf("login") < 0 && toState.name !== "settings") {
                    return;
                }
                // going to 'login' or 'settings' and no user authenticated -> allow transition
                if (!securityService.hasAuthenticatedUser()) {
                    return;
                }
                // going to login and user is authenticated -> prevent transition
                event.preventDefault();
            });
            // go to settings prior to going to login if no settings is set
            $rootScope.$on("$stateChangeSuccess", function (event, toState, toParams, fromState, fromParams) {
                // not going to 'login' or coming from 'settings' -> do nothing
                if (toState.name.indexOf("login") < 0 || fromState.name.indexOf("settings") >= 0) {
                    return;
                }
                // has serverurl -> do nothing
                const serverurl = localStorageService.get("settings:serverurl");
                if (!!serverurl) {
                    return;
                }
                // prevent state change
                event.preventDefault();
                // go to settings instead
                routeService.go("settings");
            });

            document.addEventListener("resume", initContext, false);

        }

        function loadInitialState() {
            initialRouterService.doInit();
        }

        function hideSplashScreen() {
            return $timeout(() => {
                if ($cordovaSplashscreen && angular.isFunction($cordovaSplashscreen.hide)) {
                    try {
                        $cordovaSplashscreen.hide();
                    } catch (err) {
                        //SWWEB-3102 --> at remote ripple this is not working properly, but not a big deal
                    }
                     
                }
            }, 1000);
        }

        $ionicPlatform.ready(() => {
            // loading eventual db stored values into context
            initContext().then(() => {
                adjustAndroidSoftInput();
                attachEventListeners();
                initCordovaPlugins();
                return loadInitialState();
            })
                .then(hideSplashScreen); // 1 second delay to prevent blank screen right after hiding the splash screen (empirically determined)
        });
    }
])
//#endregion

//#region App.config
    .config([
        "$stateProvider", "$urlRouterProvider", "$logProvider", "$ionicConfigProvider", "$httpProvider", function ($stateProvider, $urlRouterProvider, $logProvider, $ionicConfigProvider, $httpProvider) {

            // center page titles
            $ionicConfigProvider.navBar.alignTitle("center");

            $httpProvider.useApplyAsync(true);
            $ionicConfigProvider.views.transition('none');

            $logProvider.debugEnabled(true);

            // Ionic uses AngularUI Router which uses the concept of states
            // Learn more here: https://github.com/angular-ui/ui-router
            // Set up the various states which the app can be in.
            // Each state's controller can be found in controllers.js
            $stateProvider
                .state('login', {
                    url: '/login',
                    templateUrl: getResourcePath('Content/Mobile/templates/login.html'),
                    controller: 'LoginController',
                    params: { message: null }
                })
                .state('settings', {
                    url: '/settings',
                    templateUrl: getResourcePath('Content/Mobile/templates/settings_nomenu.html'),
                    controller: 'SettingsController'
                })

                // setup an abstract state for the tabs directive
                .state('main', {
                    url: "/main",
                    templateUrl: getResourcePath("Content/Mobile/templates/main.html"),
                    //abstract: true,
                    controller: 'MainController'
                })
                .state('main.home', {
                    url: '/home',
                    cache: false,
                    views: {
                        'main': {
                            templateUrl: getResourcePath('Content/Mobile/templates/syncoperation_detail.html'),
                            controller: 'SyncOperationDetailController'
                        }
                    }
                })
                .state('main.syncoperationhistory', {
                    url: '/syncoperationhistory',
                    views: {
                        'main': {
                            templateUrl: getResourcePath('Content/Mobile/templates/syncoperation_list.html'),
                            controller: 'SyncOperationHistoryController'
                        }
                    }
                })
                .state('main.syncoperationdetail', {
                    url: '/syncoperationdetail/{id}',
                    views: {
                        'main': {
                            templateUrl: getResourcePath('Content/Mobile/templates/syncoperation_detail.html'),
                            controller: 'SyncOperationDetailController'
                        }
                    }
                })
                .state('main.settings', {
                    url: '/settings',
                    views: {
                        'main': {
                            templateUrl: getResourcePath('Content/Mobile/templates/settings.html'),
                            controller: 'SettingsController'
                        }
                    }
                })
                // support
                .state("main.support", {
                    url: "/support",
                    views: {
                        'main': {
                            templateUrl: getResourcePath("Content/Mobile/templates/support.html"),
                            controller: "SupportController"
                        }
                    }
                })
                .state('main.crudlist', {
                    url: "/crudlist",
                    cache: false,
                    views: {
                        'main': {
                            templateUrl: getResourcePath("Content/Mobile/templates/crudlist.html"),
                            controller: 'CrudListController'
                        }
                    }
                })
                .state('main.crudlist.search', {
                    url: "/crudlistsearch",
                    views: {
                        'main@main': {
                            templateUrl: getResourcePath("Content/Mobile/templates/crudlistsearch.html"),
                            controller: 'CrudListSearchController'
                        }
                    }
                })
                .state('main.cruddetail', {
                    url: "/cruddetail",
                    views: {
                        'main': {
                            templateUrl: getResourcePath("Content/Mobile/templates/crud_detail.html"),
                            controller: 'CrudDetailController'
                        }

                    }
                })
                .state('main.cruddetail.maininput', {
                    url: "/crudinput",
                    views: {
                        'body': {
                            templateUrl: getResourcePath("Content/Mobile/templates/crud_input.html"),
                            controller: 'CrudInputController'
                        }
                    }
                })
                .state('main.cruddetail.compositionlist', {
                    url: "/crudcompositionlist",
                    cache: false,
                    views: {
                        'body': {
                            templateUrl: getResourcePath("Content/Mobile/templates/crud_composition_list.html"),
                            controller: 'CrudCompositionListController'
                        }
                    }
                })
                .state('main.cruddetail.compositiondetail', {
                    url: "/crudcompositionoutputdetail",
                    views: {
                        'body': {
                            templateUrl: getResourcePath("Content/Mobile/templates/crud_composition_detail.html"),
                            controller: 'CrudCompositionDetailController'
                        }
                    }
                })
                .state("main.cruddetail.tab", {
                    url: "/tab",
                    views: {
                        'body': {
                            templateUrl: getResourcePath("Content/Mobile/templates/crud_tab.html"),
                            controller: "CrudTabController"
                        }
                    }
                })
                .state('main.cruddetail.locationdrilldown', {
                    url: "/locationdrilldown",
                    cache: false,
                    views: {
                        'body': {
                            templateUrl: getResourcePath("Content/Customers/firstsolar_offline/templates/fslocationdrilldown.html"),
                            controller: 'FsLocationDrillDownController'
                        }
                    }
                })
                // audit
                .state("main.audit", {
                    'abstract': true,
                    url: "/audit"
                })
                .state("main.audit.applicationselect", {
                    url: "/application",
                    views: {
                        'main@main': {
                            templateUrl: getResourcePath("Content/Mobile/templates/audit/audit.application.select.html"),
                            controller: "AuditApplicationSelectController"
                        }
                    }
                })
                .state("main.audit.applicationselect.entrylist", {
                    url: "/list/{application}",
                    views: {
                        'main@main': {
                            templateUrl: getResourcePath("Content/Mobile/templates/audit/audit.entry.list.html"),
                            controller: "AuditEntryListController"
                        }
                    }
                })
                .state("main.audit.applicationselect.entrylist.entrydetail", {
                    url: "/entry/{id}",
                    views: {
                        'main@main': {
                            templateUrl: getResourcePath("Content/Mobile/templates/audit/audit.entry.detail.html"),
                            controller: "AuditEntryDetailController"
                        }
                    }
                });

        }
    ]);
//#endregion
;
(function (window) {
    "use strict";

    window.constants = window.constants || {};
    window.constants.localIdKey = "#localswdbid";
    window.constants.isDirty = "#localisDirty";
    window.constants.isPending = "#localisPending";
    window.constants.newItem = "_newitem#$";

})(window);
;
window.lastreleasebuildtime = "1518524641526";;
(function (angular, mobileServices) {
    "use strict";

    mobileServices.config(["$httpProvider", function ($httpProvider) {

        $httpProvider.defaults.withCredentials = true;
        $httpProvider.defaults.headers.common["offlineMode"] = true;

        function ajaxInterceptor($q, $rootScope, $timeout, contextService, $log, networkConnectionService, $injector) {

            var securityService = null;

            const started = function (config) {
                config.headers["offlineMode"] = true;
                config.headers["request_start_timestamp"] = new Date().getTime();
                const log = $log.getInstance("sw4.ajaxint#started");
                log.debug(`url: ${config.url}`);
            };

            const endedok = function (response) {
                const log = $log.getInstance("sw4.ajaxint#endedok");
                log.debug(`status: ${response.status}, url: ${response.config.url}`);
            };

            function isTimeoutError(rejection) {
                const timeout = rejection.config.timeout;
                const start = rejection.config["request_start_timestamp"];
                const now = new Date().getTime();
                return angular.isNumber(timeout) // timeout defined
                    && angular.isNumber(start) // start timestamp defined
                    && ((now - start) > timeout); // timeout has passed
            }

            const endederror = function (rejection) {
                const status = rejection.status;
                if (status === 0 || status === -1) {
                    // connection problem
                    if (networkConnectionService.isOffline()) {
                        // no connection at all
                        return new Error("No internet connection detected.");
                    }
                    const timeout = isTimeoutError(rejection);
                    // request-response timeout or server unreachable/socket timeout 
                    const message = (timeout ? "Request timed out" : "Server unreachable") + ". Please make sure the url in settings is correct and check your internet connection.";
                    const error = new Error(message);
                    if (rejection.config.url.contains("SignIn/Ping")) {
                        //to avoid circular error handling for ping calls that are made in order to double check server reacheability
                        return rejection;
                    }
                    error.type = timeout ? "timeout" : "unreacheable";    
                    
                    return error;
                
                } else if (status >= 500 && status < 600) {
                    const stack = rejection.data ? rejection.data.fullStack : "";
                    const error = new Error("Internal server error. Please contact support.");
                    if (!!stack) {
                        error.stack = stack;
                    }
                    // internal server error
                    return error;

                } else if (status === 404) {
                    // resource not found
                    return new Error("Requested resource not found. Please contact support.");

                } else if (status === 401) {
                    // unauthorized access
                    if (!securityService) securityService = $injector.get("securityService"); // getting around circular dependency problem ($state -> $http -> ... -> securityService -> routeService -> $state)
                    securityService.handleUnauthorizedRemoteAccess(rejection);
                } 
                return rejection;
            };

            const interceptor = {
                // optional method
                'request': function (config) {
                    started(config);
                    return config || $q.when(config);
                },
                // optional method
                'response': function (response) {
                    endedok(response);
                    return response || $q.when(response);
                },
                // optional method
                'responseError': function (rejection) {
                    const error = endederror(rejection);
                    return $q.reject(error || rejection);
                }
            };
            return interceptor;
        };
        
        $httpProvider.interceptors.push(["$q", "$rootScope", "$timeout", "contextService", "$log", "networkConnectionService", "$injector", ajaxInterceptor]);

    }]);

})(angular, mobileServices);;
;
(function ($, angular, _) {
    "use strict";

    /**
     * Allows screen tilt in mobile devices (required for iOS).
     * 
     * @param {Number} degrees 
     * @returns {Boolean} 
     */
    window.shouldRotateToOrientation = degrees => true;

    window.isRippleEmulator = () => document.URL.indexOf("http://") >= 0 || document.URL.indexOf("https://") >= 0;

    /**
     * Function that returns the angular $scope attached to an element.
     * It helps debug the app when deployed in Ripple (batarang's $scope inspection doesn't work in iframe);
     * 
     * @param {} element DOM element 
     * @returns {} $scope 
     */
    window.$s = element => {
        const elementWrapper = angular.element(element);
        return !angular.isFunction(elementWrapper["scope"]) ? null : elementWrapper.scope();
        //if (!scope || !scope['$parent']) {
        //    return scope;
        //}
        //return scope.$parent;
    };

    window.buildIdsString=  (ids) => {
        var result = [];
        angular.forEach(ids, function (id) {
            result.push("'{0}'".format(id));
        });
        return result;
    };

    window.Validate = Object.freeze(class {
        static notNull(value, name) {
            if (value === undefined || value === null) throw new Error(`${name || "value"} cannot be null`);
        }
        static notEmpty(value, name) {
            Validate.notNull(value, name);
            if (_.isString(value) && !value) throw new Error(`String ${name || "value"} cannot be empty`);
            if (_.isArray(value) && value.length <= 0) throw new Error(`Array ${name || "value"} cannot be empty`);
            if (_.isObject(value) && _.isEmpty(value)) throw new Error(`Object ${name || "value"} cannot be empty`);
        }
    });

    window.getService = name => angular.element(document.body).injector().get(name);

    window.offlineFullClear = function () {
        var dao = angular.element(document.body).injector().get("swdbDAO");
        dao.dropDataBase()
            .then(() => {
                console.log("database dropped");
                localStorage.clear();
                console.log("localStorage cleared");
                sessionStorage.clear();
                console.log("sessionStorage cleared", "reloading application");
                location.reload();
            })
            .catch(e => console.error("Failed to drop database", e));
    }

    window.getResourcePath = function (path) {
        if (!window.lastreleasebuildtime) {
            return path;
        }
        return path + "?" + window.lastreleasebuildtime;
    }
})(jQuery, angular, _);


;
class ConfigurationKeys {
    static get FacilitiesChanged() {
        return "facilitieschanged";
    }
};
(function (angular) {
    "use strict";

    angular.module("sw_mobile_services").constant("associationConstants", {
        Option: class {
            constructor(value, label, text, extra, checked) {
                this.value = value;
                this.label = label || this.value;
                this.text = text || this.label;
                this.extrafields = extra;
                this.checked = Boolean(checked);
            }
            setChecked(value) {
                this.checked = Boolean(value);
                return this;
            }
        }
    });

})(angular);;
(function (mobileServices) {
    "use strict";

    mobileServices.constant("crudConstants", {
        operation: {
            'create': "crud_create",
            'update': "crud_update"
        }
    });


})(mobileServices);;
(function (mobileServices, ionic) {
    "use strict";

    /**
     * @returns cordova directory constant (https://github.com/apache/cordova-plugin-file#where-to-store-files) 
     *          where the app's files should be created e.g. attachments and log files (changes depending on the platform)
     */
    function getAppFileDirectory() {
        var dir = undefined;
        if (ionic.Platform.isAndroid()) {
            dir = "externalDataDirectory";
        } else if (ionic.Platform.isIOS()) {
            // TODO: test user accessibility
            dir = "dataDirectory";
        } else if (ionic.Platform.isWindowsPhone()) {
            // TODO: test user acceesibility
            dir = "dataDirectory";
        }
        return dir;
    }

    class FilePathWrapper {
        toString() {
            return `{filePath: ${this.filePath}, fileName: ${this.fileName}, dirPath: ${this.dirPath}}`;
        }
        constructor(filePath) {
            if (!filePath || !angular.isString(filePath)) throw new Error("Path is empty or is not a string");
            this.filePath = filePath;
            const nameIndex = filePath.lastIndexOf("/") + 1;
            this.fileName = filePath.substr(nameIndex);
            this.dirPath = filePath.substr(0, nameIndex);
        }
    }

    class FileContentEntry {
        toString() {
            return `{length: ${this.length}, size: ${this.size}B}`;
        }
        constructor(data) {
            if (!data || !angular.isString(data)) throw new Error("Data is empty or is not a string");
            this.value = data;
            this.length = data.length;
            this.size = data.byteSize();
        }
    }

    class FileContentWrapper {
        toString() {
            return `{raw: ${this.data.toString()}, compressed: ${this.compressed.toString()}}`;
        }
        constructor(data) {
            // this.mime = mime;
            this.data = new FileContentEntry(data);
            const compressed = window.LZString.compressToUTF16(data);
            this.compressed = new FileContentEntry(compressed);
        }
    }

    mobileServices.constant("fileConstants", {
        fileEnabled: !isRippleEmulator(), // in ripple we don't use files
        appDirectory: getAppFileDirectory(),
        FilePathWrapper,
        FileContentWrapper
    });


})(mobileServices, ionic);;
(function(mobileServices) {
    "use strict";

    mobileServices.constant("rollingLogFileConstants", {
        // TODO: determine optimal size and buffer
        logFileSize: 10 * 1024 * 1024, // 10MB
        eventBuffer: 20,
        writeOnPause: false,
        logToConsole: false,
        debug: true, // controlled by the caller
        logFileName: "SWOFF"
    });


})(mobileServices);;
(function (app) {
    "use strict";

    app.controller("AuditApplicationSelectController",
        ["$scope", "offlineAuditService", "securityService", "routeService",
            function ($scope, offlineAuditService, securityService, routeService) {

                $scope.data = {
                    applications: []
                };

                var loadApplications = function () {
                    offlineAuditService.listAudittedApplications()
                        .then(function (applications) {
                            $scope.data.applications = applications;
                        });
                };

                $scope.selectApplication = function (application) {
                    routeService.go(".entrylist", { application: application });
                };

                loadApplications();

            }]);

})(softwrench);
;
(function (app) {
    "use strict";

    app.controller("AuditEntryDetailController",
        ["$scope", "offlineAuditService", "formatService", "$stateParams", "$ionicHistory",
            function ($scope, offlineAuditService, formatService, $stateParams, $ionicHistory) {

                $scope.data = {
                    entry: {},
                    entity: {}
                };

                $scope.back = function() {
                    $ionicHistory.goBack();
                };

                var formatEntry = function(entry) {
                    entry.formattedDate = formatService.formatDate(entry.createDate, "MM/dd/yyyy HH:mm");
                    return entry;
                };

                var loadData = function (id) {
                    offlineAuditService.getAuditEntry(id)
                        .then(function (entry) {
                            $scope.data.entry = formatEntry(entry);

                            return offlineAuditService.getTrackedEntity(entry);
                        })
                        .then(function(entity) {
                            $scope.data.entity = entity;
                        });
                };

                loadData($stateParams.id);

            }]);

})(softwrench);
;
(function (app) {
    "use strict";

    app.controller("AuditEntryListController",
        ["$scope", "offlineAuditService", "formatService", "$stateParams", "routeService", "$ionicHistory",
            function ($scope, offlineAuditService, formatService, $stateParams, routeService, $ionicHistory) {

                var application = $stateParams.application;

                $scope.data = {
                    entryList: []
                };

                $scope.paginationData = {
                    currentPage: 1,
                    pageSize: 10,
                    hasMoreAvailable: true
                };

                $scope.openDetail = function (entry) {
                    routeService.go(".entrydetail", { id: entry.id });
                };

                $scope.back = function () {
                    $ionicHistory.goBack();
                };

                var formatEntries = function (entries) {
                    return entries.map(function (entry) {
                        entry.formattedDate = formatService.formatDate(entry.createDate, "MM/dd/yyyy HH:mm");
                        return entry;
                    });
                };

                $scope.loadPagedList = function () {
                    var options = {
                        pagenumber: $scope.paginationData.currentPage,
                        pagesize: $scope.paginationData.pageSize
                    };
                    offlineAuditService.listEntries(application, options)
                        .then(function (entries) {
                            // update pagination data
                            $scope.paginationData.hasMoreAvailable = (entries && entries.length >= $scope.paginationData.pageSize);
                            $scope.paginationData.currentPage += 1;
                            // update list
                            $scope.data.entryList = $scope.data.entryList.concat(formatEntries(entries));
                        })
                        .finally(function () {
                            $scope.$broadcast("scroll.infiniteScrollComplete");
                        });
                };

                //TODO: add support for search filters

            }]);

})(softwrench);
;
(function(softwrench) {
    "use strict";

    softwrench.controller('CompositionMenuController', ["$log", "$scope", "$ionicScrollDelegate", "crudContextService", function ($log, $scope, $ionicScrollDelegate, crudContextService) {

        $scope.compositionMenus = function () {
            return crudContextService.currentCompositionsToShow();
        }

        $scope.getTabIcon = function (tab) {
            return tab.type === "ApplicationTabDefinition" ? tab.icon : tab.schema.schemas.list.properties['icon.composition.tab'];
        };

        $scope.loadTab = function (tab) {
            crudContextService.loadTab(tab).then(() => {
                $scope.$emit("sw_compositionselected");
            });
            $ionicScrollDelegate.scrollTop();
        }

        $scope.notOnMainTab = function () {
            return !crudContextService.isOnMainTab();
        }

    }]);

})(softwrench);

;
(function (softwrench) {
    "use strict";

    softwrench.controller('CrudCompositionDetailController', ["$log", "$scope", "$rootScope", "crudContextService", "fieldService", "offlineCompositionService", "offlineAssociationService", "schemaService", "eventService",
    function ($log, $scope, $rootScope, crudContextService, fieldService, offlineCompositionService, offlineAssociationService, schemaService, eventService) {

        function init() {
            $scope.schema = crudContextService.getCompositionDetailSchema();
            $scope.displayables =  schemaService.allDisplayables($scope.schema);
            $scope.datamap = crudContextService.getCompositionDetailItem();
            $scope.allowsUpdate = offlineCompositionService.allowsUpdate(crudContextService.getCompositionDetailItem(), crudContextService.getCompositionListSchema());

            eventService.onload($scope, $scope.schema, $scope.datamap, {});
        }

        $scope.$on('$stateChangeSuccess',
        function (event, toState, toParams, fromState, fromParams) {
            if (toState.name.startsWith("main.cruddetail.compositiondetail")) {
                //needs to refresh the displayables and datamap everytime the detail page is loaded.
                init();
            }
        });

        init();

    }]);
})(softwrench);



;
(function (softwrench, _) {
    "use strict";

    softwrench.controller('CrudCompositionListController', ["$log", "$scope", "$rootScope", "$ionicPopup", "crudContextService", "fieldService", "formatService", "crudContextHolderService", "offlineAttachmentService", "$injector",
    function ($log, $scope, $rootScope, $ionicPopup, crudContextService, fieldService, formatService, crudContextHolderService, offlineAttachmentService, $injector) {

        $scope.empty = function () {
            const compositionList = crudContextService.compositionList();
            return !compositionList || compositionList.length === 0;
        }

        $scope.list = function () {
            return crudContextService.compositionList();
        }

        //$scope.fieldLabel = function (item, field) {
        //    return field.label + ":" + formatService.format(item[field.attribute], field, item);
        //}

        $scope.fieldValue = function(item, field) {
            return formatService.format(item[field.attribute], field, item);
        }

        $scope.visibleFields = function (item) {
            const schema = crudContextService.getCompositionListSchema();
            return fieldService.getVisibleDisplayables(item, schema);
        }

        $scope.loadCompositionDetail = function (item) {
            crudContextService.loadCompositionDetail(item);
        }

        // ReSharper disable once UnusedParameter
        const deleteCompositionFromLocalId = function (localId, datamap, relationship) {
            const compositions = datamap[relationship];
            if (!compositions) {
                return;
            }

            const index = _.findIndex(compositions, composition => composition["#localswdbid"] === localId);
            
            if (index >= 0) {
                compositions.splice(index, 1);
            }
        }

        function handlerOrDefault(event, defaultAction, ...params) {
            if (!event || !$injector.has(event.service)) {
                return defaultAction();
            }
            const predeleteHandler = $injector.getInstance(event.service);
            if (!angular.isFunction(predeleteHandler[event.method])) {
                return defaultAction();
            }
            return predeleteHandler[event.method](...params, defaultAction);
        }

        $scope.startDeleteLocalComposition = function (item) {
            const localId = item["#localswdbid"];
            if (!localId) {
                return;
            }

            const compositionSchema = crudContextHolderService.getCompositionDetailSchema();
            const compositionTitle = compositionSchema["title"] || compositionSchema["applicationTitle"];
            const compositionListSchema = crudContextHolderService.getCompositionListSchema();
            const context = crudContextHolderService.getCrudContext();
            const tab = context.composition.currentTab;
            const compositionMetadata = tab.schema;

            const preDeleteEvent = compositionMetadata.events["beforedelete"] || compositionListSchema.events["beforedelete"];
            const postDeleteEvent = compositionMetadata.events["afterdelete"] || compositionListSchema.events["afterdelete"];

            const defaultPreDeletePromise = () => $ionicPopup.confirm({
                title: `Delete ${compositionTitle}`,
                template: `Are you sure to delete this local ${compositionTitle}?`
            });
            const preDeletePromise = handlerOrDefault(preDeleteEvent, defaultPreDeletePromise, item);

            return preDeletePromise.then(res => {
                if (!res) {
                    return;
                }

                const relationship = tab["relationship"];

                const datamap = crudContextHolderService.currentDetailItemDataMap();
                deleteCompositionFromLocalId(localId, datamap, relationship);

                const originalDatamap = context.originalDetailItemDatamap;
                deleteCompositionFromLocalId(localId, originalDatamap, relationship);

                const compositionList = $scope.list();
                const index = compositionList.indexOf(item);
                compositionList.splice(index, 1);

                const savePromise = crudContextService.saveCurrentItem(false);

                const deletePromise = compositionSchema.applicationName === "attachment"
                    ? savePromise.then(saved => offlineAttachmentService.deleteRelatedAttachment(item).then(() => saved))
                    : savePromise;

                return deletePromise.then(saved => handlerOrDefault(postDeleteEvent, () => saved, item, saved));
            });


        }

        $scope.isDirty = function (item) {
            return item[constants.localIdKey];
        }

    }]);

})(softwrench, _);



;

(function (softwrench) {
    "use strict";

    softwrench.controller("CrudDetailController", ['$log', "$q", '$scope', '$rootScope', '$timeout', '$state', 'schemaService', "crudContextHolderService", "wizardService", "$ionicPlatform", "drillDownService", "offlineCompositionService", "inlineCompositionService",
        'crudContextService', 'fieldService', '$ionicPopover', '$ionicPopup', '$ionicHistory', '$ionicScrollDelegate', 'eventService', "expressionService", "offlineSchemaService", "commandBarDelegate", "swAlertPopup", "loadingService",
        function (log, $q, $scope, $rootScope, $timeout, $state, schemaService, crudContextHolderService, wizardService, $ionicPlatform, drillDownService, offlineCompositionService, inlineCompositionService,
            crudContextService, fieldService, $ionicPopover, $ionicPopup, $ionicHistory, $ionicScrollDelegate, eventService, expressionService, offlineSchemaService, commandBarDelegate, swAlertPopup, loadingService) {

            $scope.inlineCompositionsLoaded = false;

            function turnOffChangeEvents() {
                $rootScope.areChangeEventsEnabled = false;
            }

            function turnOnChangeEvents() {
                // to force change the flag after the events are trigged
                $timeout(() => $rootScope.areChangeEventsEnabled = true, 0, false);
            }

            $ionicPopover.fromTemplateUrl(getResourcePath("Content/Mobile/templates/griditemoptionsmenu.html"), { scope: $scope }).then(popover => $scope.optionspopover = popover);

            function init() {
                log.get("crud_detail#init").debug("crud detail init");
                $scope.allDisplayables = crudContextService.mainDisplayables();
                $scope.displayables = wizardService.getWizardFields($scope.allDisplayables);
                $scope.schema = crudContextService.currentDetailSchema();
                $scope.allDisplayablesIncludingTabs = schemaService.allFieldsIncludingTabs($scope.schema);
                $scope.datamap = crudContextService.currentDetailItemDataMap();
                $scope.item = crudContextHolderService.currentDetailItem();

                $timeout(() => {
                        const element = $("command-bar[position=\"mobile.fab\"]");
                        commandBarDelegate.positionFabCommandBar(element);
                    },0,false);
                

                if (!$scope.inlineCompositionsLoaded) {
                    inlineCompositionService.loadInlineCompositions($scope.item, $scope.datamap, $scope.allDisplayables)
                        .then(() => {
                            $scope.inlineCompositionsLoaded = true;
                        });
                } else {
                    $rootScope.areChangeEventsEnabled = true;
                }


            }

            $ionicPopover.fromTemplateUrl(getResourcePath("Content/Mobile/templates/compositionmenu.html"), { scope: $scope })
                .then(popover => $scope.compositionpopover = popover);


            $scope.expandCompositions = function ($event) {
                $scope.compositionpopover.show($event);
            }

            $scope.compositionListSchema = null;

            $scope.$on("sw_compositionselected", function () {
                $scope.compositionpopover.hide();
                $scope.compositionListSchema = $scope.isOnMainTab() ? null : crudContextService.getCompositionListSchema();
            });

            $scope.$watch(() => $scope.isOnMainTab(), (newValue, oldValue) => {
                if (oldValue === newValue) {
                    return;
                }
                $scope.compositionListSchema = !newValue
                    ? crudContextService.getCompositionListSchema()
                    : null;
            });

            $scope.loadMainTab = function () {
                $ionicScrollDelegate.scrollTop();
                crudContextService.loadTab(null);
            }

            $scope.tabTitle = function () {
                return crudContextService.tabTitle();
            }


            $scope.showNavigation = function () {
                return !crudContextService.hasDirtyChanges();
            }

            $scope.hasNextItem = function () {
                return !!crudContextHolderService.getCrudContext().nextItem;
            };

            $scope.hasPreviousItem = function () {
                return !!crudContextHolderService.getCrudContext().previousItem;
            };

            $scope.hasAnyComposition = function () {
                return crudContextService.currentCompositionsToShow().length > 0;
            }

            $scope.cancelChanges = function () {
                $ionicPopup.confirm({
                    title: "Confirm Cancel",
                    template: "Any changes made will be lost. Proceed?"
                })
                    .then(res => {
                        if (res) {
                            turnOffChangeEvents();
                            crudContextService.cancelChanges();
                            $scope.datamap = crudContextService.currentDetailItemDataMap();

                            // to force change the flag after the events are trigged
                            $timeout(() => $rootScope.areChangeEventsEnabled = true, 0, false);
                            turnOnChangeEvents();

                            // to force inline compositions reload
                            inlineCompositionService.cancelChanges();
                        }
                    });
            }

            function showValidationErrors(validationErrors) {
                swAlertPopup.alertValidationErrors(validationErrors);
            }

            $scope.saveChanges = function () {
                crudContextService.saveChanges()
                    .then(() => {
                        $scope.inlineCompositionsLoaded = false;
                        init();
                    }).catch((errors) => {
                        if (errors && errors.length > 0) {
                            showValidationErrors(errors);
                        } else if (errors) { // not a validation error
                            throw errors;
                        }
                    });
            };

            $scope.hasDirtyChanges = function () {
                return crudContextService.hasDirtyChanges();
            };

            $scope.shouldShowBack = function () {
                return !$scope.hasDirtyChanges() && $ionicHistory.viewHistory().backView;
            };

            $scope.navigateBack = function () {
                loadingService.showDefault();
                //need a timeout in order to force the icon to show up.
                //the hide would be called on the crud_list statechanged handler method
                $timeout(() => $ionicHistory.goBack(), 0, false);
                //            loadingService.hide();
            };

            $scope.isOnMainTab = function () {
                return crudContextService.isOnMainTab();
            };

            $scope.isOnDrillDown = function () {
                return drillDownService.isOnDrillDown();
            };

            $scope.drillDownBack = function () {
                if (!drillDownService.drillDownBack()) {
                    $scope.navigateBack();
                }
            }

            $scope.isDrillDownAssetView = function () {
                return drillDownService.getDrillDown().assetView;
            }

            $scope.drillDownAssetView = function () {
                return drillDownService.assetView();
            }

            $scope.detailSubTitle = function () {
                return crudContextService.isCreation()
                    ? null
                    : offlineSchemaService.buildDisplayValue(crudContextService.currentListSchema(), "subtitle", $scope.datamap);
            };

            $scope.detailFeatured = function (item) {
                return crudContextService.isCreation()
                    ? null
                    : offlineSchemaService.buildDisplayValue(crudContextService.currentListSchema(), "featured", $scope.datamap);
            };

            $scope.detailTitle = function () {
                const datamap = crudContextService.isCreation() ? null : $scope.datamap; // workaround to force new title
                return schemaService.getTitle(crudContextService.currentDetailSchema(), datamap, true);
            };

            $scope.detailSummary = function () {
                const datamap = crudContextService.isCreation() ? null : $scope.datamap; // workaround to force new title
                return schemaService.getSummary(crudContextService.currentDetailSchema(), datamap, true);
            };

            const arrowNavigate = function (navigate) {
                turnOffChangeEvents();
                crudContextService[navigate]()
                    .then(() => {
                        $scope.datamap = crudContextService.currentDetailItemDataMap();
                        $scope.item = crudContextHolderService.currentDetailItem();
//                        inlineCompositionService.loadInlineCompositions($scope.item, $scope.datamap, $scope.allDisplayables);
                    })
                    .finally(() => {
                        turnOnChangeEvents();
                    });
            };

            $scope.navigateNext = function () {
                arrowNavigate("navigateNext");
            };

            $scope.navigatePrevious = function () {
                arrowNavigate("navigatePrevious");
            };

            $scope.onSwipeLeft = function () {
                if ($scope.showNavigation() && !$scope.isOnDrillDown()) {
                    $scope.navigateNext();
                }
            };

            $scope.onSwipeRight = function () {
                if ($scope.showNavigation() && !$scope.isOnDrillDown()) {
                    $scope.navigatePrevious();
                }
            };

            $scope.onScroll = function () {
                const position = $ionicScrollDelegate.$getByHandle('detailHandler').getScrollPosition();
                //update the position of the detail's floating action button when the user scrolls
                if (!!position) {
                    const element = $("command-bar[position=\"mobile.fab\"]");
                    commandBarDelegate.positionFabCommandBar(element, position.top);
                }
            };

            $scope.shouldShowWizardBack = function () {
                return wizardService.canReturn();
            };

            $scope.shouldShowWizardForward = function () {
                return wizardService.isInWizardState($scope.allDisplayables);
            };

            $scope.wizardNavigateBack = function () {
                $scope.displayables = wizardService.previous($scope.allDisplayables);
            };

            $scope.wizardNavigateForward = function () {
                const validationErrors = crudContextService.validateDetail({}, null, $scope.displayables);
                if (validationErrors.length !== 0) {
                    showValidationErrors(validationErrors);
                    return;
                }
                $scope.displayables = wizardService.next($scope.allDisplayables);
            };

            $scope.isDirty = function (item) {
                return $scope.item.isDirty;
            };

            $scope.isPending = function (item) {
                return $scope.item.pending;
            };

            $scope.hasProblems = function () {
                return $scope.item.hasProblem;
            };

            $scope.lastProblemMesage = function () {
                const problems = crudContextHolderService.currentProblems();
                if (!problems || problems.length === 0) {
                    return null;
                }
                return problems[0].message;
            };

            $scope.drillStyle = function() {
                return $state.$current.name === "main.cruddetail.locationdrilldown" ? { height: "calc(100vh - 87px)" } : {};
            }

            // handles device back button
            const deregisterHardwareBack = $ionicPlatform.registerBackButtonAction(() => {
                if ($scope.shouldShowBack()) {
                    $scope.navigateBack();
                } else if ($scope.shouldShowWizardBack()) {
                    $scope.wizardNavigateBack();
                    $scope.$apply();
                } else {
                    $scope.cancelChanges();
                }
            }, 100);
            $scope.$on("$destroy", deregisterHardwareBack);

            $scope.$on('sw_cruddetailrefreshed', function () {
                $scope.datamap = crudContextService.currentDetailItemDataMap();
                $scope.inlineCompositionsLoaded = false;
                init();
            });

            $scope.showDirtyOptions = function ($event) {
                var item = crudContextService.currentDetailItem();
                if (item.isDirty) {
                    crudContextHolderService.getCrudContext().currentPopOverItem = item;
                    $scope.optionspopover.show($event);
                }
            }

            $scope.$on("sw_griditemoperationperformed", () => {
                $scope.optionspopover.hide();
                crudContextHolderService.getCrudContext().currentPopOverItem = null;
            });

            $scope.$on('$stateChangeSuccess',
                function (event, toState, toParams, fromState, fromParams) {
                    if (fromState.name === "main.cruddetail.compositiondetail") {
                        crudContextService.leavingCompositionDetail();
                    }

                    if (toState.name.startsWith("main.cruddetail") && toState.name !== "main.cruddetail.locationdrilldown") {
                        //needs to refresh the displayables and datamap everytime the detail page is loaded.
                        init();
                        loadingService.hide();
                        if (toState.name === "main.cruddetail.maininput") {
                            crudContextService.resetTab();
                        }
                    } /*else {
                      crudContextService.leavingDetail();
                      if (!toState.name.startsWith("main.crud")) {
                        crudContextService.resetContext();
                      }
                  }*/
                });

            init();

        }]);

})(softwrench);


;
(function (angular) {
    "use strict";

    angular.module("softwrench").controller("CrudInputController", ['$log', '$scope', 'crudContextService', 'fieldService', 'offlineAssociationService', '$ionicPopover', 'expressionService', function ($log, $scope, crudContextService, fieldService, offlineAssociationService, $ionicPopover, expressionService) {

//        $ionicPopover.fromTemplateUrl(getResourcePath('Content/Mobile/templates/compositionmenu.html'), {
//            scope: $scope,
//        }).then(function (popover) {
//            $scope.compositionpopover = popover;
//        });

    }]);
    
})(angular);


;
(function (softwrench) {
    "use strict";

    softwrench.controller("CrudListController", ["$log", '$scope', 'crudContextService', 'offlineSchemaService', '$ionicScrollDelegate', '$timeout', '$ionicPopover', 'eventService', "routeConstants",
        "synchronizationFacade", "routeService", "crudContextHolderService", "itemActionService", "loadingService", "$ionicSideMenuDelegate", "laborService", "crudSearchService", 
        function ($log, $scope, crudContextService, offlineSchemaService, $ionicScrollDelegate, $timeout, $ionicPopover, eventService, routeConstants, synchronizationFacade, routeService, crudContextHolderService, itemActionService, loadingService, $ionicSideMenuDelegate, laborService, crudSearchService) {

            $scope.crudlist = {
                items: [],
                moreItemsAvailable: true
            };

            function laborThenDirtyItemsFirst(allItems) {
                const laborItems = [];
                const dityItems = [];
                const nonDirtyItems = [];

                angular.forEach(allItems, (item) => {
                    if (laborService.hasItemActiveLabor(item)) {
                        laborItems.push(item);
                    }else if (item.isDirty) {
                        dityItems.push(item);
                    } else {
                        nonDirtyItems.push(item);
                    }
                });
                return laborItems.concat(dityItems).concat(nonDirtyItems);
            }

            function initializeList() {
                

                const context = crudContextHolderService.getCrudContext();
                context.itemlist = laborThenDirtyItemsFirst(context.itemlist);

                // getting references to elements instead of to the whole list
                $scope.crudlist.items = context.itemlist.map(i => i);
                //do not allow infinite scroll for small subset of items preventing a second query to take place upon grid loading
                $scope.crudlist.moreItemsAvailable = $scope.crudlist.items.length > 4;
            }

            function init() {
                initializeList();
                $scope._searching = false;
                //
                //                $ionicPopover.fromTemplateUrl(getResourcePath("Content/Mobile/templates/filteroptionsmenu.html"), {
                //                    scope: $scope,
                //                }).then(popover => 
                //                    $scope.filteroptionspopover = popover
                //                );

                $timeout(() => $ionicScrollDelegate.scrollTop(), 0, false);

                const schema = crudContextService.currentListSchema();
                const datamap = crudContextService.itemlist();
                if (schema) {
                    eventService.onload($scope, schema, datamap, { schemaId: schema.schemaId });    
                }
                

                $scope.quickSearch = crudContextHolderService.getQuickSearch();
                if (typeof $scope.quickSearch.value === "undefined") {
                    $scope.quickSearch.value = null;
                }
            }

            $ionicPopover.fromTemplateUrl(getResourcePath("Content/Mobile/templates/griditemoptionsmenu.html"), { scope: $scope }).then(popover => $scope.optionspopover = popover);

            init();

            $scope.isSearching = function () {
                return $scope._searching;
            }

            $scope.enableSearch = function () {
                $scope._searching = true;
                $ionicScrollDelegate.scrollTop();
                // $scope.moreItemsAvailable = false;
            }

            $scope.goToAdvancedFilter = function () {
                routeService.go(".search", {});
            }

            $scope.filter = function () {
                crudContextService.refreshGrid(true).then(initializeList);
            };

            $scope.isDirty = function (item) {
                return item.isDirty;
            }

            $scope.isPending = function (item) {
                return item.pending;
            }

            $scope.hasProblem = function (item) {
                return item.hasProblem;
            }

            $scope.showFilterOptions = function ($event) {
                $scope.filteroptionspopover.show($event);
            }

            $scope.$on("sw_filteroptionclosed", function () {
                $scope.filteroptionspopover.hide();
            });

            $scope.createEnabled = function () {
                const schema = crudContextService.currentListSchema();
                if (!schema) {
                    return false;
                }

                const schemaDisabled = schema.properties["list.offline.create.disabled"];
                const menuDisabled = crudContextService.getCrudContext().menuDisableCreate;
                const disabled = schemaDisabled === "true" || schemaDisabled === true || menuDisabled === "true" || menuDisabled === true;

                return !disabled && crudContextService.hasNewSchemaAvailable();
            };

            $scope.disableSearch = function (clear) {
                $scope._searching = false;
                if (clear) {
                    crudSearchService.clearGridSearchValues();
                    crudContextService.refreshGrid();
                }
                $ionicScrollDelegate.scrollTop();
            }

            $scope.gridTitle = function () {
                const schema = crudContextHolderService.currentListSchema();
                const context = crudContextHolderService.getCrudContext();
                const title = context.menuGridTitle || crudContextService.gridTitle(schema);
                return title + " (" + context.gridSearch.count + ")";
            }

            $scope.itemTitle = function (item) {
                const title = offlineSchemaService.buildDisplayValue(crudContextService.currentListSchema(), "title", item);
                if (title == null) {
                    return `New ${crudContextService.currentTitle()}`;
                }
                return title;
            }

            $scope.itemSubTitle = function (item) {
                return offlineSchemaService.buildDisplayValue(crudContextService.currentListSchema(), "subtitle", item);
            }

            $scope.itemFeatured = function (item) {
                return offlineSchemaService.buildDisplayValue(crudContextService.currentListSchema(), "featured", item);
            }

            $scope.itemExcerpt = function (item) {
                return offlineSchemaService.buildDisplayValue(crudContextService.currentListSchema(), "excerpt", item);
            }

            $scope.openDetail = function (item) {
                crudContextService.loadDetail(item);
            }

            $scope.toggleMenu = function () {
                $ionicSideMenuDelegate.toggleLeft();
            }

            $scope.createItem = function () {
                crudContextService.createDetail();
            }

            $scope.fullSync = function (item) {
                loadingService.showDefault();
                return synchronizationFacade.fullSync().then(() => {
                    //updating the item on the list after it has been synced
                    crudContextService.refreshGrid();
                }).finally(() => {
                    loadingService.hide();
                    $scope.$broadcast('scroll.refreshComplete');
                });
            }


            $scope.showGridItemOptions = function ($event, item) {
                if (item.isDirty) {
                    crudContextHolderService.getCrudContext().currentPopOverItem = item;
                    $scope.optionspopover.show($event);
                }
            }

            $scope.$on("sw_griditemoperationperformed", () => {
                $scope.optionspopover.hide();
                crudContextHolderService.getCrudContext().currentPopOverItem = null;
            });

            $scope.$on("$stateChangeSuccess",
                 function (event, toState, toParams, fromState, fromParams) {
                     $log.get("crudlist#statehandler").debug("handler called", arguments);
                     if (!toState.name.startsWith("main.crud")) {
                         //                         crudContextService.resetContext();
                         //                         $scope.crudlist.items = [];
                         //                         $scope.crudlist.moreItemsAvailable = false;
                     } else if (!toState.name.startsWith("main.crudlist")) {
                         //to avoid strange transitions on the screen
                         //TODO: transition finished event??
                         $timeout(() => $scope.disableSearch(), 500);
                     } else {
                         init();
                         loadingService.hide();
                     }
                 });

            $scope.$on(routeConstants.events.sameStateTransition, (event, state) => {
                $log.get("crudlist#statehandler").debug("handler called", arguments);
                if (!state.name.startsWith("main.crudlist")) return;
                init();
            });

            $scope.loadMore = function () {
                const log = $log.get("crudListController#loadMore");
                log.debug("fetching more items");
                crudContextService.loadMorePromise().then(results => {
                    $scope.$broadcast('scroll.infiniteScrollComplete');
                    $scope.crudlist.items = $scope.crudlist.items.concat(results);
                    $scope.crudlist.moreItemsAvailable = results.length > 0;
                });
            }

        }]);

})(softwrench);
;
(function (softwrench, _) {
    "use strict";

    softwrench.controller("CrudTabController", ["$scope", "$rootScope", "$log", "crudContextService", "crudContextHolderService", "schemaService", "inlineCompositionService",
        function ($scope, $rootScope, log, crudContextService, crudContextHolderService, schemaService, inlineCompositionService) {

            function init() {
                log.get("crud_tab#init").debug("crud tab init");
                const crudContext = crudContextHolderService.getCrudContext();
                $scope.tab = crudContext.composition.currentTab;
                $scope.tabAllDisplayables = schemaService.nonTabFieldsFromDisplayables($scope.tab.displayables);
                $scope.tabDisplayables = $scope.tabAllDisplayables;

                if (!$scope.tabInlineCompositionsLoaded) {
                    $scope.tabInlineCompositionsLoaded = true;
                    inlineCompositionService.loadInlineCompositions($scope.item, $scope.datamap, $scope.tabAllDisplayables, $scope.tab.id);
                }
            }

            $scope.$on('sw_cruddetailrefreshed', function () {
                //                $scope.datamap = crudContextService.currentDetailItemDataMap();
                $scope.tabInlineCompositionsLoaded = false;
                init();
            });


            init();
        }]);
})(softwrench, _);



;
(function (softwrench) {
    "use strict";

    softwrench.controller("CrudListSearchController", ["$log", "$scope", "crudContextHolderService", "crudContextService", "routeService", "crudSearchService", 
        function ($log, $scope, crudContextHolderService, crudContextService, routeService, crudSearchService) {

            // the search state before enter the search scheen
            // used in case the user cancels the search and the previous
            // data should be recoverd
            var auxSearchValues = {};
            var auxSort = {};

            //#region aux functions

            // used to convert date back from string on the aux JSON.stringfy -> JSON.parse 
            function dateTimeReviver(key, value) {
                if ((key !== "start" && key !== "startUTC" && key !== "end" && key !== "endUTC") || typeof value !== "string") {
                    return value;
                }
                return new Date(value);
            }

            // workaround to force UTC date on sort and search
            function searchDateChanged(field, start) {
                const searchValue = $scope.gridSearch.searchValues[field.value];
                if (!searchValue) {
                    return;
                }
                const dateValue = searchValue[start ? "start" : "end"];
                if (!dateValue) {
                    searchValue[start ? "startUTC" : "endUTC"] = null;
                    return;
                }

                searchValue[start ? "startUTC" : "endUTC"] = new Date(Date.UTC(dateValue.getFullYear(), dateValue.getMonth(), dateValue.getDate()));
            }
            //#endregion

            // clears all search fields
            $scope.clear = function () {
                crudSearchService.clearGridSearchValues();
            }

            $scope.cancel = function () {
                // reverts to the previous state
                $scope.gridSearch.searchValues = auxSearchValues;
                $scope.gridSearch.sort = auxSort;
                auxSearchValues = {};
                auxSort = {};
                routeService.go("^");
            }

            // do search
            $scope.apply = function () {
                crudContextService.refreshGrid();
            }

            $scope.sortChanged = function (newValue) {
                $scope.gridSearch.sort = $scope.gridSearch.sortables[newValue];
            }

            $scope.searchDateStartChanged = function (field) {
                searchDateChanged(field, true);
            }

            $scope.searchDateEndChanged = function (field) {
                searchDateChanged(field, false);
            }

            $scope.searchFieldLabel = function (field) {
                return field.label || field.value;
            }

            $scope.sortFieldLabel = function () {
                if (!$scope.gridSearch.sort) {
                    return null;
                }
                return $scope.gridSearch.sort.label || $scope.gridSearch.sort.value;
            }

            $scope.getSearchType = function (field) {
                if (field.type === "MetadataDateTimeFilter") {
                    return "date";
                }
                if (field.type === "MetadataOptionFilter") {
                    return "option";
                }
                if (field.dataType === "date") {
                    return "date";
                }
                return "default";
            }

            $scope.searchValue = function (field) {
                return $scope.gridSearch.searchValues[field.value];
            }

            $scope.init = function () {
                $scope.gridSearch = crudContextHolderService.getGridSearchData();

                // saves the initial state in case of cancel
                auxSearchValues = JSON.parse(JSON.stringify($scope.gridSearch.searchValues), dateTimeReviver);
                auxSort = JSON.parse(JSON.stringify($scope.gridSearch.sort));

                $scope.gridSearch = crudSearchService.initGridSearch();
            }

            $scope.init();
        }]);

})(softwrench);;
(function (softwrench) {
    "use strict";

    softwrench.controller('FilterOptionController', ["$log", "$scope", "$ionicScrollDelegate", "crudContextService", "crudFilterContextService",
        function ($log, $scope, $ionicScrollDelegate, crudContextService, crudFilterContextService) {

    $scope.showpending = crudFilterContextService.showPending();
    $scope.showdirty = crudFilterContextService.showDirty();
    $scope.showproblems = crudFilterContextService.showProblems();

    $scope.changePending = function () {
        $scope.showpending = !$scope.showpending;
        crudFilterContextService.showPending($scope.showpending);
        crudContextService.refreshGrid();
    }

    $scope.changeDirty = function () {
        $scope.showdirty = !$scope.showdirty;
        crudFilterContextService.showDirty($scope.showdirty);
        crudContextService.refreshGrid();
    }

    $scope.changeProblem = function () {
        $scope.showProblems = !$scope.showProblems;
        crudFilterContextService.showProblems($scope.showProblems);
        crudContextService.refreshGrid();
    }

}]);

})(softwrench);



;
(function (softwrench) {
    "use strict";

    softwrench.controller('GridItemPopOverController', ["$log", "$scope", "synchronizationFacade", "crudContextService", "itemActionService", "$ionicPopup", "menuModelService", "alertService", "routeService", "loadingService",
        function ($log, $scope, synchronizationFacade, crudContextService, itemActionService, $ionicPopup, menuModelService, alertService, routeService, loadingService) {


            $scope.quicksync = function () {
                const item = crudContextService.getCrudContext().currentPopOverItem;
                if (!item.isDirty) {
                    return;
                }
                return synchronizationFacade.syncItem(item).then(() => {

                    // was called from a composition tab on detail
                    // resets state first
                    if (!crudContextService.isOnMainTab()) {
                        crudContextService.resetTab();
                        routeService.go("main.cruddetail.maininput");
                    }

                    menuModelService.updateAppsCount();
                    //updating the item on the list after it has been synced
                    crudContextService.refreshGrid();
                }).catch(function (error) {
                    synchronizationFacade.handleError(error);
                }).then(r => {
                    $ionicPopup.alert({
                        title: "Quick Sync",
                        template: alertService.buildCenteredTemplate("Sync Successful")
                    });
                }).finally(() => {
                    loadingService.hide();
                    $scope.$emit("sw_griditemoperationperformed");
                });
            }


            $scope.restorestate = function () {
                const item = crudContextService.getCrudContext().currentPopOverItem;
                return itemActionService.deleteOrRestoreItem(item)
                    .then(res => res ? crudContextService.refreshGrid() : null)
                    .finally(() => {
                        $scope.$emit("sw_griditemoperationperformed");
                    });
            };



        }]);

})(softwrench);



;
(function(app) {
    "use strict";

    app.controller('LoginController', ["$scope", "swAlertPopup", "routeService", "securityService", "$timeout", "$stateParams", "loadingService", "settingsService", "dynamicScriptsCacheService",
    function ($scope, swAlertPopup, routeService, securityService, $timeout, $stateParams, loadingService, settingsService, dynamicScriptsCacheService) {

            $scope.data = {};

            var showAlert = function(title, message) {
                swAlertPopup.show({
                    title: title,
                    template: message
                });
            }

            const showMessage = function() {
                const message = $stateParams.message;
                if (!!message) {
                    showAlert("Attention", message);
                }
            };

            $scope.login = function (username, password) {
                loadingService.showDefault();

                if (!!username) {
                    $scope.data.username = username;
                }

                if (!!password) {
                    $scope.data.password = password;
                }

                securityService.login($scope.data.username, $scope.data.password)
                    .then(function (data) {
                        routeService.go('main.home');
                        //enforcing SWOFF-93
                        $scope.data = {};
                        dynamicScriptsCacheService.clearEntries();
                    })
                    .catch(function (error) {
                        securityService.logout();
                        showAlert("Login failed", !!error && !!error.message ? error.message : "Please check your credentials.");
                    })
                    .finally(function() {
                        loadingService.hide();
                    });
            };

            $scope.viewSettings = function() {
                routeService.go("settings");
            };

            $scope.getIsDemoMode = function () {
                settingsService.getServerUrl().then(function (url) {
                    $scope.isDemoMode = url.indexOf('demo.softwrench.net') > 0;   
                });
            }

            $scope.$on('$stateChangeSuccess', function (event, toState, toParams, fromState, fromParams) {
                 $timeout(function () {
                     $scope.getIsDemoMode();
                 });
             });

            // init
            $timeout(showMessage);
            $scope.getIsDemoMode();
        }
    ]);

})(softwrench);;
(function (softwrench) {
    "use strict";

    softwrench.controller('MainController', ["$scope", "$ionicSideMenuDelegate", "crudContextService",
        function ($scope, $ionicSideMenuDelegate, crudContextService) {

            $scope.data = {};
           
            function init() {
                if (isRippleEmulator()) {
                    $("body").addClass("ripple");
                }
            }

            $scope.isList = function () {
                return crudContextService.isList();
            };

            $scope.toggleLeft = function () {
                $ionicSideMenuDelegate.toggleLeft();
            };

            $scope.closeMenu= function () {
                $ionicSideMenuDelegate.toggleLeft();
            };

            $scope.title = function () {
                return crudContextService.currentTitle();
            };
            

            init();


        }]);

})(softwrench);


;
(function (softwrench) {
    "use strict";

    window.MultiAssetController = function ($log, $scope, $q, crudContextHolderService, offlineAssociationService, inlineCompositionService) {

        const multiAssetLog = $log.get("multiasset");

        const crudContext = crudContextHolderService.getCrudContext();
        const multiAssetTab = crudContext.composition.currentTab;

        angular.forEach(multiAssetTab.displayables, function (d) {
            if (d.relationship === "multiassetlocci_") {
                $scope.fieldMetadata = d;
            }
        });

        $scope.detailSchema = $scope.fieldMetadata.schema.schemas.detail;
        $scope.associationData = {};
        $scope.loaded = false;

        function setIonicPaneDivHeight(height) {
            const fullheight = (height + 13) + "px"; // 13 = margins, paddings and borders
            $("[state='main.cruddetail.tab']").css("height", fullheight);
        }

        function load() {
            multiAssetLog.debug("loading multiassets");
            $scope.loaded = false;
            setIonicPaneDivHeight(100); // 100 = loading height
            const dm = crudContextHolderService.currentDetailItemDataMap();
            $scope.multiassets = dm["multiassetlocci_"] || [];
            $scope.associationData = {};
            const promisses = [];
            angular.forEach($scope.multiassets, (multiasset) => {
                const associationDataEntry = {};
                promisses.push(loadAsset(multiasset, associationDataEntry));
                associationDataEntry["offlinelocation_"] = multiasset["location"];
                $scope.associationData[multiasset["multiid"]] = associationDataEntry;
            });
            $q.all(promisses).then(() => {
                if ($scope.multiassets && $scope.multiassets.length > 0) {
                    setIonicPaneDivHeight(75 * $scope.multiassets.length); // 75 = row height
                } else {
                    setIonicPaneDivHeight(16); // 16 = no records message height
                }
                $scope.loaded = true;
            }).catch((e) => console.log(e));
        }

        load();

        function loadAsset(parentDatamap, associationDataEntry) {
            const assetNum = parentDatamap["assetnum"];
            associationDataEntry["offlineasset_"] = assetNum;
            if (!assetNum) {
                return $q.when(null);
            }
            return offlineAssociationService.filterPromise($scope.detailSchema, parentDatamap, "offlineasset_", `"assetnum":"${assetNum}"`, null, true).then((assocs) => {
                associationDataEntry["assetdescription"] = assocs && assocs[0] ? assocs[0].datamap["description"] : null;
            });
        }

        $scope.$on(inlineCompositionService.compositionLoadedEventName(), (event, tabid) => load());

        $scope.toggleProcess = function (multiasset) {
            multiasset.progress = multiasset.progress ? 0 : 1;
            multiasset["#isDirty"] = "true";
        }
    }

    softwrench.controller("MultiAssetController", ["$log", "$scope", "$q", "crudContextHolderService", "offlineAssociationService", "inlineCompositionService", window.MultiAssetController]);
})(softwrench);;
(function (softwrench) {
    "use strict";

    softwrench.controller("SettingsController", ["$scope", "routeService", "securityService", "applicationStateService", "settingsService", "offlinePersitenceBootstrap",
        function ($scope, routeService, securityService, applicationStateService, settingsService, offlinePersitenceBootstrap) {

            $scope.config = null;

            function init() {
                settingsService.getSettings()
                    .then(settings => {
                        $scope.settings = settings || {};
                        if (!$scope.settings.serverurl) {
                            $scope.settings.serverurl = "http://";
                        }
                        return applicationStateService.getAppConfig();
                    })
                    .then(result => {
                        $scope.config = result;
                        var idx;
                        if ($scope.config.client && (idx = $scope.config.client.version.indexOf("#")) > 0) {
                            //jenkins would append the commit number after a hash
                            //implmentation of SWOFF-130, there was no suitable plugins to read the preferences inside the config.xml
                            const originalVersion = $scope.config.client.version;
                            $scope.config.client.version = originalVersion.substring(0, idx);
                            $scope.config.client.commit = originalVersion.substring(idx + 1);
                        } 
                    });
            }

            $scope.goToLogin = function () {
                routeService.go("login");
            };

            $scope.saveDemo = function () {
                $scope.settings.serverurl = 'http://demo.softwrench.net/';
                $scope.save();
            }

            $scope.save = function () {
                if (!$scope.settings.serverurl.startsWith("http")) {
                    $scope.settings.serverurl = `http://${$scope.settings.serverurl}`;
                }

                settingsService.saveSettings($scope.settings).then(settings => {
                    // if has an authenticated user go to 'home' (just editting settings)
                    // otherwise go to 'login'
                    const next = securityService.hasAuthenticatedUser() ? "main.home" : "login";
                    routeService.go(next);
                });                                   
            }

            offlinePersitenceBootstrap.addPersistenceReadyListener({
                persistenceReady : function() {
                    init();
                }
            });
        }]);

})(softwrench);
;
(function (angular) {
    "use strict";

    angular.module("softwrench")
        .controller("SupportController", ["$scope", "supportService", "$ionicPopup", "dynamicScriptsCacheService", "securityService", "routeService", "swdbDAO", "$log", "$roll", function ($scope, supportService, $ionicPopup, dynamicScriptsCacheService, securityService, routeService, swdbDAO, $log, $roll) {

            const log = $log.get("SupportController");

            $scope.vm = {
                loglevel: sessionStorage["loglevel"] || "WARN",
                sqlClientCollapsed: true,
                logFileCollapsed:true
            }

            $scope.toggleSQLClientState = function() {
                $scope.vm.sqlClientCollapsed = !$scope.vm.sqlClientCollapsed;
            }

            $scope.toggleLogFile = function () {
                $scope.vm.logFileCollapsed = !$scope.vm.logFileCollapsed;
                if (!$scope.vm.logFileCollapsed) {
                    $roll.readCurrent().then(filecontent => {
                        $scope.vm.logoutput = filecontent;
                    });
                }
            }

            $scope.changeloglevel = function (callback) {
                sessionStorage.loglevel = callback.item.value;
                if (callback.item.value.equalIc('debug')) {
                    persistence.debug = true;
                    $scope.vm.logsql = true;
                } else {
                    persistence.debug = false;
                }
            }

            $scope.changeLogSQl = function (){
                persistence.debug = $scope.vm.logsql;
            }

            $scope.sendLogFiles = function() {
                supportService.getLogReportingModal(false).then(modal => {
                    modal.show();
                });
            };

            $scope.reset = function () {
                const confirm = $ionicPopup.confirm({
                    title: "Reset configurations",
                    template: `Are you sure that you want to reset configurations? All non synchronized work will be lost`
                });
                return confirm.then(res => {
                    dynamicScriptsCacheService.clearEntries();
                    window.location.reload(true);
                    securityService.logout(true).then(() => {
                        return routeService.go("login");
                    }).then(l => {

                    });
                });
                supportService.requestLogReporting();
            };

            $scope.queryModel = {};
            $scope.queryModel.sqlQuery = "";
            $scope.queryModel.limitRows = true;
            $scope.queryModel.limitRowsSize = 10;
            $scope.queryModel.resultMessage = "";
            $scope.queryModel.resultMessageStyle = { color: "green" };

            const formatQuerySuccess = function(query, result) {
                let msg = "";
                msg += `Query (${query}) run with success`;
                if (!result || !result.length) {
                    msg += ".";
                    return msg;
                }

                msg += ":\n";
                angular.forEach(result, (row) => {
                    msg += JSON.stringify(row) + "\n";
                });
                return msg;
            }

            const formatQueryError = function (query, err) {
                let msg = "";
                msg += `Query (${query}) run with error.`;
                return msg;
            }

            $scope.runSQL = function () {
                if (!$scope.queryModel.sqlQuery) {
                    return;
                }

                const query = $scope.queryModel.sqlQuery.trim();
                swdbDAO.executeQuery(query).then((result) => {
                    $scope.queryModel.resultMessageStyle.color = "green";
                    if (query.toLowerCase().startsWith("select")) {
                        $scope.queryModel.resultMessage = `${result.length} results found.`;
                    } else {
                        $scope.queryModel.resultMessage = "Success.";
                    }
                    log.warn(formatQuerySuccess(query, result));
                }, (err) => {
                    $scope.queryModel.resultMessageStyle.color = "red";
                    $scope.queryModel.resultMessage = `Error: ${err}.`;
                    log.error(formatQueryError(query, err));
                });
            }
        }]);

})(angular);;
(function (softwrench) {
    "use strict";

    softwrench.controller("SyncOperationDetailController",
        ["$scope", "synchronizationOperationService", "contextService", "routeService","securityService", "synchronizationFacade", "swAlertPopup", "$stateParams", "$ionicHistory", "applicationStateService", "$q", "$timeout", "$ionicPopup",
            "$ionicScrollDelegate", "loadingService", "attachmentDataSynchronizationService", "metadataModelService", "menuModelService", "offlineSchemaService", "crudContextService", "crudContextHolderService", "indexCreatorService", "swdbDAO", "networkConnectionService",
            function ($scope, service, contextService, routeService, securityService, synchronizationFacade, swAlertPopup, $stateParams, $ionicHistory, applicationStateService, $q, $timeout, $ionicPopup, $ionicScrollDelegate, loadingService, attachmentDataSynchronizationService, metadataModelService, menuModelService, offlineSchemaService, crudContextService, crudContextHolderService, indexCreatorService, swdbDAO, networkConnectionService) {

                $scope.data = {
                    operation: null,
                    batchItems: [],
                    isLatestOperation: !$stateParams.id,
                    isSynching: false,
                    currentApplicationState: null,
                    applicationStateCollapsed: true
                }


                var loadSyncOperation = function () {
                    var loadPromise = $scope.data.isLatestOperation ? service.getMostRecentOperation() : service.getOperation($stateParams.id);
                    return loadPromise.then(function (operation) {
                        if (!operation) return operation;
                        $scope.data.operation = operation;
                        return service.getBatchItems(operation);
                    }).then(function (items) {
                        if (!items) return items;
                        return items.map(function (item) {
                            if (item.problem) {
                                item.simpleproblem = { message: item.problem.message };
                            }
                            return item;
                        });
                    }).then(function (items) {
                        $scope.data.batchItems = items;
                    });
                };

                var loadCurrentApplicationState = function () {
                    return applicationStateService.currentApplicationsState().then(function (state) {
                        $scope.data.currentApplicationState = state;
                        angular.forEach(state.applications, appState => {
                            const appMetadata = metadataModelService.getApplicationByName(appState.application);
                            const gridSchema = offlineSchemaService.locateSchema(appMetadata, "list");
                            appState.gridTitle = gridSchema ? crudContextService.gridTitle(gridSchema) : appState.application;
                        });
                    });
                };

                var loadData = function (initial) {
                    const isFirstSyncPromise = !initial ? $q.when(false) : synchronizationFacade.isFirstSync();
                    return isFirstSyncPromise.then(value => {
                        if (value) {
                            //registering first sync call automatically
                            return $timeout(() => {
                                $scope.fullSynchronize(true);
                            }, 0, false);
                        } else {
                            loadingService.showDefault();
                            const operationPromise = loadSyncOperation();
                            const currentStatePromise = loadCurrentApplicationState();
                            return $q.all([operationPromise, currentStatePromise])
                                .finally(function () {
                                    if (!!initial) {
                                        loadingService.hide();
                                    }
                                });
                        }
                    });

                };

                $scope.goToHistory = function () {
                    routeService.go("main.syncoperationhistory");
                };

                $scope.goBack = function () {
                    $ionicHistory.goBack();
                };

                $scope.solveProblems = function () {
                    // TODO: resubmit $scope.operation's Batches
                };

                $scope.reset = function () {
                    if (networkConnectionService.isOffline()) {
                        swAlertPopup.show({
                            title: "error",
                            template: "No internet connection detected. Cannot perform the reset operation"
                        });
                        return;
                    }


                    return $ionicPopup.confirm({
                        title: "Reset",
                        template: [
                            "All unsaved data will be lost",
                            "Proceed anyway?",
                        ].join(" ")
                    }).then((confirmed) => {
                        if (confirmed) {
                            return securityService.logout(false,false);    
                        }
                        return $q.reject();
                    }).then(() => $scope.fullSynchronize());
                }


                $scope.innerFullSynchronize = function() {
                    $scope.data.isSynching = true;
                    loadingService.showDefault();

                    // clears grid search data to consider changes on the metadata
                    crudContextHolderService.clearGridSearch();

                    let needFullResync = false;
                    return synchronizationFacade.fullSync()
                        .then(function (operation) {
                            return synchronizationFacade.shouldFullResync().then((needsResync) => {
                                needFullResync = needsResync;
                                if (!needFullResync) {
                                    swAlertPopup.show({
                                        title: "Synchronization Succeeded" //TODO: maybe create a message for the popup?
                                    });
                                }
                            }).then(() => loadData());
                        })
                        .catch(function (error) {
                            synchronizationFacade.handleError(error);
                        })
                        .finally(function () {
                            $scope.data.isSynching = false;
                            loadingService.hide();
                            attachmentDataSynchronizationService.downloadAttachments();
                            indexCreatorService.createIndexAfterFirstSync();
                            menuModelService.updateAppsCount();
                            if (!!contextService.get("restartneeded")) {
                                //only if there are dynamic scripts loaded
                                contextService.deleteFromContext("restartneeded");
                                window.restartApplication();
                                return;
                            }
                        }).then(() => needFullResync ? securityService.logout(false, false) : $q.reject()).then(() => $scope.innerFullSynchronize());
                }

                $scope.fullSynchronize = function () {
                    synchronizationFacade.shouldFullResync(true).then((needsResync) => {
                        if (needsResync) {
                            return securityService.logout(false, false).then(() => $scope.innerFullSynchronize());
                        }
                        return $scope.innerFullSynchronize();
                    });
                };

                $scope.toggleApplicationStateCollapsed = function () {
                    $scope.data.applicationStateCollapsed = !$scope.data.applicationStateCollapsed;
                    if ($scope.data.applicationStateCollapsed) {
                        $ionicScrollDelegate.scrollTop(true);
                    } else {
                        $ionicScrollDelegate.scrollBottom(true);
                    }
                }

                // initialize
                loadData(true);

            }]);

})(softwrench);;
(function (softwrench) {
    "use strict";

    softwrench.controller("SyncOperationHistoryController",
        ["$scope", "synchronizationOperationService", "routeService",
        function($scope, synchronizationOperationService, routeService) {

            $scope.operationList = [];

            $scope.paginationData = {
                currentPage: 1,
                pageSize: 10,
                hasMoreAvailable: true
            };

            $scope.goBack = function () {
                routeService.go("main.home");
            };

            $scope.openDetail = function(operation) {
                routeService.go("main.syncoperationdetail", { id: operation.id });
            };

            // infinite scroll
            $scope.loadPagedList = function () {
                synchronizationOperationService.getSyncList($scope.paginationData.currentPage)
                    .then(function (operations) {
                        // update pagination data
                        $scope.paginationData.hasMoreAvailable = (operations && operations.length >= $scope.paginationData.pageSize);
                        $scope.paginationData.currentPage += 1;
                        // update list
                        $scope.operationList = $scope.operationList.concat(operations);
                    })
                    .finally(function () {
                        $scope.$broadcast('scroll.infiniteScrollComplete');
                    });
            };
        }
    ]);

})(softwrench);;
(function (mobileServices, angular, _) {
    "use strict";

    function applicationStateService(dao, $q, entities, configurationService, $cordovaAppVersion, settingsService, securityService, $cordovaDevice) {

        //#region Utils

        const countAll = app => dao.countByQuery("DataEntry", `application='${app}'`);

        const countPending = app => dao.countByQuery("DataEntry", `application='${app}' and pending = 1`);

        const countDirty = app => dao.countByQuery("DataEntry", `application='${app}' and isDirty=1 and (hasProblem = 0 or hasProblem is null)`);

        const countProblematic = app => dao.countByQuery("DataEntry", `application='${app}' and hasProblem = 1`);

        function associationState() {
            return dao.findByQuery("Application", "association=1")
                .then(r => r.map(a => ({
                    name: a.application, title: a.data.title
                })))
                .then(a => {
                    const titleLookupTable = _.indexBy(a, "name");
                    return dao.executeStatement("select application,count(id) from AssociationData group by application")
                        .then(c => c
                            //excluding applications which are not present. TODO: delete them. Scenario, removing a profile from an existing user
                            .filter(i => titleLookupTable[i.application])
                            .map(i => ({ application: i.application, count: i["count(id)"], title: titleLookupTable[i.application].title })));
                });
        }

        function topLevelApplicationState() {
            return dao.findByQuery("Application", "composition=0 and association=0")
                .then(results => {
                    const apps = results.map(app => app.application);

                    const promises = apps.map(app => {
                        const countPromises = [
                            countAll(app), // all
                            countPending(app), // pending
                            countDirty(app), // dirty
                            countProblematic(app) // problematic
                        ];

                        return $q.all(countPromises)
                            .spread((all, pending, dirty, problematic) => ({
                                application: app,
                                all,
                                pending,
                                dirty,
                                problematic
                            }));
                    });
                    return $q.all(promises);
                });
        }

        const stateResolver = {
            settings() {
                return settingsService.getSettings().then(s => _.pick(s, "serverurl"));
            },
            configs() {
                return getAppConfig();
            },
            applications() {
                return currentApplicationsState();
            },
            user() {
                const user = securityService.currentFullUser();
                return $q.when(user);
            },
            device() {
                const device = _.pick($cordovaDevice.getDevice(), "platform", "version", "model");
                return $q.when(device);
            }
        }

        //#endregion

        //#region Public methods

        /**
         * Fetches the status of each 'top level' application and each association in the system and groups them:
         * { 
         * applications: [{ 
         *      application: String, // application's name 
         *      all: Integer, // count of all entities
         *      pending: Integer, // count of pending entities 
         *      dirty: Integer, // count of all dirty entities (just dirty, not including problematic)
         *      problematic: Integer, // count of problematic entities 
         *  }],
         *  associations: [{
         *      application: String, // application's name
         *      title: String, // application's title
         *      count: Integer, // count of all associations
         *  }]
         * }
         * 
         * @returns Promised resolved with array of each application's states 
         */
        function currentApplicationsState() {
            return $q.all([topLevelApplicationState(), associationState()])
                .spread((applications, associations) => ({ applications, associations }));
        }

        /**
         * Fetches the app's configuration (server and client info).
         * 
         * @returns Promise resolved with dictionary containing 'server' and 'client' configuration (both are dictionaries) 
         */
        function getAppConfig() {
            const serverConfigPromise = configurationService.getConfig("serverconfig");
            const clientVersionPromise = isRippleEmulator() ? $q.when("Ripple") : $cordovaAppVersion.getVersionNumber();
            return $q.all([serverConfigPromise, clientVersionPromise])
                .spread((serverConfig, appVersion) => ({
                    'server': serverConfig,
                    'client': { 'version': appVersion }
                })
                );
        }

        /**
         * Resolves the states of the app (e.g. logged user, settings, configs, application state, device info) 
         * passed as parameter.
         * 
         * @param {Array<String>} states possible values are "settings"|"configs"|"user"|"device"|"applications"
         * @returns {Promise<Object>} state 
         */
        function getStates(states) {
            if (!angular.isArray(states) || states.length <= 0) return $q.when();
            const promises = [];
            angular.forEach(states, state => {
                const resolver = stateResolver[state];
                if (!resolver || !angular.isFunction(resolver)) return;
                // state value indexed by it's name
                const promise = resolver().then(result => ({ state, result }));
                promises.push(promise);
            });
            if (promises.length <= 0) return $q.when();
            return $q.all(promises).then(result => {
                const fullState = {};
                // build object { <state_name>: <state_value> }
                angular.forEach(result, (value) => {
                    fullState[value.state] = value.result;
                });
                return fullState;
            });
        }

        function getServerDeviceData() {
            return this.getStates(["configs", "device"]).then(state => {
                const deviceData = state.device;
                deviceData["clientVersion"] = state.configs.client.version;
                return deviceData;
            });
        }

        /**
         * Resolves all possible states of the app
         * @see #getStates
         * @returns {Promise<Object>} complete state
         */
        function getFullState() {
            return getStates(Object.keys(stateResolver));
        }

        //#endregion

        //#region Service Instance
        const service = {
            currentApplicationsState,
            getAppConfig,
            getStates,
            getServerDeviceData,
            getFullState
        };
        return service;
        //#endregion
    }

    //#region Service registration

    mobileServices.factory("applicationStateService",
        ["swdbDAO", "$q", "offlineEntities", "configurationService", "$cordovaAppVersion", "settingsService", "securityService", "$cordovaDevice", applicationStateService]);

    //#endregion

})(mobileServices, angular, _);
;
(function (mobileServices, angular) {
    "use strict";

    mobileServices.factory("configurationService", ["$http", "$log", "$q", "swdbDAO", "contextService", "settingsService",
    function ($http, $log, $q, swdbDAO, contextService, settingsService) {

        function updateConfigurationContext(configs) {
            angular.forEach(configs, config => {
                contextService.insertIntoContext(config.key, config.value);
                if (config.key === "serverconfig") {
                    //adapting so that we can use the same contextService.isDev() here
                    contextService.set("environment", config.value.environment);
                }
            });
            return configs;
        }

        /**
         * Load client based configs
         */
        function loadClientConfigs() {
            return settingsService.initializeSettings();
        }

        /**
         * Load server based configs
         */
        function loadConfigs() {
            return swdbDAO.findAll("Configuration").then(updateConfigurationContext);
        }

        function saveConfigs(configs) {
            const entitiesPromises = configs.map(config => swdbDAO.instantiate("Configuration", config));
            return $q.all(entitiesPromises)
                .then(result => swdbDAO.bulkSave(result))
                .then(updateConfigurationContext);
        };

        function saveConfig(config) {
            return getFullConfig(config.key).then(dbConfig => {
                if (dbConfig != null) {
                    dbConfig.key = config.key;
                    dbConfig.value = config.value;
                }
                return dbConfig ? dbConfig : swdbDAO.instantiate("Configuration", config);
            }).then(toSaveConfig => swdbDAO.save(toSaveConfig));
        }

        /**
         * Finds the Configuration with matching key.
         * 
         * @param String key 
         * @returns Promise resolved with the Configuration's value if it was found, null otherwise 
         */
        function getConfig(key) {
            return swdbDAO.findSingleByQuery("Configuration", `key='${key}'`).then(config => !config ? null : config.value);
        }

        /**
         * Finds the Configuration with matching key.
         * 
         * @param String key 
         * @returns Promise resolved with the Configuration's if it was found, null otherwise 
         */
        function getFullConfig(key) {
            return swdbDAO.findSingleByQuery("Configuration", `key='${key}'`).then(config => !config ? null : config);
        }

        const api = {
            loadConfigs,
            loadClientConfigs,
            saveConfigs,
            saveConfig,
            getConfig,
            getFullConfig
        };
        return api;

    }]);

})(mobileServices, angular);;
(function (mobileServices) {
    "use strict";

    function settingsService(localStorageService, dao, $q) {
        //#region Utils
        var config = {
            storageNamespace: "settings:"
        }
        function key(str) {
            return config.storageNamespace + str;
        }
        function cacheSettings(settings) {
            if (!settings) {
                return settings;
            }
            localStorageService.put(key("settings"), settings);
            if(!!settings.serverurl) localStorageService.put(key("serverurl"), settings.serverurl);
            return settings;
        }
        //#endregion

        //#region Public methods
        /**
         * Finds the saved Settings entity
         * (uses localStorage as cache for performance).
         * 
         * @returns Promise resolved with the saved Settings entity
         */
        function getSettings() {
            const settings = localStorageService.get(key("settings"));
            return !!settings
                // resolve immediately on cache hit
                ? $q.when(settings)
                // fetch from DB on cache miss and cache result
                : dao.findSingleByQuery("Settings", null).then(cacheSettings); 
        }

        function getServerUrl() {
            return getSettings().then(settings => settings.serverurl);
        }

        function getClient(){
            return getSettings().then(settings => settings.server.client);
        }

        /**
         * Saves the settings as Settings entity to local database 
         * (uses localStorage as cache for performance).
         * 
         * @param {} settings 
         * @returns Promise resolved with the saved Settings entity 
         */
        function saveSettings(settings) {
            return dao.instantiate("Settings", settings)
                .then(settingsInstance => dao.save(settingsInstance))
                .then(cacheSettings);
        }

        /**
         * Checks the database for a saved Settings entry.
         * If there are none save an empty entry and resolve with it.
         * Otherwise resolve with the entry found.
         * 
         * @returns Promise resolved with saved Settings entity
         */
        function initializeSettings() {
            return dao.findAll("Settings").then(function(settings) {
                return settings.length <= 0
                    ? saveSettings(null) // save 'empty' Settings to DB and cache it
                    : cacheSettings(settings[0]); // already has an entry -> just cache it
            });
        }
        //#endregion

        //#region Service Instance
        const service = {
            getSettings,
            getClient,
            getServerUrl,
            saveSettings,
            initializeSettings
        };
        return service;
        //#endregion
    }

    //#region Service registration
    mobileServices.factory("settingsService", ["localStorageService", "swdbDAO", "$q", settingsService]);
    //#endregion

})(mobileServices);
;
(function (angular, cordova, _) {
    "use strict";

    function supportService($q, applicationStateService, $roll, $cordovaFile, $cordovaEmailComposer, networkConnectionService, $ionicPopup, $ionicModal, $rootScope, dao) {
        //#region Utils

        const config = {
            logs: {
                emailTo:"support@controltechnologysolutions.com",
                emailConfigKey: "/Offline/Support/Email",
                modalTemplateUrl: "Content/Mobile/templates/support_reportlog_modal.html",
                popup: {
                    title: "Log Reporting", 
                    template: "Do you wish to report to the support team"
                },
                ongoing: false
            }
        };

        /**
         * @returns {Promise<Array<String>>} absolute url of the log files
         */
        function getLogFiles() {
            return $cordovaFile.listDir(cordova.file[$roll.config.directory])
                .then(entries => 
                    entries
                        .filter(e => e.isFile && e.name.startsWith($roll.config.prefix)) // only files that are log files
                        .map(f => f.nativeURL) // absolute path
                );
        }

        function objectToHtml(object) {
            var html = "<ul>";
            angular.forEach(object, (value, key) => {
                if (angular.isFunction(value)) return;
                var valueHtml = value;
                if (!value) {
                    valueHtml = String(value);
                } else if (angular.isArray(value)) {
                    valueHtml = value.toString();
                }
                html += `<li>${key}: ${valueHtml}</li>`;
            });
            html += "</ul>";
            return html;
        }

        function stateToHtml(state) {
            var html = "";
            angular.forEach(state, (value, key) => {
                var valueHtml = "";
                if (key === "user") {
                    valueHtml += "<div>";
                    valueHtml += objectToHtml(_.omit(value, "meta", "properties"));
                    valueHtml += `<b>user.properties</b><br>${objectToHtml(value.properties)}`;
                    valueHtml += "</div>";
                } else if (key === "configs") {
                    valueHtml += "<div>";
                    valueHtml += `<b>configs.server</b><br>${objectToHtml(value.server)}`;
                    valueHtml += `<b>configs.client</b><br>${objectToHtml(value.client)}`;
                    valueHtml += "</div>";
                } else {
                    valueHtml = objectToHtml(value);
                }
                html += `<div><b>${key}</b><br><div>${valueHtml}</div></div>`;
            });
            return html;
        }

        function buildReportEmailMessage(state, userMessage) {
            const user = state.user;
            var message = `<div>softWrench Log Reporting from <b>${user.UserName}</b></div><br>`;
            if (userMessage) {
                message += `<div>${user.UserName} included the following message:<br>${userMessage}</div><br>`;
            }
            const stateHtml = stateToHtml(state);
            message += `
                <div>
                    <h3>Application state during the report<h3>
                    ${stateHtml}
                </div><br>`;
            message += "The log files are attached";
            return message;
        }

        function getSupportEmail() {
            return dao.findSingleByQuery("DataEntry", `application='_configuration' and datamap like '%"fullKey":"${config.logs.emailConfigKey}"%'`)
                .then(emailConfig => {
                    if (!emailConfig) {
                        return config.logs.emailTo;
                    }
                    const datamap = emailConfig.datamap;
                    return datamap.stringValue || datamap.defaultValue || config.logs.emailTo;
                });
        }

        function buildReportEmail({ subject = "", message = "" } = {}) {
            const promises = [
                applicationStateService.getStates(["settings", "configs", "user", "device"]),
                getLogFiles(),
                getSupportEmail()
            ];
            return $q.all(promises).spread((state, logs, supportEmail) => {
                const customer = state.configs.server.client.toUpperCase();
                var mailSubject = `[${customer}][SWOFF][LOG]`;
                if (subject) mailSubject += ` ${subject}`;
                
                const mailMessage = buildReportEmailMessage(state, message);
                const userMail = state.user.Email;
                
                const email = {
                    to: [supportEmail],
                    cc: [userMail],
                    subject: mailSubject,
                    body: mailMessage,
                    isHtml: true,
                    attachments: logs
                };
                return email;
            });
        }

        function getLogReportingModal(logreporting = true) {
            // create an isolated $scope to hold the viewmodel
            const $scope = $rootScope.$new(true);
            $scope.title = logreporting ? "Log Reporting" : "Contact";
            $scope.actiontitle = logreporting ? "Send Report" : "Send";
            $scope.email = { subject: null, message: null };
            // $scope method: report and dispose of the modal
            $scope.sendLogReport = function (email) {
                reportLogs(email)
                    .catch(error => $ionicPopup.alert({ title: "Error Sending Log Report", template: error.message }))
                    .finally(() => $scope.modal.remove());
            };
            return $ionicModal
                .fromTemplateUrl(getResourcePath(config.logs.modalTemplateUrl), {
                    scope: $scope,
                    animation: "slide-in-up",
                    hardwareBackButtonClose: true
                })
                // set reference to built modal so it can be disposed and return it
                .then(modal => $scope.modal = modal);
        }
        
        //#endregion

        //#region Public methods

        /**
         * Sends email to support reporting the log files 
         * and the current state of the application.
         * 
         * @param {Object} emailConfig 
         *                 {
         *                  subject: String // subject to be appended
         *                  message: String // message to be prepended
         *                 }
         * @returns {Promise} 
         */
        function reportLogs(emailConfig = {}) {
            if (isRippleEmulator() || !$roll.started) {
                return $q.reject(new Error("Logging is not enabled"));
            }
            if (networkConnectionService.isOffline()) {
                return $q.reject(new Error("Device is not connected to a network"));
            }
            return $roll.writeNow() // flush logs to file
                // check availability
                .then(() => $cordovaEmailComposer.isAvailable())
                // build email dto
                .then(() => buildReportEmail(emailConfig))
                // send email intent
                .then(email => 
                    $cordovaEmailComposer.open(email)
                        .catch(() => $q.when()) // user canceled email -> catch
                );
        }
        
        /**
         * Shows confirm popup requesting permission to report the logs.
         * If it is confirmed will open modal: 
         * - optional email fields
         * - button to send the log report
         * 
         * @param {String?} title confirm popup title
         * @param {String?} template confirm popup template
         * @returns {Promise} 
         */
        function requestLogReporting({ title = config.logs.popup.title, template = config.logs.popup.template } = {}) {
            // prompt user asking confirmation
            if (config.logs.ongoing) return;
            // make sure only a single report can run at a time 
            // --> uncaught $digest loop (e.g. bad expression inside ng-if) exceptions may flood the screen
            config.logs.ongoing = true;
            $ionicPopup.confirm({ title, template })
                // build additional email data form modal
                .then(res => res ? getLogReportingModal() : $q.reject())
                // show built modal
                .then(modal => modal.show())
                // swallow any exceptions
                .catch(e => e)
                // mark finished
                .finally(() => config.logs.ongoing = false);
        }

        //#endregion

        //#region Service Instance
        const service = {
            reportLogs,
            getLogReportingModal,
            requestLogReporting: _.debounce(requestLogReporting, 500)
        };
        return service;
        //#endregion
    }

    //#region Service registration
    angular.module("sw_mobile_services")
        .factory("supportService", ["$q", "applicationStateService", "$roll", "$cordovaFile", "$cordovaEmailComposer", "networkConnectionService", "$ionicPopup", "$ionicModal", "$rootScope", "swdbDAO", supportService]);
    //#endregion

})(angular, cordova, _);;
(function (angular, _) {
    "use strict";

    function trackingService($log, $q, applicationStateService) {
        //#region Utils
        const config = {
            loggerContext: "tracking",
            get loggerContextKey() { return `log_${this.loggerContext}`; },
            loggerLevel: "trace"
        };
        const defaultTracker = $log.get(config.loggerContext, [config.loggerContext]);

        function getTracker(context) {
            return context
                ? $log.get(`${context}/${config.loggerContext}`, [config.loggerContext])
                : defaultTracker;
        }

        //#endregion

        //#region Public methods

        /**
         * Enables tracking.
         */
        function enable() {
            sessionStorage[config.loggerContextKey] = config.loggerLevel;
        }

        function disable() {
            sessionStorage[config.loggerContextKey] = defaultTracker.globalLogLevel;
        }

        function isEnabled() {
            return sessionStorage[config.loggerContextKey] === config.loggerLevel;
        }

        function track(context, ...messages) {
            const tracker = getTracker(context);
            tracker.trace("[TRACKING]:", ...messages);
        }
        
        /**
         * Logs states of the application passed as parameter
         * (e.g. logged user, settings, configs, application state, device info)
         * along with the context tag and any additional messages.
         * 
         * @param {String} context a tag for tracking
         * @param {Array<String>} states possible values are "settings"|"configs"|"user"|"device"|"applications"
         *                                  if null or empty will track the complete state
         * @param {VarArgs<String>} messages 
         */
        function trackStates(context, states, ...messages) {
            const method = !angular.isArray(states) || states.length <= 0 ? "getFullState" : "getStates";
            applicationStateService[method](states).then(state => {
                if (!state || _.isEmpty(state)) return;
                track(context, state, ...messages);
            });
        }

        /**
         * Logs the complete current state of the application 
         * (i.e. logged user, settings, configs, application state, device info)
         * along with the context tag and any additional messages.
         * 
         * @param {String} context a tag for tracking
         * @param {VarArgs<String>} messages
         */
        function trackFullState(context, ...messages) {
            if (!isEnabled()) return;
            trackStates(context, null, ...messages);
        }

        //#endregion

        //#region Service Instance
        const service = {
            track,
            trackStates,
            trackFullState,
            enable,
            disable,
            get isEnabled() {
                return isEnabled();
            }
        };
        return service;
        //#endregion
    }

    //#region Service registration

    angular.module("sw_mobile_services").factory("trackingService",
        ["$log", "$q", "applicationStateService", "$roll", "$cordovaFile", "$cordovaEmailComposer", "networkConnectionService", trackingService]);

    //#endregion

})(angular, _);;

(function (angular) {
    "use strict";

    angular.module("softwrench").factory("crudContextHolderService", ["$log","$state", "$rootScope", "contextService", crudContextHolderService]);

    function crudContextHolderService($log, $state, $rootScope, contextService) {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="$log"></param>
        /// <param name="contextService"></param>
        /// <returns type=""></returns>

        //#region Utils
        const quickSearchValue = "_quicksearch";
        const defaultSortValue = "default";

        const initialDrillDown = {
            // location
            selectedLocation: null,
            locationHistory: [],
            locations: [],
            locationQuery: undefined,
            locationsCount: 0,
            // asset
            childAssetsView: false,
            assets: [],
            assetSearchQuery: undefined,
            // both
            clean: true,
            assetView: false,
            assetsCount: 0,
            page: 1,
            moreItemsAvailable: false
        }

        var initialContext = {
            currentApplicationName: null,
            currentApplication: null,
            currentTitle: null,

            currentListSchema: null,
            itemlist: null,

            originalDetailItemDatamap: null,
            currentDetailItem: null,
            currentProblems: null,
            currentDetailSchema: null,
            currentNewDetailSchema: null,
            currentPopOverItem: null,
            newItem: false,

            // grid search
            gridSearch: {
                searchFields: {}, // the searchable fields as a object with attribute as key
                searchValues: {}, // all the search values as a object with attribute as key
                sortables: {}, // the sortableFields as a object with attribute as key
                sortableFields: [], // the sortableFields as a array
                sort: {}, // sort value
                count: 0
            },

            // menu
            currentMenuId: null,
            menuGridTitle: null,
            menuDisableCreate: false,
            readonly:false,

            //composition
            composition: {
                currentTab: null,
                currentListSchema: null,
                itemlist: null,

                currentDetailItem: null,
                originalDetailItemDatamap: null,
                currentDetailSchema: null,


            },

            // indexes for searching and ordering
            indexes: null,

            previousItem: null,
            nextItem: null,
            wizardStateIndex: 0,

            // drill down
            drillDown: angular.copy(initialDrillDown)
        };

        // inits the search and sort data with defaults
        function defaultGridSearch(gridSearch) {
            gridSearch.searchFields[quickSearchValue] = {
                label: "Quick Search",
                value: quickSearchValue,
                type: "BaseMetadataFilter"
            }
            const defaultSort = {
                label: "Default",
                value: defaultSortValue
            }
            gridSearch.sortables[defaultSortValue] = defaultSort;
            gridSearch.sortableFields.push(defaultSort);
            gridSearch.sort = defaultSort;
        }

        defaultGridSearch(initialContext.gridSearch);

        // ReSharper disable once InconsistentNaming
        var _crudContext = angular.copy(initialContext);

        //#endregion

        //#region Public methods

        function setPreviousAndNextItems(item) {
            if (!item) {
                return;
            }
            const itemlist = _crudContext.itemlist;
            const idx = itemlist.indexOf(item);
            if (idx === 0) { // first on the list: has no previous
                _crudContext.previousItem = null;
            } else {
                _crudContext.previousItem = itemlist[idx - 1];
            }
            if (idx === itemlist.length - 1) { // last on the list: has no next
                _crudContext.nextItem = null;
            } else {
                _crudContext.nextItem = itemlist[idx + 1];
            }
        }


        function restoreState() {
            if (!isRippleEmulator()) {
                return null; //this is used for F5 (refresh) upon development mode, so that we can return to the page we were before quickier
            }
            const savedCrudContext = contextService.getFromContext("crudcontext");
            if (savedCrudContext) {
                _crudContext = JSON.parse(savedCrudContext);
                if (_crudContext.itemlist) {
                    _crudContext.itemlist = [];
                }
                if (_crudContext.originalDetailItemDatamap) {
                    // the persistence entries do not get serialized correctly
                    _crudContext.currentDetailItem = _crudContext.currentDetailItem || {};
                    _crudContext.originalDetailItemDatamap = angular.copy(_crudContext.originalDetailItemDatamap);
                    _crudContext.currentDetailItem.datamap = _crudContext.originalDetailItemDatamap;
                    setPreviousAndNextItems(savedCrudContext.currentDetailItem);
                }

            }
            $log.get("crudContextService#factory").debug("restoring state of crudcontext");
            return savedCrudContext;
        };

        function isList() {
            return $state.current.name === "main.crudlist";
        };

        function currentTitle() {
            const tabTitle = this.tabTitle();
            if (tabTitle != null) {
                return _crudContext.currentTitle + " / " + tabTitle;
            }

            return _crudContext.currentTitle;
        };

        function currentApplicationName() {
            return _crudContext.currentApplicationName;
        }

        function currentListSchema() {
            return _crudContext.currentListSchema;
        }

        function currentSchema() {
            const listSchema = _crudContext.currentListSchema;
            const detailSchema = _crudContext.currentDetailSchema;
            if (!listSchema) {
                return detailSchema;
            } else if (!detailSchema) {
                return listSchema;
            }
            //both are defined, bigger devices
            return [listSchema, detailSchema];
        }

        function currentDetailSchema() {
            if (_crudContext.newItem) {
                return _crudContext.currentNewDetailSchema ? _crudContext.currentNewDetailSchema : _crudContext.currentDetailSchema;
            }
            return _crudContext.currentDetailSchema;
        }

        function currentDetailItem() {
            return _crudContext.currentDetailItem;
        }

        function currentProblems() {
            return _crudContext.currentProblems;
        }

        function updateCurrentProblem(problem) {
            if (!!problem) {
                $rootScope.$broadcast("sw.problem.problemupdated");
                _crudContext.currentProblems = [problem];
            }
        }

        function updateOriginalItemDatamap(newItemDatamap) {
            _crudContext.originalDetailItemDatamap = angular.copy(newItemDatamap);
        }

        function itemlist() {
            return _crudContext.itemlist;
        }

        function currentDetailItemDataMap() {
            if (_crudContext.composition.currentDetailItem) {
                return _crudContext.composition.currentDetailItem;
            }

            return _crudContext.currentDetailItem.datamap;
        }

        function leavingDetail() {
            _crudContext.composition = {};
            _crudContext.currentDetailItem = null;
        };

        function leavingCompositionDetail() {
            _crudContext.composition.currentDetailItem = null;
        };

        function isOnMainTab() {
            return _crudContext.composition.currentTab == null;
        };

        function isOnDrillDown() {
            return $state.current.name === "main.cruddetail.locationdrilldown";
        };

        function resetTab() {
            _crudContext.composition.currentTab = null;
        };

        function tabTitle() {
            if (this.isOnMainTab()) {
                return null;
            }
            return _crudContext.composition.currentTab.label;
        };

        function tabIcon() {
            if (this.isOnMainTab()) {
                return null;
            }
            return _crudContext.composition.currentTab.schema.schemas.list.properties['icon.composition.tab'];
        };

        function getActiveTab() {
            if (this.isOnMainTab()) {
                return null;
            }
            return _crudContext.composition.currentTab.id;
        }

        function compositionList() {
            return _crudContext.composition.itemlist;
        };

        function getCompositionListSchema() {
            return _crudContext.composition.currentListSchema;
        };

        function getCompositionDetailSchema() {
            return _crudContext.composition.currentDetailSchema;
        };

        function getCompositionDetailItem() {
            return _crudContext.composition.currentDetailItem;
        };

        function getGridSearchData() {
            return _crudContext.gridSearch;
        }

        // parse the indexes from the application props
        function parseIndexes(key, props) {
            const indexes = [];
            const indexesString = props[key];

            if (!indexesString) {
                return indexes;
            }
            angular.forEach(indexesString.split(","), index => {
                const trimmed = index.trim();
                if (trimmed) {
                    indexes.push(trimmed);
                }
            });
            return indexes;
        }

        function getIndexes() {
            if (_crudContext.indexes) {
                return _crudContext.indexes;
            }

            _crudContext.indexes = {};

            const app = _crudContext.currentApplication;
            if (!app || !app.data || !app.data.properties) {
                return _crudContext.indexes;
            }

            _crudContext.indexes.textIndexes = parseIndexes("list.offline.text.indexlist", app.data.properties);
            _crudContext.indexes.numericIndexes = parseIndexes("list.offline.numeric.indexlist", app.data.properties);
            _crudContext.indexes.dateIndexes = parseIndexes("list.offline.date.indexlist", app.data.properties);
            return _crudContext.indexes;
        }

        // clears the search and sort values
        function clearGridSearchValues() {
            angular.forEach(_crudContext.gridSearch.searchFields, (searchable, attribute) => {
                if (_crudContext.gridSearch.searchFields.hasOwnProperty(attribute)) {
                    _crudContext.gridSearch.searchValues[attribute] = {};
                }
            });
            _crudContext.gridSearch.sort = _crudContext.gridSearch.sortables[defaultSortValue];
        }

        // reset search and sort structure to default - not only values
        function clearGridSearch() {
            _crudContext.gridSearch = {
                searchFields: {},
                searchValues: {},
                sortables: {},
                sortableFields: [],
                sort: {}
            }
            defaultGridSearch(_crudContext.gridSearch);
        }

        function getQuickSearch() {
            if (!_crudContext.gridSearch.searchValues[quickSearchValue]) {
                _crudContext.gridSearch.searchValues[quickSearchValue] = {};
            }
            return _crudContext.gridSearch.searchValues[quickSearchValue];
        }

        function getCrudContext() {
            return _crudContext;
        }

        function reset() {
            _crudContext = angular.copy(initialContext);
            defaultGridSearch(_crudContext.gridSearch);
        }

        function hasDirtyChanges() {
            if (_crudContext.composition.currentDetailItem) {
                return _crudContext.composition.currentDetailItem && (!angular.equals(_crudContext.composition.originalDetailItemDatamap, _crudContext.composition.currentDetailItem));
            }

            return _crudContext.currentDetailItem && (!angular.equals(_crudContext.originalDetailItemDatamap, _crudContext.currentDetailItem.datamap));
        };

        //#endregion

        //#region Service Instance
        function drillDownClear() {
            _crudContext.drillDown = angular.copy(initialDrillDown);
        }
        //#endregion


        //#region Service Instance

        const service = {
            setPreviousAndNextItems,
            restoreState,
            isList,
            currentTitle,
            currentApplicationName,
            currentListSchema,
            currentDetailSchema,
            currentDetailItem,
            currentProblems, updateCurrentProblem,

            currentSchema,
            itemlist,
            currentDetailItemDataMap,
            leavingDetail,
            isOnMainTab,
            isOnDrillDown,
            resetTab,
            tabTitle,
            tabIcon,
            leavingCompositionDetail,
            compositionList,
            getCompositionListSchema,
            getCompositionDetailSchema,
            getCompositionDetailItem,
            getGridSearchData,
            getIndexes,
            clearGridSearchValues,
            clearGridSearch,
            getQuickSearch,
            hasDirtyChanges,
            getActiveTab,
            reset,
            updateOriginalItemDatamap,
            drillDownClear,
            //below method to facilitate migration
            getCrudContext

        };

        return service;

        //#endregion
    }

    //#region Service registration



    //#endregion

})(angular);
;
(function (mobileServices, angular, constants, _) {
    "use strict";
    constants = constants || {};

    mobileServices.factory('crudContextService', [
        "$q", "$log", "$rootScope", "$ionicHistory", "swdbDAO", "searchIndexService", "problemService",
        "metadataModelService", "offlineSchemaService", "offlineCompositionService", "expressionService",
        "offlineSaveService", "schemaService", "contextService", "routeService", "tabsService", "crudSearchService",
        "crudFilterContextService", "validationService", "crudContextHolderService", "datamapSanitizationService", "maximoDataService", "menuModelService", "loadingService", "offlineAttachmentService", "offlineEntities", "queryListBuilderService", "swAlertPopup", "eventService",
        function ($q, $log, $rootScope, $ionicHistory, dao, searchIndexService, problemService,
            metadataModelService, offlineSchemaService, offlineCompositionService, expressionService,
            offlineSaveService, schemaService, contextService, routeService, tabsService, crudSearchService,
            crudFilterContextService, validationService, crudContextHolderService, datamapSanitizationService, maximoDataService, menuModelService, loadingService, offlineAttachmentService, entities, queryListBuilderService, swAlertPopup, eventService) {

            let service = {};

            // ReSharper disable once InconsistentNaming
            var internalListContext = {
                lastPageLoaded: 1
            }

            $rootScope.$on("sw4:security:logout", function () {
                metadataModelService.reset();
                crudContextHolderService.reset();
                menuModelService.reset();
            });

            // used to know when to clear search and sort data structure
            var lastGridApplication = null;

            const afterSaveNew = function (newItem, crudContext) {
                crudContext.originalDetailItemDatamap = angular.copy(newItem.datamap);
                return service.refreshGrid(true).then(() => {
                    $rootScope.$broadcast("sw_cruddetailrefreshed");
                    return newItem;
                });
            }

            service = {
                //#region delegateMethods
                getCrudContext: function () {
                    return crudContextHolderService.getCrudContext();
                },

                restoreState: function () {
                    const savedState = crudContextHolderService.restoreState();
                    if (savedState && savedState.itemlist && !savedState.currentDetailItem) {
                        this.refreshGrid();
                    }
                    $rootScope.$broadcast("sw_staterestored");
                    return savedState;
                },

                resetContext: function () {
                    crudContextHolderService.reset();
                },

                isList: function () {
                    return crudContextHolderService.isList();
                },

                currentTitle: function () {
                    return crudContextHolderService.currentTitle();
                },

                currentApplicationName: function () {
                    return crudContextHolderService.currentApplicationName();
                },

                currentListSchema: function () {
                    return crudContextHolderService.currentListSchema();
                },

                currentDetailSchema: function () {
                    return crudContextHolderService.currentDetailSchema();
                },

                currentDetailItem: function () {
                    return crudContextHolderService.currentDetailItem();
                },

                itemlist: function () {
                    return crudContextHolderService.itemlist();
                },

                currentDetailItemDataMap: function () {
                    return crudContextHolderService.currentDetailItemDataMap();
                },

                leavingDetail: function () {
                    crudContextHolderService.leavingDetail();
                },

                isOnMainTab: function () {
                    return crudContextHolderService.isOnMainTab();
                },

                resetTab: function () {
                    crudContextHolderService.resetTab();
                },

                tabTitle: function () {
                    return crudContextHolderService.tabTitle();
                },

                tabIcon: function () {
                    return crudContextHolderService.tabIcon();
                },

                leavingCompositionDetail: function () {
                    crudContextHolderService.leavingCompositionDetail();
                },

                //#region composition
                compositionList: function () {
                    return crudContextHolderService.compositionList();
                },

                getCompositionListSchema: function () {
                    return crudContextHolderService.getCompositionListSchema();
                },

                getCompositionDetailSchema: function () {
                    return crudContextHolderService.getCompositionDetailSchema();
                },

                getCompositionDetailItem: function () {
                    return crudContextHolderService.getCompositionDetailItem();
                },
                //#endregion

                //#endregion


                mainDisplayables: function () {
                    return schemaService.nonTabFields(this.currentDetailSchema());
                },


                //#region Compositions

                currentCompositionsToShow: function () {
                    const detailSchema = this.currentDetailSchema();
                    if (!detailSchema) {
                        return [];
                    }
                    const allDisplayables = tabsService.tabsDisplayables(detailSchema);
                    return allDisplayables;
                },

                currentCompositionTabByName: function (composition) {
                    return this.currentCompositionsToShow().find(c => c.attribute === composition);
                },

                currentCompositionSchemaById: function (composition, schemaId) {
                    const compositionMetadata = this.currentCompositionTabByName(composition);
                    return !compositionMetadata ? null : compositionMetadata.schema.schemas[schemaId];
                },

                loadTab: function (tab) {
                    var crudContext = crudContextHolderService.getCrudContext();
                    if (tab == null) {
                        //letÂ´s return to the main tab
                        this.resetTab();
                        return routeService.go("main.cruddetail.maininput");
                    }

                    if (tab.type !== "ApplicationCompositionDefinition") {
                        //tabs do not need to load from the database since the data is already contained on the main datamap
                        crudContext.composition.currentTab = tab;
                        return routeService.go("main.cruddetail.tab");
                    }

                    return offlineCompositionService.loadCompositionList(crudContext.currentDetailItem, tab).then(function (compositionItems) {
                        crudContext.composition.currentTab = tab;
                        crudContext.composition.itemlist = compositionItems;
                        crudContext.composition.currentListSchema = tab.schema.schemas.list;
                        crudContext.composition.currentDetailSchema = tab.schema.schemas.detail;
                        crudContext.composition.currentDetailItem = null;
                        contextService.insertIntoContext("crudcontext", crudContext);
                        return routeService.go("main.cruddetail.compositionlist");
                    });
                },

                //TODO: move to offlinecompositionservice perhaps?
                loadCompositionDetail: function (item) {
                    const errors = this.validateDetail();
                    if (errors && errors.length > 0) {
                        // main form has validations: disable edit and redirect to main tab
                        return swAlertPopup.alertValidationErrors(errors, null, `Validation errors in the main form prevent you from editing this ${this.tabTitle()}. Please resolve this errors:`)
                            .then(() => this.loadTab());
                    }
                    const crudContext = crudContextHolderService.getCrudContext();
                    const compositionDetailSchema = this.getCompositionDetailSchema();
                    const fields = compositionDetailSchema.displayables;
                    if (compositionDetailSchema.applicationName === "attachment") {
                        return offlineAttachmentService.loadRealAttachment(item);
                    }
                    datamapSanitizationService.enforceNumericType(item, fields);
                    //for compositions item will be the datamap itself
                    crudContext.composition.currentDetailItem = item;
                    crudContext.composition.originalDetailItemDatamap = angular.copy(item);
                    contextService.insertIntoContext("crudcontext", crudContext);
                    return routeService.go("main.cruddetail.compositiondetail");
                },

                addCompositionAllowed: function () {
                    const context = crudContextHolderService.getCrudContext();
                    const composition = context.composition;
                    if (!composition || !composition.currentTab || !composition.currentTab.schema || composition.currentDetailItem != null) {
                        return false;
                    }

                    const allowInsertion = composition.currentTab.schema.allowInsertion;
                    const datamap = context.currentDetailItem.datamap;
                    const schema = context.currentDetailSchema;
                    return expressionService.evaluate(allowInsertion, datamap, { schema: schema }, null);
                },

                createNewCompositionItem: function () {
                    const errors = this.validateDetail();
                    if (errors && errors.length > 0) {
                        // main form has validations: disable create/add and redirect to main tab
                        return swAlertPopup.alertValidationErrors(errors, null, `Validation errors in the main form prevent you from adding a new ${this.tabTitle()}. Please resolve this errors:`)
                            .then(() => this.loadTab());
                    }
                    const crudContext = crudContextHolderService.getCrudContext();
                    const compositionParentDatamap = crudContext.currentDetailItem.datamap;
                    crudContext.composition.currentDetailItem = {};
                    offlineSchemaService.fillDefaultValues(crudContext.composition.currentDetailSchema, crudContext.composition.currentDetailItem, compositionParentDatamap);
                    crudContext.composition.originalDetailItemDatamap = {
                        //to make this new item always dirty!!!
                        "_newitem#$": true
                    };
                    contextService.insertIntoContext("crudcontext", crudContext);
                    return routeService.go("main.cruddetail.compositiondetail");
                },


                //#endregion

                //#region saveFNS

                hasDirtyChanges: function () {
                    return crudContextHolderService.hasDirtyChanges();
                },

                cancelChanges: function () {
                    const crudContext = crudContextHolderService.getCrudContext();
                    if (crudContext.composition.currentDetailItem) {
                        crudContext.composition.currentDetailItem = angular.copy(crudContext.composition.originalDetailItemDatamap);
                        return routeService.go("main.cruddetail.compositionlist");
                    }
                    if (crudContext.newItem) {
                        this.refreshGrid();
                        crudContext.newItem = false;
                    } else {
                        crudContext.currentDetailItem.datamap = angular.copy(crudContext.originalDetailItemDatamap);
                    }

                },

                validateDetail: function (crudForm, schemaToValidate, displayables) {
                    const crudContext = crudContextHolderService.getCrudContext();
                    crudForm = crudForm || {};
                    const detailSchema = schemaToValidate || this.currentDetailSchema();
                    const datamap = crudContext.currentDetailItem.datamap;
                    const toValidateDisplayables = displayables || detailSchema.displayables;
                    return validationService.validate(detailSchema, toValidateDisplayables, datamap, crudForm.$error);
                },

                saveChanges: function (crudForm, showConfirmationMessage) {
                    const crudContext = crudContextHolderService.getCrudContext();
                    crudForm = crudForm || {};
                    const validationErrors = this.validateDetail(crudForm);
                    if (validationErrors.length > 0) {
                        //interrupting here, canÂ´t be done inside service
                        return $q.reject(validationErrors);
                    }

                    const datamap = crudContext.currentDetailItem.datamap;
                    const composition = crudContext.composition;
                    if (composition && composition.currentDetailItem) {
                        const compositionItem = composition.currentDetailItem;
                        const validationErrors = validationService.validate(composition.currentDetailSchema, composition.currentDetailSchema.displayables, compositionItem, crudForm.$error);
                        if (validationErrors.length > 0) {
                            //interrupting here, canÂ´t be done inside service
                            return $q.reject(validationErrors);
                        }

                        return offlineSaveService.addAndSaveComposition(crudContext.currentApplicationName, crudContext.currentDetailItem, compositionItem, composition.currentTab)
                            .then(() => {
                                //                            crudContext.originalDetailItemDatamap = angular.copy(datamap);
                                composition.originalDetailItemDatamap = composition.currentDetailItem;
                                return this.refreshIfLeftJoinPresent(crudContext, null);
                            })
                            .then(saved => {
                                const compositionItemInList = composition.itemlist.find(c => c[constants.localIdKey] === compositionItem[constants.localIdKey]);
                                if (!compositionItemInList) {
                                    return saved;
                                }
                                angular.forEach(compositionItemInList, (value, key) => {
                                    if (!compositionItem.hasOwnProperty(key) || key === "$$hashKey") return;
                                    compositionItemInList[key] = compositionItem[key];
                                });
                                return saved;
                            })
                            .then(saved => this.loadTab(composition.currentTab).then(() => saved));
                    }

                    return this.saveCurrentItem(showConfirmationMessage, true);
                },



                saveCurrentItem: function (showConfirmationMessage, loadSavedItem) {
                    const crudContext = crudContextHolderService.getCrudContext();
                    let applicationName = crudContext.currentApplicationName;
                    const item = crudContext.currentDetailItem;
                    const datamap = item.datamap;
                    const schema = this.currentDetailSchema();

                    const beforeSave = eventService.dispatch("offline.presave", schema, { schema, datamap });

                    return $q.when(beforeSave)
                        .then(() => {
                            const title = crudContext.currentApplication.data.title || applicationName;
                            return offlineSaveService.saveItem(applicationName, item, title, showConfirmationMessage);
                        })
                        .then(saved => {
                            applicationName = saved.application;
                            contextService.insertIntoContext("crudcontext", crudContext);
                            if (!crudContext.newItem) {
                                //                            crudContext.originalDetailItemDatamap = angular.copy(saved.datamap);
                                return this.refreshIfLeftJoinPresent(crudContext, saved);
                            }

                            menuModelService.updateAppsCount();
                            crudContext.newItem = false;

                            if (!loadSavedItem) {
                                return afterSaveNew(saved, crudContext);
                            }

                            const listSchema = crudContextHolderService.currentListSchema();
                            const joinObj = queryListBuilderService.buildJoinParameters(listSchema);
                            const qry = "`root`.application = '{0}' and `root`.id = '{1}'".format(applicationName, saved.newId);
                            return dao.findByQuery("DataEntry", qry, joinObj).then((results) => {
                                const newItem = results[0];
                                crudContext.currentDetailItem = newItem;
                                return afterSaveNew(newItem, crudContext);
                            });
                        });
                },

                refreshIfLeftJoinPresent: function (crudContext, saved) {
                    const itemlist = this.itemlist();
                    const currentDetailItem = crudContext.currentDetailItem;
                    if (itemlist.length > 0) {
                        //due to possible leftjoins
                        const repeatedItems = itemlist.some(i => i.id === currentDetailItem.id && i.generatedRowStamp !== currentDetailItem.generatedRowStamp);
                        if (repeatedItems) {
                            //letÂ´s garantee that all items with the same id are updated (eventual left joins)
                            return this.refreshGrid(true).then(() => saved);
                        }
                    }
                    return saved;
                },

                restoreItemToOriginalState: function (item) {
                    const crudContext = crudContextHolderService.getCrudContext();
                    const application = crudContext.currentApplicationName;

                    const newAttachments = (() => {
                        const originalAttachments = item.originaldatamap["attachment_"] || [];
                        const allAttachments = item.datamap["attachment_"] || [];

                        if (allAttachments.length <= 0) return [];

                        const allHashes = allAttachments.map(a => a["#offlinehash"]);
                        const originalHashes = originalAttachments.map(a => a["#offlinehash"]);
                        const newHashes = _.difference(allHashes, originalHashes);

                        return allAttachments.filter(a => _.contains(newHashes, a["#offlinehash"]));
                    })();

                    const hadProblem = item.hasProblem;
                    item.isDirty = false;
                    item.hasProblem = false;

                    var promise = dao.executeStatement(entities.DataEntry.restoreToOriginalStateStatement, [item.id, application]);
                    if (hadProblem) {
                        item.hasProblem = false;
                        promise = promise.then(() => problemService.deleteRelatedProblems(item.id));
                    }
                    if (newAttachments.length > 0) {
                        promise = promise.then(() => offlineAttachmentService.deleteRelatedAttachments(newAttachments));
                    }

                    return promise;
                },

                deleteLocalItem: function (item) {
                    const crudContext = crudContextHolderService.getCrudContext();
                    const application = crudContext.currentApplicationName;

                    const newAttachments = item.datamap["attachment_"] || [];

                    const promise = dao.executeStatement(entities.DataEntry.deleteLocalStatement, [item.id, application]).then((result) => {
                        menuModelService.updateAppsCount();
                        return result;
                    });

                    return newAttachments.length > 0
                        ? promise.then(() => offlineAttachmentService.deleteRelatedAttachments(newAttachments))
                        : promise;
                },

                //#endregion

                //#region GridFNS

                refreshGrid: function (skipPostFilter) {
                    const log = $log.get("crudContextService#refreshGrid", ["list", "crud"]);
                    var crudContext = crudContextHolderService.getCrudContext();
                    crudContext.itemlist = [];
                    internalListContext.lastPageLoaded = 1;
                    internalListContext.pageNumber = 1;
                    return this.loadMorePromise().then(function () {
                        if (skipPostFilter) {
                            return $q.when();
                        }
                        log.debug("application grid refreshed");
                        contextService.insertIntoContext("crudcontext", crudContext);
                        return routeService.go("main.crudlist");
                    });
                },


                loadMorePromise: function () {
                    crudSearchService.initGridSearch();

                    var crudContext = crudContextHolderService.getCrudContext();
                    const gridSearch = crudContextHolderService.getGridSearchData();
                    const quickSearch = crudContextHolderService.getQuickSearch();
                    const listSchema = crudContextHolderService.currentListSchema();
                    const appName = crudContextHolderService.currentApplicationName();

                    const joinObj = queryListBuilderService.buildJoinParameters(listSchema);

                    let extraWhereClause = crudSearchService.handleQuickSearch(quickSearch,joinObj);

                    extraWhereClause += searchIndexService.buildSearchQuery(appName, listSchema, gridSearch);
                    
                    let baseQuery = menuModelService.buildListQuery(crudContext.currentApplicationName, crudContext.currentMenuId, extraWhereClause);

                    if (internalListContext.lastPageLoaded === 1) {
                        const countQuery = baseQuery;
                        dao.countByQuery("DataEntry", countQuery, joinObj).then((count) => {
                            gridSearch.count = count;
                        });
                    }

                    baseQuery += searchIndexService.buildSortQuery(appName, listSchema, gridSearch);

                    const queryObj = angular.extend({ pagesize: 10, pageNumber: internalListContext.lastPageLoaded }, joinObj);

                    return dao.findByQuery("DataEntry", baseQuery, queryObj)
                        .then(function (results) {
                            internalListContext.lastPageLoaded = internalListContext.lastPageLoaded + 1;
                            for (var i = 0; i < results.length; i++) {
                                crudContext.itemlist.push(results[i]);
                            }
                            return $q.when(results);
                        });
                },


                loadApplicationGrid: function (applicationName, schemaId, menuId, menuParams) {
                    const log = $log.get("crudContextService#loadApplicationGrid", ["list", "crud"]);
                    log.debug("loading application grid");
                    if (lastGridApplication !== applicationName) {
                        crudContextHolderService.clearGridSearch();
                    }
                    lastGridApplication = applicationName;

                    const crudContext = crudContextHolderService.getCrudContext(); //cleaning up
                    crudContext.currentDetailItem = null;
                    crudContext.composition = {};
                    const application = metadataModelService.getApplicationByName(applicationName);
                    crudContext.currentTitle = application.data.title;
                    crudContext.currentApplicationName = applicationName;
                    crudContext.currentApplication = application;
                    crudContext.newItem = false;

                    if (menuId) {
                        crudContext.currentMenuId = menuId;
                        crudContext.menuGridTitle = menuParams && menuParams.offlinegridtitle;
                        crudContext.menuDisableCreate = menuParams && menuParams.offlineDisableCreate === "true";
                    }

                    crudContext.readonly = "true" === application.data.properties["mobile.application.readonly"];

                    crudContext.currentListSchema = offlineSchemaService.locateSchema(application, schemaId);
                    crudContext.currentDetailSchema = offlineSchemaService.loadDetailSchema(crudContext.currentListSchema, crudContext.currentApplication);
                    crudContext.currentNewDetailSchema = offlineSchemaService.locateSchemaByStereotype(crudContext.currentApplication, "detailnew");
                    if (crudContext.currentNewDetailSchema == null && schemaService.isPropertyTrue(crudContext.currentDetailSchema, "mobile.actasnewschema")) {
                        //if this property is true, then the detail schema will also be used as the newschema
                        crudContext.currentNewDetailSchema = crudContext.currentDetailSchema;
                    }
                    return this.refreshGrid();
                },

                hasNewSchemaAvailable: function () {
                    const crudContext = crudContextHolderService.getCrudContext();
                    const newDetailSchema = crudContext.currentNewDetailSchema;
                    return !!newDetailSchema;
                },

                //#endregion

                //#region detailFNs

                navigatePrevious: function () {
                    const crudContext = crudContextHolderService.getCrudContext();
                    if (!crudContext.previousItem) {
                        return routeService.go("main.crudlist");
                    } else {
                        return this.loadDetail(crudContext.previousItem);
                    }

                },

                navigateNext: function () {
                    const crudContext = crudContextHolderService.getCrudContext();
                    if (!crudContext.nextItem) {
                        return this.loadMorePromise().then(results => {
                            if (!results || results.length <= 0) {
                                //end has reached;
                                return $q.when();
                            }
                            crudContextHolderService.setPreviousAndNextItems(crudContext.currentDetailItem);
                            if (!!crudContext.nextItem) {
                                return this.loadDetail(crudContext.nextItem);
                            }
                            return $q.when();
                        });
                    }
                    return this.loadDetail(crudContext.nextItem);
                },

                isCreation: function () {
                    const crudContext = this.getCrudContext();
                    return !crudContext.originalDetailItemDatamap || crudContext.originalDetailItemDatamap["_newitem#$"];
                },

                gridTitle: function (gridSchema) {
                    if (!gridSchema || !gridSchema.title) {
                        return this.currentTitle();
                    }
                    return gridSchema.title;
                },

                createDetail: function () {
                    const crudContext = crudContextHolderService.getCrudContext();
                    crudContext.wizardStateIndex = 0;
                    crudContext.currentDetailItem = {
                        datamap: {}
                    };
                    crudContext.newItem = true;
                    // TODO: add support for schema registered hooks
                    offlineSchemaService.fillDefaultValues(this.currentDetailSchema(), crudContext.currentDetailItem.datamap);
                    crudContext.originalDetailItemDatamap = {
                        //to make this new item always dirty!!!
                        "_newitem#$": true
                    };
                    return routeService.go("main.cruddetail.maininput");
                },

                loadDetailByMaximoUid: function (application, schema, refId) {
                    var that = this;
                    maximoDataService.loadItemByMaximoUid(application, schema, refId)
                        .then(function (item) {
                            return that.loadDetail(item);
                        });
                },



                loadDetail: function (item) {
                    return $ionicHistory.clearCache().then(() => {
                        const log = $log.get("crudContextService#loadDetail", ["crud", "detail"]);
                        log.debug("load detail init");
                        const crudContext = crudContextHolderService.getCrudContext();
                        if (crudContext.readonly){
                            return;
                        }

                        loadingService.showDefault();
                         /// <summary>
                        ///  Loads a detail represented by the parameter item.
                        /// </summary>
                        /// <param name="item"></param>
                        /// <returns type=""></returns>
                        if (!crudContext.currentDetailSchema) {
                            crudContext.currentDetailSchema = offlineSchemaService.loadDetailSchema(crudContext.currentListSchema, crudContext.currentApplication, item);
                        }


                        const fields = this.mainDisplayables();
                        datamapSanitizationService.enforceNumericType(item.datamap, fields);

                        crudContext.currentDetailItem = item;
                        eventService.onload({}, crudContext.currentDetailSchema, crudContext.currentDetailItem.datamap, {});
                        crudContext.originalDetailItemDatamap = angular.copy(crudContext.currentDetailItem.datamap);
                        crudContextHolderService.setPreviousAndNextItems(item);
                        if (isRippleEmulator()) {
                            contextService.insertIntoContext("crudcontext", crudContext);
                        }


                        log.debug("loading problems");
                        return problemService.getProblems(item.id).then(problems => {
                            log.debug("problems loaded done");
                            crudContext.currentProblems = problems;
                            if (!!crudContext.composition.currentTab) {
                                this.loadTab(crudContext.composition.currentTab);
                            } else {
                                return routeService.go("main.cruddetail.maininput");
                            }

                        }).then(() => {
                            log.debug("crud detail finished loading");
                            $rootScope.$broadcast("sw_cruddetailrefreshed");
                            loadingService.hide();
                        });
                    });
                }
                //#endregion
            }

            return service;

        }]);

})(mobileServices, angular, constants, _);
;
(function (mobileServices) {
    "use strict";

    mobileServices.factory('crudFilterContextService', ["$q", "$log", "contextService", function ($q, $log, contextService) {

    var filterContext = {
        showPending: false,
        showDirty: true,
        showProblems: false,
    }

    return {

        showPending: function (value) {
            if (value != undefined) {
                filterContext.showPending = value;
                contextService.insertIntoContext("filterContext", filterContext);
            }
            return filterContext.showPending;
        },

        showProblems: function (value) {
            if (value != undefined) {
                filterContext.showProblem = value;
                contextService.insertIntoContext("filterContext", filterContext);
            }
            return filterContext.showProblem;
        },


        showDirty: function (value) {
            if (value != undefined) {
                filterContext.showDirty = value;
                contextService.insertIntoContext("filterContext", filterContext);
            }
            return filterContext.showDirty;
        },

    }

}]);

})(mobileServices);;
(function (mobileServices) {
    "use strict";


    class crudSearchService {
        constructor(crudContextHolderService, dispatcherService, offlineAssociationService, fieldService) {
            this.crudContextHolderService = crudContextHolderService;
            this.dispatcherService = dispatcherService;
            this.offlineAssociationService = offlineAssociationService;
            this.fieldService = fieldService;

            const ascIcon = "android-arrow-up";
            const descIcon = "android-arrow-down";

            // builds the label for a multiple option field
            this.getOptionLabels = function (options, value) {
                if (!value || !options) {
                    return null;
                }
                var labels = [];
                const valuesArray = value.split(";");
                angular.forEach(valuesArray, currentValue => {
                    angular.forEach(options, option => {
                        if (option.value === currentValue) {
                            labels.push(option.label);
                        }
                    });
                });
                return labels.join(" & ");
            }

            // create a fild key to enable two sort field from the same attribute 
            this.sortKey = function (attribute, asc) {
                return attribute + "." + (asc ? "asc" : "desc");
            }

            this.searchOptionChangedFunction = function (attribute, options) {
                if (!options) {
                    return null;
                }
                return (newValue) => {
                    // updates the label considering the selected options
                    const gridSearch = this.crudContextHolderService.getGridSearchData();
                    const searchValue = gridSearch.searchValues[attribute];
                    if (!searchValue) {
                        return;
                    }
                    searchValue.value = newValue;
                    searchValue.label = this.getOptionLabels(options, newValue);
                }
            }

            // creates a search field data
            this.createSearchable = function (searchFields, filter, schema) {
                const displayables = schema.displayables;
                var field = {};
                angular.forEach(displayables, displayable => {
                    if (displayable.attribute === filter.attribute) {
                        field = displayable;
                    }
                });

                const searchable = {
                    label: filter.label,
                    value: filter.attribute,
                    type: filter.type,
                    dataType: field.dataType
                }

                searchFields[filter.attribute] = searchable;

                if (filter.type !== "MetadataOptionFilter") {
                    return;
                }

                searchable.whereClause = filter.whereClause;

                if (!filter.provider) {
                    searchable.options = filter.options;
                    if (searchable.options) {
                        angular.forEach(searchable.options, option => {
                            option.text = option.label || option.value;
                        });
                    }
                    searchable.optionChanged = this.searchOptionChangedFunction(filter.attribute, searchable.options);
                    return;
                }

                searchable.options = [];
                searchable.optionChanged = this.searchOptionChangedFunction(filter.attribute, searchable.options);

                // a service provides the options
                if (filter.provider.startsWith("@")) {
                    const serviceString = filter.provider.substring(1);
                    const options = this.dispatcherService.invokeServiceByString(serviceString);
                    searchable.options.push(...options);
                    return;
                }

                // options are provided by a relathionship
                // TODO: for now is required a association on detail schema to force the sync of the data for use on the option filter
                const parentSchema = this.crudContextHolderService.currentDetailSchema();
                const providerTokens = filter.provider.split(".");
                const associationName = providerTokens[0];
                const assocDisplayables = this.fieldService.getDisplayablesByAssociationKey(parentSchema, associationName);
                if (!assocDisplayables || assocDisplayables.length === 0) {
                    return;
                }
                const labelField = providerTokens[1];
                const assocDisplayable = assocDisplayables[0];
                this.offlineAssociationService.filterPromise(parentSchema, {}, associationName, null, assocDisplayable).then(assocs => {
                    angular.forEach(assocs, assoc => {
                        const option = {
                            label: assoc.datamap[labelField],
                            value: assoc.datamap[assocDisplayable.valueField]
                        }
                        option.text = option.label || option.value;
                        searchable.options.push(option);
                    });
                });
            }

            // creates a sort field data
            this.createSortable = function (filter, asc) {
                return {
                    label: filter.label,
                    value: this.sortKey(filter.attribute, asc),
                    attribute: filter.attribute,
                    afterLabelIcon: asc ? ascIcon : descIcon,
                    direction: asc ? "asc" : "desc"
                }
            }

            // sets the pre selected values from a option filter
            this.setPreSelectedValue = function (gridSearch, filter) {
                if (filter.type !== "MetadataOptionFilter") {
                    return;
                }

                const searchable = gridSearch.searchFields[filter.attribute];
                if (!searchable) {
                    return;
                }

                if (filter.preselected) {
                    searchable.optionChanged(filter.preselected);
                    return;
                }

                const preselectedValues = [];
                angular.forEach(searchable.options, option => {
                    if (option.preSelected) {
                        preselectedValues.push(option.value);
                    }
                });
                if (preselectedValues.length > 0) {
                    searchable.optionChanged(preselectedValues.join(";"));
                }
            }

            // sets the pre selected values from all option filters
            this.setPreSelectedValues = function () {
                const gridSearch = this.crudContextHolderService.getGridSearchData();
                const schema = this.crudContextHolderService.currentListSchema();
                const filters = schema.schemaFilters;
                if (!filters || !filters.filters) {
                    return;
                }

                angular.forEach(filters.filters, filter => {
                    this.setPreSelectedValue(gridSearch, filter);
                });
            }
        }


        handleQuickSearch(quickSearch,joinObj) {
            if (!quickSearch || !quickSearch.value) {
                return "1=1";
            }

            const value = quickSearch.value;

            let quickSearchWc = '(`root`.datamap like \'%:"%{0}%\''.format(value);
            quickSearchWc += ' or `root`.textindex01 like "%{0}%"'.format(value);
            quickSearchWc += ' or `root`.textindex02 like "%{0}%" '.format(value);

            if (!!joinObj.leftJoinEntities && joinObj.leftJoinEntities.length > 0) {
                joinObj.leftJoinEntities.forEach(item => {
                    //searching through related joined indexes
                    quickSearchWc += ' or `{0}`.textindex01 like "%{1}%"'.format(item, value);
                    quickSearchWc += ' or `{0}`.textindex02 like "%{1}%" '.format(item, value);
                })
            }

            quickSearchWc += ")";
            return quickSearchWc;

        }

        initGridSearch() {
            const gridSearch = this.crudContextHolderService.getGridSearchData();

            // verifies if the search structured is already built
            const searchFields = gridSearch.searchFields;
            if (Object.keys(searchFields).length > 1) {
                return gridSearch;
            }

            // verifies if there are existing filters
            const schema = this.crudContextHolderService.currentListSchema();
            const filters = schema.schemaFilters;
            if (!filters || !filters.filters) {
                return gridSearch;
            }

            // builds search and sort structure
            angular.forEach(filters.filters, filter => {
                if (!gridSearch.searchValues[filter.attribute]) {
                    gridSearch.searchValues[filter.attribute] = {};
                }
                this.createSearchable(gridSearch.searchFields, filter, schema);
                this.setPreSelectedValue(gridSearch, filter);

                const asc = this.createSortable(filter, true);
                gridSearch.sortables[asc.value] = asc;
                gridSearch.sortableFields.push(asc);
                const desc = this.createSortable(filter, false);
                gridSearch.sortables[desc.value] = desc;
                gridSearch.sortableFields.push(desc);
            });

            return gridSearch;
        }

        // clears the search and sort values and sets the preselected values
        clearGridSearchValues() {
            this.crudContextHolderService.clearGridSearchValues();
            this.setPreSelectedValues();
        }
    }

    crudSearchService["$inject"] = ["crudContextHolderService", "dispatcherService", "offlineAssociationService", "fieldService"];

    mobileServices.service("crudSearchService", crudSearchService);

})(mobileServices)
;
!(function (angular) {
    "use strict";

    function drillDownService($q, swdbDAO, crudContextHolderService, securityService, applicationStateService, loadingService) {
        let locationApp = "location";
        let assetApp = "asset";
        let isFlat = true;
        applicationStateService.getAppConfig().then((config) => {
            const client = config.server.client;
            if (client === "firstsolar") {
                locationApp = "offlinelocation";
                assetApp = "offlineasset";
                isFlat = false;
            }
        });


        //#region Utils
        const dd = () => crudContextHolderService.getCrudContext().drillDown;

        const getCurrentLocation = function() {
            const drillDown = crudContextHolderService.getCrudContext().drillDown;
            return drillDown.selectedLocation ? drillDown.selectedLocation.datamap.location : null;
        }

        const buildLocationClause = function (start, end) {
            const currentLocation = getCurrentLocation();
            if (currentLocation) {
                return ` (${start}${currentLocation}${end}) `;
            }

            const siteid = securityService.currentFullUser().SiteId;
            const pm = `PM${siteid}`;
            return ` (${start}${siteid}${end} OR ${start}${pm}${end} OR ${start}140${end} OR ${start}180${end}) `;
        }

        const updatePaginationOptions = function (drillDown) {
            drillDown.page++;
            drillDown.moreItemsAvailable = false;
            return { pagesize: 20, pageNumber: drillDown.page }
        }

        const setMoreItemsAvailable = function(drillDown, list) {
            drillDown.moreItemsAvailable = list.length === 20;
        }

        const locationSearchWc = (drillDown, alias) => drillDown.locationQuery ? ` and ${alias ? `\`${alias}\`.` : ""}datamap like '%${drillDown.locationQuery}%'` : "";

        const locationsQuery = function () {
            const drillDown = dd();
            if (drillDown.locationQuery) {
                const locationClause = isFlat ? " (1=1) " : buildLocationClause("`root`.textindex04 like '%/", "/%'");
                return ` \`root\`.application = '${locationApp}' and ${locationClause} ${locationSearchWc(drillDown, "root")} order by \`root\`.textindex01`;
            }
            const locationClause = isFlat ? " (1=1) " : buildLocationClause("`root`.datamap like '%\"parent\":\"", "\"%'");
            return ` \`root\`.application = '${locationApp}' and ${locationClause} order by \`root\`.textindex01`;
        }

        const assetSearchWc = (drillDown) => drillDown.assetQuery ? ` and \`root\`.datamap like '%${drillDown.assetQuery}%'` : "";

        const assetQuery = function (order) {
            const drillDown = dd();
            const orderClause = order ? " order by `root`.textindex02 " : "";
            const currentLocation = getCurrentLocation();

            if (isFlat && !currentLocation) {
                return ` \`root\`.application = '${assetApp}' ${assetSearchWc(drillDown)} ${orderClause} `;
            }

            const locationClause1 = buildLocationClause("`root`.textindex01 = '", "'");
            if (isFlat) {
                return ` \`root\`.application = '${assetApp}' ${assetSearchWc(drillDown)} and ${locationClause1} ${orderClause} `;
            }

            const locationClause2 = buildLocationClause("textindex04 like '%/", "/%'");
            return ` \`root\`.application = '${assetApp}' ${assetSearchWc(drillDown)} and (${locationClause1} or \`root\`.textindex01 in (select textindex01 from AssociationData where application = '${locationApp}' and ${locationClause2})) ${orderClause} `;
        }
        //#endregion

        const drillDownClear = function () {
            crudContextHolderService.drillDownClear();
        }

        const isOnDrillDown = function () {
            return crudContextHolderService.isOnDrillDown();
        }

        const getDrillDown = function () {
            return dd();
        }

        const updateDrillDownLocations = function () {
            loadingService.showDefault();

            const drillDown = dd();
            drillDown.page = 0;

            const promises = [];

            const currentLocation = getCurrentLocation();

            // location list
            if (isFlat && currentLocation) {
                promises.push($q.when([]));
            } else {
                promises.push(swdbDAO.findByQuery("AssociationData", locationsQuery(), updatePaginationOptions(drillDown)));
            }

            // location count
            if (isFlat && currentLocation) {
                promises.push($q.when(0));
            }else if (isFlat) {
                promises.push(swdbDAO.countByQuery("AssociationData", ` \`root\`.application = '${locationApp}' ${locationSearchWc(drillDown, "root")}`));
            } else {
                const locationClause1 = buildLocationClause("`root`.textindex04 like '%/", "/%'");
                promises.push(swdbDAO.countByQuery("AssociationData", ` \`root\`.application = '${locationApp}' and ${locationClause1} ${locationSearchWc(drillDown, "root")}`));
            }

            // asset count
            if (isFlat && !currentLocation) {
                promises.push(swdbDAO.countByQuery("AssociationData", ` \`root\`.application = '${assetApp}'`));
            } else {
                const locationClause2 = buildLocationClause("`root`.textindex01 = '", "'");
                const locationClause3 = buildLocationClause("textindex04 like '%/", "/%'");
                promises.push(swdbDAO.countByQuery("AssociationData", ` \`root\`.application = '${assetApp}' and (${locationClause2} or \`root\`.textindex01 in (select textindex01 from AssociationData where application = '${locationApp}' and ${locationClause3}))`));
            }

            return $q.all(promises).then((results) => {
                setMoreItemsAvailable(drillDown, results[0]);
                drillDown.locations = results[0];
                drillDown.locationsCount = results[1];
                drillDown.assetsCount = results[2];
                loadingService.hide();
                return drillDown.locations;
            });
        }

        const locationDrillDownClick = function (location) {
            const drillDown = dd();
            drillDown.locationHistory.push({
                location: drillDown.selectedLocation,
                query: drillDown.locationQuery
            });
            drillDown.selectedLocation = location;
            drillDown.locationQuery = undefined;
            return this.updateDrillDownLocations();
        }

        const drillDownBack = function () {
            const drillDown = dd();
            if (drillDown.assetView) {
                drillDown.assetView = false;
                return true;
            }

            if (drillDown.locationHistory.length === 0) {
                return false;
            }

            const locationHistoryEntry = drillDown.locationHistory.pop();
            drillDown.selectedLocation = locationHistoryEntry.location;
            drillDown.locationQuery = locationHistoryEntry.query;
            this.updateDrillDownLocations();
            return true;
        }

        const updateDrillDownAssets = function () {
            loadingService.showDefault();

            const drillDown = dd();
            drillDown.page = 0;

            const promises = [];
            promises.push(swdbDAO.findByQuery("AssociationData", assetQuery(true), updatePaginationOptions(drillDown)));
            promises.push(swdbDAO.countByQuery("AssociationData", assetQuery()));

            return $q.all(promises).then((results) => {
                setMoreItemsAvailable(drillDown, results[0]);
                drillDown.assets = results[0];
                drillDown.assetsCount = results[1];
                loadingService.hide();
                return drillDown.assets;
            });
        }

        const assetView = function () {
            const drillDown = dd();
            drillDown.assetView = true;
            drillDown.assetQuery = undefined;
            return this.updateDrillDownAssets();
        }

        const findAsset = function(assetNum) {
            return swdbDAO.findByQuery("AssociationData", ` \`root\`.application = '${assetApp}' and \`root\`.textindex02 = '${assetNum}'`).then((assets) => {
                return assets[0];
            });
        }

        const loadMore = function () {
            const drillDown = dd();
            if (!drillDown.assetView) {
                swdbDAO.findByQuery("AssociationData", locationsQuery(), updatePaginationOptions(drillDown)).then((newLocations) => {
                    setMoreItemsAvailable(drillDown, newLocations);
                    drillDown.locations = drillDown.locations.concat(newLocations);
                });
            } else {
                swdbDAO.findByQuery("AssociationData", assetQuery(true), updatePaginationOptions(drillDown)).then((newAssets) => {
                    setMoreItemsAvailable(drillDown, newAssets);
                    drillDown.assets = drillDown.assets.concat(newAssets);
                });
            }
        }

        const service = {
            drillDownClear,
            isOnDrillDown,
            getDrillDown,
            updateDrillDownLocations,
            locationDrillDownClick,
            drillDownBack,
            updateDrillDownAssets,
            assetView,
            findAsset,
            loadMore
        };

        return service;
    }

    mobileServices.factory("drillDownService", ["$q", "swdbDAO", "crudContextHolderService", "securityService", "applicationStateService", "loadingService", drillDownService]);
})(angular);;
(function (mobileServices) {
    "use strict";

    const compositionLoadedEvent = "sw:inline:compositions:resolved";

    class inlineCompositionService {
        constructor($rootScope, $q, offlineCompositionService, crudContextHolderService) {
            this.$rootScope = $rootScope;
            this.$q = $q;
            this.offlineCompositionService = offlineCompositionService;
            this.crudContextHolderService = crudContextHolderService;

            this.arrayToObj = function(array) {
                const obj = {};
                angular.forEach(array, (comp, idx) => {
                    obj[idx] = comp;
                });
                return obj;
            }

            this.objToArray = function (obj) {
                const array = [];
                angular.forEach(obj, (comp) => {
                    array.push(comp);
                });
                return array;
            }
        }

        loadInlineCompositions(item, datamap, allDisplayables, tabId = "main") {
            const promises = [];
            angular.forEach(allDisplayables, (displayable) => {
                if (displayable.type !== "ApplicationCompositionDefinition" || !displayable.inline || displayable.relationship in datamap) {
                    return;
                }

                const promise = this.offlineCompositionService.loadCompositionList(item, displayable);
                promises.push(promise);

                datamap[displayable.relationship] = [];
                promise.then((compositionList) => {
                    // array to obj to keep angular copy and catch changes to know if it's dirty
                    datamap[displayable.relationship] = this.arrayToObj(compositionList);
                });
            });
            return this.$q.all(promises).then(() => {
                const context = this.crudContextHolderService.getCrudContext();
                context.originalDetailItemDatamap = angular.copy(datamap);
                angular.forEach(allDisplayables, (displayable) => {
                    if (displayable.type === "ApplicationCompositionDefinition" && displayable.inline && datamap[displayable.relationship] && typeof datamap[displayable.relationship] === "object") {
                        datamap[displayable.relationship] = this.objToArray(datamap[displayable.relationship]);
                        context.originalDetailItemDatamap[displayable.relationship] = this.objToArray(context.originalDetailItemDatamap[displayable.relationship]);
                    }
                });
                return this.$rootScope.$broadcast(compositionLoadedEvent, tabId);
            });
        }

        cancelChanges() {
            this.$rootScope.$broadcast(compositionLoadedEvent);
        }

        compositionLoadedEventName() {
            return compositionLoadedEvent;
        }
    }

    inlineCompositionService["$inject"] = ["$rootScope", "$q", "offlineCompositionService", "crudContextHolderService"];

    mobileServices.service("inlineCompositionService", inlineCompositionService);

})(mobileServices)
;

(function (angular) {
    'use strict';
    //used at the offline solution, do not remove
    angular.module('sw_mobile_services').factory('notificationViewModel', ['contextService', '$timeout', '$log', notificationViewModel]);
    function notificationViewModel(contextService, $timeout, $log) {
        var log = $log.getInstance('sw4.notificationViewModel');

        //#region Utils
        var vm = {
            messages: []
        };

        //#endregion
        //#region Private Methods

        function getMessages() {
            return vm.messages;
        }

        return {
            /// <summary>
            /// Receive message data and crete user notification
            /// </summary>
            /// <param name="type" type="string">Optional, [dev, error, info (default), null, success]</param>
            /// <param name="title" type="string">Optional, if no value the default title will be used based on the data.type. For consistency the default title should be used</param>
            /// <param name="body" type="string">Required, message text to display</param>
            /// <param name="exceptionType" type="string">Optional, display in more info modal</param>
            /// <param name="exceptionOutline" type="string">Optional, display in more info modal</param>
            /// <param name="exceptionStack" type="string">Optional, display in more info modal</param>
            /// <returns></returns>
            createNotification: function (type, title, body, exceptionType, exceptionOutline, exceptionStack) {

                //build the message object
                var message = {};
                message.type = type;
                message.title = title;
                message.body = body;
                message.display = true;

                //if any exception info is present, create the exception object
                if (exceptionType || exceptionOutline || exceptionStack) {
                    var exception = {};
                    exception.type = exceptionType;
                    exception.outline = exceptionOutline;
                    exception.stack = exceptionStack;
                    message.exception = exception;
                }

                //broad the notification event
                if (message.body) {
                    log.debug('createNotification', message);

                    $timeout(function () {
                        vm.messages.push(message);
                    });

                    //add automatic timeout for success messages
                    if (message.type === 'success' && !message.exception) {
                        $timeout(function () {
                            //$scope.removeMessage(message);
                            message.display = false;
                        }, contextService.retrieveFromContext('successMessageTimeOut'));
                    }
                }
            },

            /// <summary>
            /// Return the data for the more info modal
            /// </summary>
            /// <param name="message" type="object">Notification message</param>
            /// <returns></returns>
            getMoreInfo: function (message) {
                //setup more info temporary store
                var moreInfo = message.exception;
                moreInfo.title = message.body;
                moreInfo.text = ('Error description:\n\n' +
                    'Type: \n{0}\n\n' +
                    'Message: \n{1}\n\n' +
                    'Outline:\n{2}\n\n' +
                    'StackTrace:\n{3}\n\n')
                .format(moreInfo.type, moreInfo.title, moreInfo.outline, moreInfo.stack);

                return moreInfo;
            },

            /// <summary>
            /// Hide the user selected message
            /// </summary>
            /// <param name="message" type="object">Notification message</param>
            /// <returns></returns>
            removeNotification: function (message) {
                log.debug('removeMessage', message);
                message.display = false;
            },

            messages: getMessages()
        }

        //#endregion
    }
})(angular);;
!(function (angular) {
    "use strict";

    function problemService($q, swdbDAO, offlineEntities, crudContextHolderService) {

        function updateProblem(hasProblem, dataEntriesIds) {
            if (dataEntriesIds.length === 0) {
                return $q.when(null);
            }

            var whereClause = dataEntriesIds.map(id => `id='${id}' or `).join(""); // using id in (?) did not work for some reason...
            whereClause = whereClause.substring(0, whereClause.lastIndexOf(" or "));
            const queryStr = `update DataEntry set hasProblem=${hasProblem ? 1 : 0} where (${whereClause})`;

            return swdbDAO.executeQuery(queryStr);
        }

        function rejectProblematicQuickSync(quickSyncItem) {
            if (quickSyncItem && quickSyncItem.hasProblem) {
                // forces the promise chain to stop and avoid 
                // overriding a problem item with its previous state in case of an update
                return $q.reject("It was not possible to sync.");
            }
            return $q.when(null);
        }

        function locateBatchItemProblems(problemContext, batchItem) {
            const targetIds = batchItem.problem ? problemContext.problematicIds : problemContext.okIds;
            const id = batchItem.dataentry.id;
            if (problemContext.quickSyncItem && problemContext.quickSyncItem.id === id) {
                problemContext.quickSyncItem.hasProblem = !!batchItem.problem;
                crudContextHolderService.updateCurrentProblem(batchItem.problem);
            }
            targetIds.push(id);
        }

        function locateBatchProblems(problemContext, batch) {
            const deferred = $q.defer();
            persistence.transaction(tx => {
                batch.items.list(tx, batchItems => {
                    angular.forEach(batchItems, batchItem => {
                        locateBatchItemProblems(problemContext, batchItem);
                    });
                    deferred.resolve();
                });
            });
            return deferred.promise;
        }

        function updateHasProblemToDataEntries(batches, quickSyncItem) {
            if (!batches || batches.length === 0) {
                return $q.when(batches);
            }

            const problemContext = {
                okIds: [],
                problematicIds: [],
                quickSyncItem: quickSyncItem
            }

            const batchPromises = [];

            angular.forEach(batches, batch => {
                const batchDeferred = $q.defer();
                batchPromises.push(batchDeferred.promise);

                try {
                    locateBatchProblems(problemContext, batch).then(() => batchDeferred.resolve());
                } catch (e) {
                    batchDeferred.reject(e);
                }
            });

            return $q.all(batchPromises)
                .then(() =>
                    updateProblem(false, problemContext.okIds))
                .then(() =>
                    updateProblem(true, problemContext.problematicIds))
                .then(() =>
                    rejectProblematicQuickSync(quickSyncItem))
                .then(() => batches);
        }

        function getProblems(dataEntryId) {
            return swdbDAO.executeQuery({ query: offlineEntities.DataEntry.findProblems, args: [dataEntryId] });
        }

        function deleteRelatedProblems(dataEntryId) {
            return getProblems(dataEntryId)
                .then(problems =>
                    swdbDAO.executeQuery(`delete from Problem where id in (${problems.map(p => `'${p.id}'`)})`)
                );
        }

        const service = {
            updateHasProblemToDataEntries: updateHasProblemToDataEntries,
            getProblems: getProblems,
            deleteRelatedProblems
        };

        return service;
    }

    mobileServices.factory("problemService", ["$q", "swdbDAO", "offlineEntities", "crudContextHolderService", problemService]);
})(angular);;
!(function (angular) {
    "use strict";


    function searchIndexService(dispatcherService, offlineSchemaService) {


        var indexColumnCache = {}; // cache of attribute -> index column
        const orderByBlackList = ["asc", "desc", "is", "null"]; // list of ignored terms on order by parsing
        //key = application name , value = array of columns
        const applicationSortColumnCache = new Map();


        //#region utils

        // build a string with two digits 2 -> 02, 10 -> 10
        const padToTwo = number => number <= 99 ? (`0${number}`).slice(-2) : number;

        // create a cache of attribute -> index column
        const parseIndexColumn = function (cache, indexList, prefix) {
            angular.forEach(indexList, (indexAttribute, i) => {
                var trimmed = indexAttribute.trim();
                if (!trimmed) {
                    return;
                }
                cache[trimmed] = "`root`." + prefix + padToTwo(i + 1);
            });
        }

        // create a cache of attribute -> index column
        const buildIndexColumnCache = function (listSchema) {
            const appCache = {};
            if (!listSchema || !listSchema.properties) {
                return appCache;
            }

            const textIndexes = listSchema.properties["list.offline.text.indexlist"];
            if (textIndexes) {
                parseIndexColumn(appCache, textIndexes.split(","), "textindex");
            }

            const numericIndexes = listSchema.properties["list.offline.numeric.indexlist"];
            if (numericIndexes) {
                parseIndexColumn(appCache, numericIndexes.split(","), "numericindex");
            }

            const dateIndexes = listSchema.properties["list.offline.date.indexlist"];
            if (dateIndexes) {
                parseIndexColumn(appCache, dateIndexes.split(","), "dateindex");
            }

            return appCache;
        }

        // parses a term of order by replacing attributes for index columns
        const parseOrderByTerm = function (appName, listSchema, orderByTerm) {
            const tokens = orderByTerm.split(/[\s]+/);
            const parsedTokens = [];
            angular.forEach(tokens, token => {
                const trimmed = token.trim();
                if (!trimmed) {
                    return;
                }
                if (orderByBlackList.indexOf(trimmed) >= 0) {
                    parsedTokens.push(trimmed);
                    return;
                }
                var columnSet = applicationSortColumnCache.get(appName);
                if (!columnSet) {
                    columnSet = new Set();
                    applicationSortColumnCache.set(appName, columnSet);
                }
                columnSet.add(trimmed);
                var indexColumn = getIndexColumn(appName, listSchema, trimmed);
                parsedTokens.push(indexColumn || trimmed);
            });

            return parsedTokens.join(" ");
        }

        // builds a search where clause for a single search field
        const buildAttributeQuery = function (appName, listSchema, gridSearch, searchValue, attribute) {
            const indexColumn = getIndexColumn(appName, listSchema, attribute);
            if (!indexColumn) {
                return "";
            }

            const field = gridSearch.searchFields[attribute];
            if (!field) {
                return "";
            }

            if (field.type === "MetadataDateTimeFilter" || field.dataType === "date") {
                if (!searchValue.startUTC && !searchValue.endUTC) {
                    return "";
                }

                let query = "";
                if (searchValue.startUTC) {
                    query += ` and ${indexColumn} >= ${searchValue.startUTC.getTime()} `;
                }
                if (searchValue.endUTC) {
                    query += ` and ${indexColumn} <= ${searchValue.endUTC.getTime()} `;
                }
                return query;
            }

            if (field.type === "MetadataOptionFilter") {
                if (!searchValue.value || !searchValue.value.trim()) {
                    return "";
                }
                const terms = searchValue.value.split(";");
                const termQueries = [];
                angular.forEach(terms, term => {
                    var trimmed = term.trim();
                    if (!trimmed) {
                        return;
                    }

                    if (!field.whereClause) {
                        termQueries.push(`${indexColumn} = '${term}'`);
                        return;
                    }

                    if (field.whereClause.startsWith("@")) {
                        const serviceString = field.whereClause.substring(1);
                        termQueries.push(dispatcherService.invokeServiceByString(serviceString, [term]));
                    }

                    // TODO: add support for option filter whereclauses that are not services
                });

                return ` and (${termQueries.join(" or ")}) `;
            }

            if (!searchValue.value || !searchValue.value.trim()) {
                return "";
            }

            return ` and ${indexColumn} like '%${searchValue.value}%' `;
        }
        //#endregion

        // builds an array of index values parameters to be stored on client db
        const buildIndexes = function (textIndexes, numericIndexes, dateIndexes, newDataMap) {

            const indexesData = {
                t1: null,
                t2: null,
                t3: null,
                t4: null,
                t5: null,
                n1: null,
                n2: null,
                d1: null,
                d2: null,
                d3: null
            };

            if (textIndexes) {
                angular.forEach(textIndexes, (indexName, i) => {
                    indexesData[`t${i + 1}`] = newDataMap[indexName] || null;
                });
            }

            if (numericIndexes) {
                angular.forEach(numericIndexes, (indexName, i) => {
                    indexesData[`n${i + 1}`] = newDataMap[indexName] || null;
                });
            }

            if (dateIndexes) {
                angular.forEach(dateIndexes, (indexName, i) => {
                    const value = newDataMap[indexName];
                    var convertedValue;
                    if (!value) {
                        convertedValue = null;
                    } else {
                        convertedValue = new Date(value).getTime();
                    }
                    indexesData[`d${i + 1}`] = convertedValue;
                });
            }

            return indexesData;
        };

        // gets the index columns given the attribute, or all of them if the attribute is no passed
        const getIndexColumn = function (appName, listSchema, attribute) {



            if (!indexColumnCache[appName]) {
                indexColumnCache[appName] = buildIndexColumnCache(listSchema);
            }
            if (!attribute) {
                //to retrieve the list of all indexes
                return indexColumnCache[appName];
            }

            if (attribute.startsWith("#") && attribute.contains(".")) {
                //this means we are referring to a related joined schema that needs to be resolved on the offline
                //letÂ´s locate the appropriate index on that schema instead
                const entityData = offlineSchemaService.findRelatedEntityName(attribute);
                const entityName = entityData.entityName;
                const relatedSchema = offlineSchemaService.locateRelatedListSchema(listSchema, entityName);
                const relatedAppName = relatedSchema.applicationName;
                if (!indexColumnCache[relatedAppName]) {
                    indexColumnCache[relatedAppName] = buildIndexColumnCache(relatedSchema);
                }
                return indexColumnCache[relatedAppName][entityData.attribute].replace("`root`", "`" + entityName + "`");
            }

            return indexColumnCache[appName][attribute];
        }

        // builds the default order by replacing attributes for index columns
        const buildDefaultOrderBy = function (appName, listSchema, defaultOrderBy) {
            if (!defaultOrderBy) {
                return "";
            }

            const terms = defaultOrderBy.split(",");
            const parsedTerms = [];

            angular.forEach(terms, term => {
                if (!term) {
                    return;
                }
                parsedTerms.push(parseOrderByTerm(appName, listSchema, term));
            });

            return parsedTerms.join(", ");
        }

        // builds the search where clause
        const buildSearchQuery = function (appName, listSchema, gridSearch) {
            if (!gridSearch.searchValues) {
                return "";
            }

            var query = " ";
            angular.forEach(gridSearch.searchValues, (searchValue, attribute) => {
                if (!gridSearch.searchValues.hasOwnProperty(attribute)) {
                    return;
                }
                query += buildAttributeQuery(appName, listSchema, gridSearch, searchValue, attribute) + " ";
            });

            return query;
        }

        // builds the sort where clause
        const buildSortQuery = function (appName, listSchema, gridSearch) {
            if (gridSearch.sort && gridSearch.sort.attribute && listSchema) {
                const indexColumn = getIndexColumn(appName, listSchema, gridSearch.sort.attribute);
                if (indexColumn) {
                    const direction = gridSearch.sort.direction;
                    if (indexColumn.startsWith("text")) {
                        return ` order by \`root\`.isDirty desc, ${indexColumn} is null ${direction}, lower(${indexColumn}) ${direction} `;
                    }
                    return ` order by \`root\`.isDirty desc, ${indexColumn} is null ${direction}, ${indexColumn} ${direction} `;
                }
            }

            if (listSchema && listSchema.properties) {
                const orderBy = listSchema.properties["list.defaultorderby"];
                if (orderBy) {
                    const parsedOrderBy = buildDefaultOrderBy(appName, listSchema, orderBy);
                    return ` order by \`root\`.isDirty desc, ${parsedOrderBy}`;
                }
            }
            return " order by \`root\`.isDirty desc, \`root\`.rowstamp is null desc, \`root\`.rowstamp desc ";
        }

        const innerParseWhereClause = function (whereClause, datamap, parameters) {
            angular.forEach(parameters, parameter => {
                const parameterName = parameter.substring(1);
                const value = datamap[parameterName] || "";
                whereClause = whereClause.replace(new RegExp(parameter, "g"), `'${value}'`);
            });
            return whereClause;
        }

        const parseWhereClause = function (whereClause, datamap) {
            const parameterRegex = /@[\w]+/g;
            let parameters = parameterRegex.exec(whereClause);
            while (parameters) {
                whereClause = innerParseWhereClause(whereClause, datamap, parameters);
                parameters = parameterRegex.exec(whereClause);
            }
            return whereClause;
        }

        const refreshIndexCaches = function () {
            applicationSortColumnCache.clear();
            indexColumnCache = {};
        }

        const getSearchColumnsByApp = function (applicationName) {
            const set = applicationSortColumnCache.get(applicationName);
            return set ? Array.from(set) : [];
        }

        const service = {
            buildIndexes,
            getIndexColumn,
            buildDefaultOrderBy,
            buildSearchQuery,
            buildSortQuery,
            getSearchColumnsByApp,
            parseWhereClause,
            refreshIndexCaches
        };

        return service;

    }

    mobileServices.factory("searchIndexService", ["dispatcherService", "offlineSchemaService", searchIndexService]);
})(angular);;
!(function (angular) {
    "use strict";

    function wizardService(crudContextHolderService, crudContextService) {

        const wizardBehaviors = {
            SHOW: "show", // show wizards fields on last screen
            HIDE: "hide", // hide the wizard fileds on the last screen
            READ_ONLY: "readonly" // show wizards fields on last screen but read only
        }

        const allBehaviors = [];
        angular.forEach(wizardBehaviors, behavior => {
            allBehaviors.push(behavior);
        });

        const modelCache = {}

        const getBehavior = function (displayable) {
            const behavior = displayable.rendererParameters["wizardBehavior"];
            if (!behavior || allBehaviors.indexOf(behavior.toLowerCase()) < 0) {
                return wizardBehaviors.HIDE;
            }
            return behavior.toLowerCase();
        }

        const buildWizardModel = function (application, displayables) {
            const appModel = {
                states: [],
                allWizardFields: {}
            };
            modelCache[application] = appModel;
            if (!displayables) {
                return appModel;
            }

            angular.forEach(displayables, displayable => {
                if (!displayable.attribute) {
                    return;
                }
                const parameters = displayable.rendererParameters;
                if (!parameters) {
                    return;
                }
                const indexString = parameters["wizard"];
                if (nullOrUndef(indexString)) {
                    return;
                }
                const index = Number(indexString);
                if (isNaN(index)) {
                    return;
                }
                var state = appModel.states[index];
                if (!state) {
                    state = {
                        fields: {}
                    }
                    appModel.states[index] = state;
                }
                const fieldModel = {
                    attribute: displayable.attribute,
                    behavior: getBehavior(displayable)
                }

                state.fields[displayable.attribute] = fieldModel;
                appModel.allWizardFields[displayable.attribute] = fieldModel;
            });

            const nullSafeStates = [];
            angular.forEach(appModel.states, (state, index) => {
                if (appModel.states[index]) {
                    nullSafeStates.push(state);
                }
            });
            appModel.states = nullSafeStates;

            return appModel;
        }

        const getModel = function (application, displayables) {
            var model = modelCache[application];
            if (model) {
                return model;
            }
            model = buildWizardModel(application, displayables);
            return model;
        }

        const getModelAlso = function (displayables) {
            if (!crudContextService.isCreation()) {
                return null;
            }
            const application = crudContextHolderService.currentApplicationName();
            return getModel(application, displayables);
        }

        const nonWizardFields = function (application, displayables) {
            const appModel = getModel(application, displayables);
            if (appModel.states.length === 0) {
                return displayables;
            }
            
            const allWizardFields = appModel.allWizardFields;
            const nonWizardFieldsArray = [];
            angular.forEach(displayables, displayable => {
                if (!displayable.attribute) {
                    nonWizardFieldsArray.push(displayable);
                    return;
                }

                const fieldModel = allWizardFields[displayable.attribute];
                if (!fieldModel || fieldModel.behavior !== wizardBehaviors.HIDE) {
                    nonWizardFieldsArray.push(displayable);
                }
            });
            return nonWizardFieldsArray;
        }

        const innerGetWizardFields = function (displayables, stateIndex) {
            if (!crudContextService.isCreation() || !displayables) {
                return displayables;
            }

            const application = crudContextHolderService.currentApplicationName();

            const appModel = getModel(application, displayables);
            const state = appModel.states[stateIndex];
            if (!state) {
                return nonWizardFields(application, displayables);;
            }

            const wizardFields = [];
            angular.forEach(displayables, displayable => {
                if (!displayable || !displayable.attribute) {
                    return;
                }
                if (state.fields[displayable.attribute]) {
                    wizardFields.push(displayable);
                }
            });
            return wizardFields;
        }

        const getWizardFields = function (displayables) {
            const crudContext = crudContextService.getCrudContext();
            return innerGetWizardFields(displayables, crudContext.wizardStateIndex);
        }

        const next = function (displayables) {
            const crudContext = crudContextService.getCrudContext();
            crudContext.wizardStateIndex++;
            return innerGetWizardFields(displayables, crudContext.wizardStateIndex);
        }

        const previous = function (displayables) {
            const crudContext = crudContextService.getCrudContext();
            crudContext.wizardStateIndex--;
            if (crudContext.wizardStateIndex < 0) {
                crudContext.wizardStateIndex = 0;
            }
            return innerGetWizardFields(displayables, crudContext.wizardStateIndex);
        }

        const getWizardState = function(displayables) {
            const appModel = getModelAlso(displayables);
            if (!appModel) {
                return null;
            }
            const crudContext = crudContextService.getCrudContext();
            return appModel.states[crudContext.wizardStateIndex];
        }

        const isInWizardState = function (displayables) {
            return !!(getWizardState(displayables));
        }

        const canReturn = function () {
            if (!crudContextService.isCreation()) {
                return false;
            }
            const crudContext = crudContextService.getCrudContext();
            return crudContext.wizardStateIndex > 0;
        }

        const isReadOnly = function(displayable, allDisplayables) {
            if (!displayable.attribute) {
                return false;
            }
            const appModel = getModelAlso(allDisplayables);
            if (!appModel) {
                return false;
            }

            const crudContext = crudContextService.getCrudContext();
            const state =  appModel.states[crudContext.wizardStateIndex];
            if (state) {
                return false;
            }

            const fieldModel = appModel.allWizardFields[displayable.attribute];
            return fieldModel && fieldModel.behavior === wizardBehaviors.READ_ONLY;
        }

        const service = {
            getWizardFields,
            isInWizardState,
            canReturn,
            next,
            previous,
            isReadOnly
        };

        return service;
    }

    mobileServices.factory("wizardService", ["crudContextHolderService", "crudContextService", wizardService]);
})(angular);;
(function (mobileServices, angular) {
    "use strict";

    mobileServices.factory("datamapSanitizationService", service);

    function service() {
        
        // holds the sanitizer functions to be applied to a datamap
        var sanitizationPipeline = [
            // escapes single quotes
            function (datamap) {
                return replaceAll(datamap, "'", "\\'");
            }
            //, future sanitization processes
        ];

        var api = {
            sanitize: sanitize,
            enforceNumericType: enforceNumericType
        };

        return api;

        function enforceNumericType(datamap, displayables) {
            if (!datamap || !displayables) {
                return;
            }
            angular.forEach(displayables, function (field) {
                if (field.rendererType !== "numericinput" || field.rendererParameters["numberType"] === "double" || field.rendererParameters["numberType"] === "float") {
                    return;
                }
                if (!datamap[field.attribute]) {
                    return;
                }
                datamap[field.attribute] = parseInt(datamap[field.attribute]);
            });
        };

        function sanitize(datamap) {
            if (!datamap) {
                return datamap;
            }
            var sanitizedDataMap = angular.isString(datamap) ? angular.copy(datamap) : JSON.stringify(datamap);
            // executes each sanitizer passing the result to the next in line
            sanitizationPipeline.forEach(function (sanitizer) {
                sanitizedDataMap = sanitizer(sanitizedDataMap);
            });
            return sanitizedDataMap;
        };


    };

    // service.$inject = [];



})(mobileServices, angular);
;
(function (angular) {
    "use strict";

    function itemActionService($q,$rootScope, synchronizationFacade, crudContextService, $ionicPopup, laborService, alertService) {
        //#region Utils
        //#endregion

        //#region Public methods

        /**
         * Checks if current item can be quicksynced 
         * i.e. isDirty and does not have unsaved changes.
         * 
         * @returns {Boolean} 
         */
        function shouldAllowQuickSyncForCurrentItem() {
            const item = crudContextService.currentDetailItem();
            return !!item && item.isDirty && !crudContextService.hasDirtyChanges();
        }

        /**
         * Checks if the current item can be deleted or restored.
         * 
         * @returns {Boolean} 
         */
        function shouldAllowDeleteOrRestoreForCurrentItem() {
            const item = crudContextService.currentDetailItem();
            if (!item) {
                return false;
            }
            const restorable = item.remoteId && item.isDirty && !!item.originaldatamap;
            const deletable = !item.remoteId;
            return !item.pending && (restorable || deletable) && !crudContextService.hasDirtyChanges();
        }

        /**
         * Quicksyncs current item.
         * If successful will redirect to the grid.
         * 
         * @returns {Promise<Void>} 
         */
        function quickSyncCurrentItem() {
            const item = crudContextService.currentDetailItem();
            return synchronizationFacade.syncItem(item)
                .then(() => crudContextService.refreshGrid())
                .then(() => $ionicPopup.alert({
                    title: "Quick Sync",
                    template: alertService.buildCenteredTemplate("Sync Successful")
                }))
                .catch(error => $ionicPopup.alert({
                    title: "Quick Sync",
                    template: alertService.buildCenteredTemplate(error.message || "An error happened during sync")
                }));
        }

        /**
         * Attempts to delete or restore the item to it's original state (from server).
         * 
         * @returns {Promise<Boolean>} whether or not the item was deleted/restored 
         */
        function deleteOrRestoreItem(item) {
            const restorable = item.remoteId && item.isDirty && !!item.originaldatamap;
            const deletable = !item.remoteId;

            if (item.pending || (!restorable && !deletable)) {
                return $q.when(false);
            }

            const currentTitle = crudContextService.currentTitle();

            const confirmConfig = restorable
                ? { title: "Cancel Changes", template: `Are you sure you want to cancel changes made to this ${currentTitle}` }
                : { title: `Delete ${currentTitle}`, template: `Are you sure you want to delete this ${currentTitle} created locally` }

            return $ionicPopup.confirm(confirmConfig).then(res => {
                if (!res) return false;

                // clears the current labor cache if the item being deleted or restored is the current parent of the labor
                laborService.clearLaborCacheIfCurrentParent(item);

                const promise = restorable
                    ? crudContextService.restoreItemToOriginalState(item)
                    : crudContextService.deleteLocalItem(item);

                return promise
                    .then(() => $ionicPopup.alert({ title: `${currentTitle} was successfuly ${restorable ? "restored" : "deleted"}` }))
                    .then(()=> $rootScope.$broadcast("sw_itemrestored",item))
                    .then(() => true);
            });
        }

        /**
         * Attempts to delete or restore the current item to it's original state (from server).
         * If successfull, will redirect to the grid.
         * 
         * @returns {Promise<Void>}
         */
        function deleteOrRestoreCurrentItem() {
            const item = crudContextService.currentDetailItem();
            return deleteOrRestoreItem(item).then(res => res ? crudContextService.refreshGrid() : null);
        }

        //#endregion

        //#region Service Instance
        const service = {
            quickSyncCurrentItem,
            deleteOrRestoreCurrentItem,
            deleteOrRestoreItem,
            shouldAllowQuickSyncForCurrentItem,
            shouldAllowDeleteOrRestoreForCurrentItem
        };
        return service;
        //#endregion
    }

    //#region Service registration

    angular.module("sw_mobile_services")
        .factory("itemActionService", ["$q","$rootScope", "synchronizationFacade", "crudContextService", "$ionicPopup", "laborService", "alertService", itemActionService]);

    //#endregion

})(angular);;
(function (angular) {
    'use strict';

    class laborTimeSheetIconProvider {

        constructor() {

        }

        //#region Public methods
        getIconClass(item) {
            if (item.datamap["#runninglabor"]){
                return "hasaction";
            }
            return item.datamap.labtransid != null ? null : "isdirty";
        }

        getIconIcon(item) {
            if (item.datamap["#runninglabor"]){
                return "clock-o";
            }

            return item.datamap.labtransid != null ? "check" : "refresh";
        }

        getIconColor(item){
            return item.datamap.labtransid != null ? "#39b54a" : "refresh";
        }

        getIconText(item){
            return "";
        }

        getTextColor(item){
            return item.datamap.labtransid != null ? "white" : null;
        }


    }


    laborTimeSheetIconProvider['$inject'] = [];

    angular.module('sw_mobile_services').service('laborTimeSheetIconProvider', laborTimeSheetIconProvider);

})(angular);;
(function (angular, _) {
    "use strict";

    function laborService(dao, securityService, localStorageService, crudContextService, $ionicPopup, $q, $log, offlineSchemaService, offlineSaveService, $rootScope, menuModelService,fsLaborOfflineService, metadataModelService) {
        //#region Utils

        const truncateDecimal = value => parseFloat(value.toFixed(2));

        let parentIdCache = null;
        let laborCache = null;

        // init cache
        dao.findUnique("ActiveLaborTracker").then((tracker) => {
            if (!tracker) {
                return;
            }

            parentIdCache = tracker.parentid;
            dao.findById("DataEntry", parentIdCache).then((parent) => {
                if (!parent || !parent.datamap || !parent.datamap["labtrans_"]) {
                    return;
                }
                const labTrans = parent.datamap["labtrans_"];
                angular.forEach(labTrans, (labor) => {
                    if (labor[constants.localIdKey] === tracker.laborlocalid) {
                        laborCache = labor;
                    }
                });
            });
        });

        function trackStartedLabor(parentId, labor) {
            parentIdCache = parentId;
            laborCache = labor;
            return dao.instantiate("ActiveLaborTracker", { parentid: parentIdCache, laborlocalid: labor[constants.localIdKey] }).then(tracker => dao.save(tracker));
        }

        function clearTrackedLabor() {
            return dao.executeQuery("delete from ActiveLaborTracker").then(() => {
                parentIdCache = null;
                laborCache = null;
            });
        }

        function calculateLineCost(regularhours, payrate) {
            const calcHours = !regularhours ? 0 : parseFloat(regularhours);
            const calcRate = !payrate ? 0 : parseFloat(payrate);
            const linecost = calcHours * calcRate;
            return _.isNaN(linecost) ? 0 : truncateDecimal(linecost);
        }

        const getActiveLabor = () => laborCache;

        const getActiveLaborParent = () => parentIdCache;

        const hasActiveLabor = () => !!getActiveLabor();

        function hasActiveLaborForCurrent() {
            const parent = crudContextService.currentDetailItem();
            return !parent || !parent.id || !hasActiveLabor()
                ? false
                : parent.id === getActiveLaborParent();
        }

        const getLabTransDetailSchema = () => crudContextService.currentCompositionSchemaById("labtrans", "detail");

        const getLabTransMetadata = () => {
            const laborMetadata = crudContextService.currentCompositionTabByName("labtrans");
            if (laborMetadata){
                return $q.when(laborMetadata);
            }
            const metadataDef = metadataModelService.getCompositionByName("labtrans");
            //this is an adaptation since the next layers expected to receive the Composition displable definition, rather than the DB application definition
            //TODO: make it properly
            metadataDef.attribute = metadataDef.data.role;
            metadataDef.associationKey = metadataDef.data.role + "_";

            return $q.when(metadataDef);

        }

        const insertTsLaborDataEntry = (labor, datamap, runningLabor = false) =>{
            //TODO: check for client
            labor["refwo"] = datamap.wonum;
            labor["wodescription"] =datamap["description"];
            fsLaborOfflineService.insertTsLaborDataEntry(labor, runningLabor);
        }

        function setInitialLaborAndCraft(datamap, overrideRegularHours) {
            const currentUser = securityService.currentFullUser();
            return dao.findSingleByQuery("AssociationData", `application = 'labor' and datamap like '%"personid":"${currentUser.PersonId}"%'`)
                .then(association => {
                    if (!association) return $q.reject(new Error(`There is no labor registered for the current user with personid '${currentUser.PersonId}'`));

                    const labor = association.datamap;
                    datamap["laborcode"] = labor.laborcode;
                    datamap["labor_.worksite"] = labor.worksite;
                    datamap["labor_.orgid"] = labor.orgid;

                    return dao.findSingleByQuery("AssociationData", `application = 'laborcraftrate' and datamap like '%"laborcode":"${labor.laborcode}"%'`);
                })
                .then(association => {
                    if (!association) return $q.reject(new Error(`There is no laborcraftrate registered for the labor '${datamap["laborcode"]}'`));

                    const craft = association.datamap;
                    datamap["craft"] = craft.craft;
                    const payrate = craft.rate;
                    datamap["payrate"] = payrate;

                    if (angular.isNumber(overrideRegularHours) && overrideRegularHours >= 0) {
                        datamap["regularhrs"] = overrideRegularHours;
                    }

                    datamap["linecost"] = calculateLineCost(datamap["regularhrs"], payrate);

                    return datamap;
                })
                .catch(error =>
                    $ionicPopup.alert({ title: "Labor Reporting Error", template: error.message }).then(() => $q.reject(error))
                );
        }

        function saveLabor(parent, labor, inCurrentParent, saveCustomMessage,showConfirmationMessage, starting) {
            const application = parent != null? parent.application : crudContextService.currentApplicationName();
            return getLabTransMetadata().then(laborMetadata=>{
                return offlineSaveService.addAndSaveComposition(application, parent, labor, laborMetadata, saveCustomMessage, showConfirmationMessage)
                .then(savedParent => {
                    const context = crudContextService.getCrudContext();
                    if (!!inCurrentParent) {
                        // update the current detail context
                        // context.originalDetailItemDatamap = savedParent.datamap;
                    } else {
                        // find the correct parent in the list and update it
                        const parentIndex = context.itemlist.findIndex(i => i.id === savedParent.id);
                        if (parentIndex >= 0) context.itemlist[parentIndex] = savedParent;
                    }
                    return labor;
                }).then(insertTsLaborDataEntry(labor,parent.datamap,starting));
            })
     
        }

        function doStartLaborTransaction() {
            const parent = crudContextService.currentDetailItem();

            const laborDetailSchema = getLabTransDetailSchema();
            const labor = { "_newitem#$": true };
            offlineSchemaService.fillDefaultValues(laborDetailSchema, labor, parent.datamap);

            return setInitialLaborAndCraft(labor, 0)
                .then(initialized => saveLabor(parent, initialized, true, "Labor Timer Started",false,true))
                .then(saved => {
                    return trackStartedLabor(parent.id, saved).then(() => {
                        menuModelService.updateAppsCount();
                        $rootScope.$broadcast("sw.labor.start");
                        return saved;
                    });
                });
        }

        function doStopLaborTransaction(parent, showConfirmationMessage) {
            const labor = getActiveLabor();
            const startdate = new Date(labor["startdate"]);
            const hoursDelta = ((new Date().getTime() - startdate.getTime()) / (1000 * 60 * 60));
            const hours = truncateDecimal(hoursDelta); // truncating and rounding to have 2 decimal
            labor["regularhrs"] = hours === 0 ? 0.01 : hours;
            labor["linecost"] = calculateLineCost(hours, labor["payrate"]);

            const stopingOnCurrentParent = !parent;
            const realParent = parent || crudContextService.currentDetailItem();


            return saveLabor(realParent, labor, stopingOnCurrentParent, "Labor Timer Stopped", showConfirmationMessage,false).then(() => {
                return clearTrackedLabor().then(() => {
                    $rootScope.$broadcast("sw.labor.stop");
                    return labor;
                });
            });
        }

        //#endregion

        //#region Public methods

        function shouldAllowLaborStart() {
            return !hasActiveLaborForCurrent();
        }

        function shouldAllowLaborFinish() {
            return hasActiveLaborForCurrent();
        }

        function showLaborCreationCommand() {
            return crudContextService.addCompositionAllowed() && shouldAllowLaborStart();
        }

        function showLaborFinishCommand() {
            return crudContextService.addCompositionAllowed() && shouldAllowLaborFinish();
        }

        function startLaborTransactionWhenLaborAlreadyStarted(parent) {
            return $ionicPopup.confirm({
                title: "Labor Reporting",
                template: "There's a labor timer started. Would you like to stop it in order to start a new one?"
            }).then(res => {
                if (res) {
                    // user wants to stop the current: stop it then start a new one
                    return doStopLaborTransaction(parent).then(() => doStartLaborTransaction());
                }
                // user does not wish to stop the previous: do nothing
                return null;
            });
        }

        /**
         * Starts a labor reporting/transaction on the current parent entity.
         * If there's a labor already in-progress on another work order it will ask if the user wishes to stop it.
         * 
         * @param {Schema} schema 
         * @param {Datamap} datamap 
         * @returns {Promise<Datamap>} started labor
         */
        function startLaborTransaction(schema, datamap) {
            if (!shouldAllowLaborStart()) throw new Error("IllegalStateError: there's already an active labor transaction for the current item");

            if (!hasActiveLabor()) {
                return doStartLaborTransaction();
            }

            const parentId = getActiveLaborParent();
            return dao.findById("DataEntry", parentId).then((parent) => {
                // This is the case when a labor is started and for some reason the parent of the labor is not on db anymore
                // (after a sync that forces it not shown anymore or was a created one and deleted)
                // TODO: Add a alert on all cases that causes this to let user choose between finishing the labor or discard it
                if (!parent) {
                    $log.get("laborService#saveLabor").warn("Parent labor not found! This is the case when a labor timer is started and for some reason the parent of the labor is not on db anymore.");
                    return clearTrackedLabor().then(() => {
                        return doStartLaborTransaction();
                    });
                }
                return startLaborTransactionWhenLaborAlreadyStarted(parent);
            });
        }

        /**
         * Finishes an in-progress labor reporting/transaction on the current parent entity.
         * 
         * @param {} schema 
         * @param {} datamap 
         * @returns {} 
         */
        function finishLaborTransaction(schema, datamap) {
            if (!shouldAllowLaborFinish()) throw new Error("IllegalStateError: there's no active labor transaction for the current item");

            return $ionicPopup.confirm({
                title: "Active Labor Report",
                template: "Are you sure you want to stop the labor timer?"
            })
                .then(res => res ? doStopLaborTransaction() : null);
        }

        function finishLaborBeforeSynch(parent) {
            if ((parent && !shouldAllowLaborFinish()) || (!parent && !hasActiveLabor())) {
                throw new Error("IllegalStateError: there's no active labor transaction");
            }

            const parentPromise = parent ? $q.when(parent) : dao.findById("DataEntry", getActiveLaborParent());
            return parentPromise.then((foundParent) => {
                return $ionicPopup.confirm({
                    title: "Labor Report",
                    template: "You must stop the labor timer before synchronization. Do you want to stop it and proceed with the synchronization?"
                }).then(res => res ? doStopLaborTransaction(foundParent, false) : false);
            });
        }

        function finishLaborTransactionFromComposition(schema, datamap) {
            finishLaborTransaction(schema, datamap).then(result => {
                if (result) {
                    $rootScope.$broadcast("sw_updatecommandbar", "mobile.composition");
                }
            });
        }

        /**
         * Executed when detail schema is loaded:
         * - formats 'regularhrs' as hh.mm
         * - if it's a creation schema will set laborer, payrate and linecost information.  
         * 
         * @param {$scope} scope 
         * @param {Schema} schema 
         * @param {Datamap} datamap 
         */
        function onDetailLoad(scope, schema, datamap) {
            const regularHours = datamap["regularhrs"];
            if (angular.isNumber(regularHours) && !Number.isInteger(regularHours)) {
                datamap["regularhrs"] = truncateDecimal(regularHours);
            }
            if (!datamap["labtransid"]) {
                setInitialLaborAndCraft(datamap);
            }
        }

        /**
         * Updates linecost when regularhrs changes.
         * 
         * @param {events.afterchange} event 
         */
        function updateLineCost(event) {
            const datamap = event.datamap;
            datamap["linecost"] = calculateLineCost(datamap["regularhrs"], datamap["payrate"]);
        }

        /**
         * Formats the 'rugularhrs' field as `HHh MMm {SSs}`. 
         * 
         * @param {formatter.params} params 
         * @returns {String} 
         */
        function formatRegularHours(params) {
            const value = params.value;
            if (!value) return value;
            const hours = Math.trunc(value);
            const minutes = Math.round((value * 60) % 60);
            if (hours === 0 && minutes === 0) {
                const seconds = Math.round((value * 3600) % 3600);
                return `${hours}h ${minutes}m ${seconds}s`;
            }
            return `${hours}h ${minutes}m`;
        }

        /**
         * Formats 'genapprservreceipt' boolean field to "Yes" and "No".
         * 
         * @param {formatter.params} params 
         * @returns {String} 
         */
        function formatApproved(params) {
            const value = params.value;
            if (!value) return value;
            const approved = _.contains([true, "true", "True", 1, "1", "yes", "Yes"], value);
            return approved ? "Yes" : "No";
        }

        /**
         * Clears the labor cache if the given item is the current labor parent
         * @param {} item 
         * @returns {} 
         */
        function clearLaborCacheIfCurrentParent(item) {
            if (item.id === getActiveLaborParent()) {
                clearTrackedLabor();
            }
        }

        function confirmPossibleTimer(item, defaultPreDeleteAction) {
            const activeLabor = getActiveLabor();
            return !!activeLabor && item["#localswdbid"] === activeLabor["#localswdbid"]
                ? $ionicPopup.confirm({
                    title: "Delete Labor",
                    template: "The labor you are trying to delete has a timer. Are you sure you wish to cancel the timer and delete it?"
                })
                : defaultPreDeleteAction();
        }


        function cancelPossibleTimer(item, parent, defaultPostDeleteAction) {
            const activeLabor = getActiveLabor();
            if (!!activeLabor && item["#localswdbid"] === activeLabor["#localswdbid"]) {
                clearTrackedLabor();
                return parent;
            }
            return defaultPostDeleteAction();
        }

        function hasItemActiveLabor(item) {
            if (!item) {
                return false;
            }

            const activeLabor = getActiveLabor();

            //is labor composition item
            if (!item.application && !!activeLabor) {
                return activeLabor["#localswdbid"] === item["#localswdbid"];
            }

            return getActiveLaborParent() === item.id;
        }

        //#endregion

        //#region Service Instance
        const service = {
            onDetailLoad,
            shouldAllowLaborStart,
            shouldAllowLaborFinish,
            showLaborCreationCommand,
            showLaborFinishCommand,
            startLaborTransaction,
            finishLaborTransaction,
            finishLaborBeforeSynch,
            finishLaborTransactionFromComposition,
            updateLineCost,
            formatRegularHours,
            formatApproved,
            getActiveLaborParent,
            getActiveLabor,
            confirmPossibleTimer,
            cancelPossibleTimer,
            hasActiveLabor,
            hasItemActiveLabor,
            clearLaborCacheIfCurrentParent
        };
        return service;
        //#endregion
    }

    //#region Service registration
    angular.module("sw_mobile_services")
        .factory("laborService",
        ["swdbDAO", "securityService", "localStorageService", "crudContextService", "$ionicPopup", "$q", "$log", "offlineSchemaService", "offlineSaveService", "$rootScope", "menuModelService","fsLaborOfflineService","metadataModelService", laborService]);
    //#endregion

})(angular, _);
;
(function (angular) {
    "use strict";

    function laborTimerIconProvider(laborService) {
        //#region Utils
        //#endregion

        //#region Public methods
        function getIconClass(item) {
            return laborService.hasItemActiveLabor(item) ? "hasaction" : null;
        }

        function getIconIcon(item) {
            return laborService.hasItemActiveLabor(item) ? "clock-o" : null;
        }
        //#endregion

        //#region Service Instance
        const service = {
            getIconClass,
            getIconIcon
        };
        return service;
        //#endregion
    }

    //#region Service registration
    angular.module("sw_mobile_services").factory("laborTimerIconProvider", ["laborService", laborTimerIconProvider]);
    //#endregion

})(angular);
;
(function (angular, _) {
    "use strict";

    function materialService(dao, crudContextHolderService) {
        //#region Utils

        const cleanItemData = (datamap) => {
            datamap["offlineitem_.description"] = null;
            datamap["#description"] = null;
            datamap["description"] = null;
        }

        const cleanMaterialData = (datamap, materialSelected) => {
            const nullNumberValue = materialSelected ? 0 : null;
            datamap["description"] = null;
            datamap["unitcost"] = nullNumberValue;
        }

        //#endregion

        //#region Public methods

        /**
         * @returns {String} whereclause that filters locations that are storerooms
         * textindex02 = offlinelocation.type
         * textindex03 = offlinelocation.status
         */
        const getStoreRoomWhereClause = function() {
            return "textindex02='STOREROOM' and textindex03='OPERATING'";
        };

        /**
         * @returns {String} whereclause that filters items that are stocked in the selected storeroom
         * textindex01 = offlineitem.itemnum
         * textindex01 = offlineinventory.itemnum
         * textindex02 = offlineinventory.location
         * textindex03 = offlineinventory.category
         */
        const getAvailableItemsWhereClause = () => {
            const dm = crudContextHolderService.getCompositionDetailItem();
            if(dm.category !== "ANY"){
                return "textindex01 in (select textindex01 from AssociationData where application='offlineinventory' and textindex02 = @storeloc and textindex03 = @category)"
            }
            return "textindex01 in (select textindex01 from AssociationData where application='offlineinventory' and textindex02 = @storeloc)"
        };
        
        /**
         * Clears datamap.
         * 
         * @param {events.afterchange} event 
         */
        function lineSelected(event) {
            const datamap = event.datamap;
            const linetype = datamap.linetype;
            cleanItemData(datamap);
            datamap["storeloc"] = "null$ignorewatch";
            datamap["itemnum"] = "null$ignorewatch";
            cleanMaterialData(datamap, linetype === "MATERIAL");
            datamap["qtyrequested"] = 1;
        }

        /**
         * Sets description from selected item.
         * 
         * @param {events.afterchange} event 
         */
        function itemSelected(event) {
            const datamap = event.datamap;
            const value = event.newValue;
            if (!value) {
                cleanItemData(datamap);
                return;
            }
            const description = datamap["offlineitem_.description"];
            datamap["#description"] = description;
            datamap["description"] = description;
        }

        /**
         * Clear item data.
         * 
         * @param {events.afterchange} event
         */
        function categorySelected(event) {
            const datamap = event.datamap;
            if (!datamap["itemnum"]) return;
            datamap["itemnum"] = "null$ignorewatch";
            cleanItemData(datamap);
        }

        /**
         * Clear item data.
         * 
         * @param {events.afterchange} event
         */
        function storeRoomSelected(event){
            const datamap = event.datamap;
            if (!datamap["itemnum"]) return;
            datamap["itemnum"] = "null$ignorewatch";
            cleanItemData(datamap);
        }

        //#endregion

        //#region Service Instance
        const service = {
            lineSelected,
            itemSelected,
            categorySelected,
            storeRoomSelected,
            getStoreRoomWhereClause,
            getAvailableItemsWhereClause
        };
        return service;
        //#endregion
    }

    //#region Service registration

    angular.module("sw_mobile_services").factory("materialService", ["swdbDAO", "crudContextHolderService", materialService]);

    //#endregion

})(angular, _);;
(function (angular, mobileServices) {
    "use strict";

    function offlineAttachmentService($log, $q, cameraService, $cordovaFile, fileConstants, crudContextHolderService, swdbDAO, offlineSchemaService, entities, loadingService, swAlertPopup) {
        //#region Utils
        const config = {
            newAttachmentFieldName: "newattachment",
            newAttachmentPathFieldName: "newattachment_path",
            fileNameFieldName: "document",
            defaultBaseFileName: "camera.jpg"
            //newAttachmentCompressedFlagFieldName: "#is_compressed"
        };

        function newFileName(application, fileName) {
            return `attachment_${application}_${Date.now()}_${fileName || config.defaultBaseFileName}`;
        }

        function createAttachmentEntity(attachment) {
            return swdbDAO.instantiate("Attachment", attachment).then(a => swdbDAO.save(a));
        }


        function base64ToBlob(b64Data, contentType, sliceSize) {
            contentType = contentType || "";
            sliceSize = sliceSize || 512;
            const byteCharacters = atob(b64Data);
            const byteArrays = [];
            for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
                const slice = byteCharacters.slice(offset, offset + sliceSize);
                const byteNumbers = new Array(slice.length);
                for (let i = 0; i < slice.length; i++) {
                    byteNumbers[i] = slice.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                byteArrays.push(byteArray);
            }
            const blob = new Blob(byteArrays, { type: contentType });
            return blob;
        }

        function createFile(fileName, base64Data, mimeType) {

            var deferred = $q.defer();
            const log = $log.get("attachmentService#createFile", ["attachment"]);

            window.requestFileSystem(window.TEMPORARY, 5 * 1024 * 1024, function (fs) {
                log.debug('file system open directory: ' + fs.name);

                fs.root.getFile(fileName, { create: true, exclusive: false }, function (fileEntry) {

                    fileEntry.createWriter(function (fileWriter) {
                        fileWriter.onwriteend = function () {
                            log.info("Successful file read...");
                            deferred.resolve(fileEntry);
                        };
                        fileWriter.onerror = function (e) {
                            deferred.reject();
                        };
                        fileWriter.write(base64ToBlob(base64Data, mimeType));
                    });

                }, ()=>deferred.reject());

            });

            return deferred.promise;

            // Creates a new file or returns the file if it already exists.

        }

        function createAndLoadTempFile(fileName, attachment, docinfoId) {
            const deferred = $q.defer();

            const mimeType = attachment.mimetype;
            const cachedPath = attachment.path;

            const creationPromise = cachedPath ? $q.when({
                toInternalURL: function () {
                    return attachment.path;
                }
            }) : createFile(fileName, attachment.content, mimeType);
            const log = $log.get("attachmentService#createAndLoadTempFile", ["attachment"]);

            creationPromise.then(fileEntry => {
                var path = fileEntry.toURL();
                
                // if(ionic.Platform.isIOS()) {
                // TODO: might not be the optmimal way to open office docs. Use: https://github.com/pwlin/cordova-plugin-fileopenener2/issues/60
                const ref = window.open(path, "_blank", "location=yes,hidden=no,closebuttoncaption=Close");
                ref.addEventListener("loadstop", evt => deferred.resolve());
                ref.addEventListener("loaderror", evt => deferred.reject(evt));
                    
                /*} else {
                    cordova.plugins.fileOpener2.open(path, mimeType, {
                        error: () => {
                            deferred.reject();
                            log.warn("couldnÂ´t open file {0} at location {1}".format(docinfoId,path));
                        },
                        success: () => {
                            if (cachedPath) {
                                log.info("opening cached file at location {0}".format(path));
                                deferred.resolve();
                                return;
                            }

                            var queryObj = {
                                query: entities.Attachment.UpdateAttachmentPath,
                                args: [path, docinfoId]
                            }
                            swdbDAO.executeQuery(queryObj).then(() => {
                                //updating attachment path so that next time we can (try) load the same file.
                                log.debug("updating cached location {0} for file {1}".format(path, docinfoId));
                                deferred.resolve();
                            });
                        },
                    });
                }*/
            }).catch(
                error=> deferred.reject(error)
            );

            return deferred.promise;

        }


        //#endregion

        //#region Public methods

        /**
         * Finds the attachments of a root entity.
         * 
         * @param {String} application 
         * @param {String} parentId 
         * @returns {Promise<persistence.entity.Attachment>} 
         */
        function getAttachment(application, parentId) {
            Validate.notEmpty(application, "application");
            Validate.notEmpty(parentId, "parentId");
            return swdbDAO.findByQuery("Attachment", `application='${application}' and parentId='${parentId}'`);
        }

        /**
         * Takes picture, moves cached image file to app's external storage and sets the file path in the datamap.
         * 
         * @param {Schema} schema current schema on display
         * @param {Datamap} datamap current datamap on display
         * @returns {Promise<String>} resolved with the file path
         */
        function attachCameraPictureAsFile(schema, datamap) {
            return cameraService.captureFile()
                .then(file => {
                    const application = crudContextHolderService.currentApplicationName();
                    return $cordovaFile.copyFile(file.dirPath, file.fileName, cordova.file[fileConstants.appDirectory], newFileName(application, file.fileName));
                })
                .then(fileEntry => datamap[config.newAttachmentFieldName] = fileEntry.nativeURL);
        }

        function handleBase64Prefix(content, mimeType) {
            const replacementString = `data:${mimeType};base64,`;
            const indexOf = content.indexOf(replacementString);
            if (indexOf !== -1) {
                //data stored locally need to be 
                return content.substring(replacementString.length);
            }
            return content;
        }

        /**
         * Takes a picture and sets the base64 encoded content in the datamap.
         * 
         * @param {Schema} schema 
         * @param {Datamap} datamap 
         * @returns {Promise<string>} base64 encoded picture's content 
         */
        function attachCameraPicture(schema, datamap) {
            return cameraService.captureData().then(content => {
                const application = crudContextHolderService.currentApplicationName();
                const field = offlineSchemaService.getFieldByAttribute(schema, config.newAttachmentFieldName);

                field.rendererParameters["showImagePreview"] = true;
                datamap[config.fileNameFieldName] = datamap[config.newAttachmentPathFieldName] = newFileName(application);
                datamap[config.newAttachmentFieldName] = content.data.value;
                datamap["#mimetype"] = "image/jpeg";
            });
        }

        /**
         * Creates an Attachment entity from the base64 encoded content present in the datamap.
         * 
         * @param {Schema} schema 
         * @param {Datamap} datamap 
         * @returns {Promise<persistence.Entity.Attachment>} resolved with the saved attachment
         */
        function saveAttachment(schema, datamap) {
            const attachment = {
                application: crudContextHolderService.currentApplicationName(),
                parentId: crudContextHolderService.currentDetailItem().id,
                content: datamap[config.newAttachmentFieldName],
                mimetype: datamap["#mimetype"],
                compressed: false,
                compositionRemoteId: null
            };
            attachment.content = handleBase64Prefix(attachment.content, attachment.mimetype);
            return createAttachmentEntity(attachment);
        }

        /**
         * Creates an Attachment entity from the file path present in the datamap.
         * 
         * @param {Schema} schema 
         * @param {Datamap} datamap 
         * @returns {Promise<persistence.Entity.Attachment>} resolved with the saved Attachment
         */
        function saveAttachmentAsFile(schema, datamap) {
            const attachment = {
                application: crudContextHolderService.currentApplicationName(),
                parentId: crudContextHolderService.currentDetailItem().id,
                path: datamap[config.newAttachmentFieldName]
            };
            return createAttachmentEntity(attachment);
        }

        /**
         * Deletes the file from the attachment file path present in the datamap.
         * 
         * @param {Schema} schema 
         * @param {Datamap} datamap 
         * @returns {Promise<Void>} 
         */
        function deleteAttachmentFile(schema, datamap) {
            const log = $log.get("attachmentService#cancelAttachment", ["attachment"]);
            const attachmentPath = datamap[config.newAttachmentFieldName];
            log.debug(`deleting ${attachmentPath}`);
            const file = new fileConstants.FilePathWrapper(attachmentPath);
            return $cordovaFile.removeFile(file.dirPath, file.fileName)
                .then(() => log.debug(`Successfully deleted ${attachmentPath}`))
                .catch(e => log.warn(`Could not delete ${attachmentPath}`, e));
        }

        function loadRealAttachment(doclinkEntry) {

            const fileName = doclinkEntry.document;
            const docinfoId = doclinkEntry.docinfoid;
            const localHash = doclinkEntry["#offlinehash"];

            const log = $log.get("attachmentService#loadRealAttachment", ["attachment"]);
            const queryObj = {
                query: !!docinfoId ? entities.Attachment.ByDocInfoId : entities.Attachment.ByHashId,
                args: !!docinfoId ? [String(docinfoId)] : [String(localHash)]
            };
            const deferred = $q.defer();
            loadingService.showDefault();
            swdbDAO.executeQuery(queryObj).then(result => {
                if (result.length === 0 || result[0].content==null) {
                    deferred.reject();
                    const error = `Could not open attachment ${docinfoId}, not found on database...`;
                    log.warn(error);
                    swAlertPopup.show({
                        title: error //TODO: maybe create a message for the popup?
                    });
                    loadingService.hide();
                    return;
                }
                var attachment = result[0];

                var mimeType = attachment.mimetype;
                var extension = mimeType.substring(mimeType.indexOf("/") + 1);

                if (isRippleEmulator()) {
                    swAlertPopup.show({
                        title: "File Cannot be openend on Ripple" //TODO: maybe create a message for the popup?
                    });
                    deferred.resolve();
                    loadingService.hide();
                    return;
                }

                if (ionic.Platform.isAndroid()) {
                    const content = handleBase64Prefix(attachment.content, attachment.mimetype);
                    cordova.plugins.fileOpener2.openBase64(fileName, extension, content, mimeType, {
                        error: function (e) {
                            loadingService.hide();
                            deferred.reject();
                        },
                        success: function () {
                            loadingService.hide();
                            deferred.resolve();
                        }
                    });
                } else if (ionic.Platform.isIOS()) {
                    // For IOS we need to create a temp file and load it afterwards, since thereÂ´s no plugin support for loading it straight from base64 string
                    //trying to open already cached temp file
                    createAndLoadTempFile(fileName, attachment, docinfoId)
                        .then(() => deferred.resolve())
                        .catch(() => {
                            if (!attachment.path) {
                                //file failed to create/load and
                                log.warn("could not open file load file {0}".format(docinfoId));
                                deferred.reject();
                                return;
                            }
                            //attachment path is no longer valid... cleaning and trying again
                            log.warn("could not open file at path {0}, creating temporary one... ".format(path));
                            attachment.path = null;
                            createAndLoadTempFile(fileName, attachment, docinfoId)
                                .then(() => deferred.resolve())
                                .catch(() => deferred.reject())
                                .finally(() => loadingService.hide());
                        }).finally(() => loadingService.hide());
                }

            });

            return deferred.promise;

        }

        /**
         * Deletes the entities.Attachment related to the composition datamap.
         * 
         * @param {Datamap} composition 
         * @returns {Promise<Array<Void>>} 
         */
        function deleteRelatedAttachment(composition) {
            const attachmentHash = composition["#offlinehash"];
            return swdbDAO.executeStatement(entities.Attachment.DeleteById, [attachmentHash]);
        }

        /**
         * Deletes the entities.Attachments related to the compositions datamaps.
         * 
         * @param {Datamap} compositions 
         * @returns {Promise<Array<Void>>} 
         */
        function deleteRelatedAttachments(compositions) {
            const hashes = compositions.map(c => c["#offlinehash"]).filter(h => !!h).map(h => `'${h}'`);
            if (hashes.length <= 0) return $q.when();

            const query = entities.Attachment.DeleteMultipleByIdsPattern.format(hashes);
            return swdbDAO.executeQuery(query);
        }

        //#endregion

        //#region Service Instance
        const service = {
            // general
            getAttachment,
            loadRealAttachment,
            deleteRelatedAttachment,
            deleteRelatedAttachments,
            // file
            attachCameraPictureAsFile,
            saveAttachmentAsFile,
            deleteAttachmentFile,
            // content
            attachCameraPicture,
            saveAttachment
        };
        return service;
        //#endregion
    }

    //#region Service registration
    mobileServices.factory("offlineAttachmentService",
        ["$log", "$q", "cameraService", "$cordovaFile", "fileConstants", "crudContextHolderService", "swdbDAO", "offlineSchemaService", "offlineEntities", "loadingService", "swAlertPopup", offlineAttachmentService]);
    //#endregion

})(angular, mobileServices);;
(function (mobileServices) {
    "use strict";

    class offlineCompositionService {

        constructor($log, swdbDAO, offlineEntities, attachmentDataSynchronizationService, searchIndexService) {
            this.$log = $log;
            this.swdbDAO = swdbDAO;
            this.offlineEntities = offlineEntities;
            this.attachmentDataSynchronizationService = attachmentDataSynchronizationService;
            this.searchIndexService = searchIndexService;
        }

        /**
          * Generates the queries to update the composition entries after a synchronization has been performed.
          * @param {any} compositionDataReturned The composition data returned from the server, a dictionary of multiple applications (worklogs,attachments, etc)
          * @return type="string" a array of queries to be executed later
          */
        generateSyncQueryArrays(compositionDataReturned) {
            const log = this.$log.get("compositionService#generateSyncQueryArrays", ["composition"]);
            let queryArray = [];

            if (compositionDataReturned == null) {
                log.debug("no compositions returned from the server");
                return queryArray;
            }

            const doclinksMap = new Map();

            for (let i = 0; i < compositionDataReturned.length; i++) {
                const application = compositionDataReturned[i];
                const newDataMaps = application.newdataMaps;

                log.debug("inserting {0} new compositions for {1}".format(newDataMaps.length, application.applicationName));
                const idsToDelete = [];
                for (let j = 0; j < newDataMaps.length; j++) {
                    const datamap = newDataMaps[j];
                    const id = persistence.createUUID();
                    const json = datamap.jsonFields || JSON.stringify(datamap);
                    const parsedDM = datamap.jsonFields ? JSON.parse(datamap.jsonFields) : datamap; //keeping backwards compatibility //newJson = datamapSanitizationService.sanitize(newJson);

                    const idx = datamap.indexData || this.searchIndexService.buildIndexes(application.textIndexes, application.numericIndexes, application.dateIndexes, JSON.parse(datamap.jsonFields));
                    const query = { query: this.offlineEntities.CompositionDataEntry.insertionQueryPattern, args: [datamap.application, json, datamap.id, String(datamap.approwstamp), id, idx.t1, idx.t2, idx.t3, idx.t4, idx.t5, idx.n1, idx.n2, idx.d1, idx.d2, idx.d3] };


                    idsToDelete.push("'" + datamap.id + "'");
                    queryArray.push(query);
                    if (application.applicationName === "attachment_") {
                        var queryObj = { compositionRemoteId: parsedDM.doclinksid, hash: parsedDM["docinfo_.urlparam2"], ownerTable: parsedDM.ownertable, ownerId: parsedDM.ownerid, docinfoid: parsedDM.docinfoid };
                        doclinksMap.set(queryObj.compositionRemoteId, queryObj);
                    }
                }
                if (idsToDelete.length !== 0) {
                    //letÂ´s delete the old compositions first, to avoid any chance of errors due to server side updates
                    //however persistence.js reverts the array on ripple... damn it
                    if (isRippleEmulator()) {
                        queryArray.push(this.offlineEntities.CompositionDataEntry.syncdeletionQuery.format(application.applicationName, idsToDelete));
                    } else {
                        queryArray.unshift(this.offlineEntities.CompositionDataEntry.syncdeletionQuery.format(application.applicationName, idsToDelete));
                    }
                }

            }

            return this.attachmentDataSynchronizationService.generateAttachmentsQueryArray(Array.from(doclinksMap.values()))
                .then((attachmentQueryArray) => {
                    queryArray = queryArray.concat(attachmentQueryArray);
                    log.debug(`final composition array count ${queryArray.length}`);
                    return queryArray;
                });

        }

        allowsUpdate(item, compositionListSchema) {
            //only items not yet synced with the server
            //TODO: someday allow synced compositions as well
            return item[compositionListSchema.idFieldName] == null;
        }

        /**
           * Load composition list
           * 
           * @param {} mainItem 
           * @param {} displayable 
           * @returns {} 
           */
        loadCompositionList(mainItem, displayable) {
            var mainDatamap = mainItem.datamap;
            if (!displayable) {
                throw new Error("field displayable is required");
            }
            //TODO: cache...
            const log = this.$log.get("offlineCompositionService#loadComposition", ["composition"]);
            const localId = mainItem.id;
            var baseQuery = "application = '{0}' and ( (".format(displayable.associationKey);
            const entityDeclarationAttributes = displayable.entityAssociation.attributes;
            for (var i = 0; i < entityDeclarationAttributes.length; i++) {
                const attribute = entityDeclarationAttributes[i];
                let fromValue;
                if (attribute.literal) {
                    //siteid = 'SOMETHING'
                    fromValue = attribute.literal;
                } else {
                    //siteid = siteid
                    fromValue = mainDatamap[attribute.from];
                }
                baseQuery += '( datamap like \'%"{0}":"{1}"%\' '.format(attribute.to, fromValue);
                baseQuery += ' or datamap like \'%"{0}":{1}%\' )'.format(attribute.to, fromValue);
                if (i != entityDeclarationAttributes.length - 1) {
                    baseQuery += " and ";
                }
            }
            baseQuery += "))";
            //baseQuery += " or ( parentlocalId = '{0}') )".format(localId);

            if (displayable.schema &&
                displayable.schema.collectionProperties &&
                displayable.schema.collectionProperties.orderByField &&
                displayable.schema.schemas &&
                displayable.schema.schemas.list) {

                const listSchema = displayable.schema.schemas.list;
                const appName = listSchema.applicationName;
                const column = displayable.schema.collectionProperties.orderByField;
                const orderIndex = this.searchIndexService.getIndexColumn(appName, listSchema, column);
                baseQuery += ` order by ${orderIndex}`;
            }

            log.debug("fetching composition {0} using query {1}".format(displayable.associationKey, baseQuery));
            return this.swdbDAO.findByQuery("CompositionDataEntry", baseQuery, { projectionFields: ["remoteId", "datamap"] }).then(function (results) {
                var resultCompositions = [];
                for (let i = 0; i < results.length; i++) {
                    resultCompositions.push(results[i].datamap);
                }
                // put any locally created compositions on top of the list
                if (mainDatamap[displayable.associationKey]) {
                    resultCompositions = mainDatamap[displayable.associationKey].concat(resultCompositions);
                }
                return resultCompositions;
            });

        }


    }


    offlineCompositionService["$inject"] = ["$log", "swdbDAO", "offlineEntities", "attachmentDataSynchronizationService", "searchIndexService"];

    mobileServices.service("offlineCompositionService", offlineCompositionService);

})(mobileServices);;
(function (mobileServices, _) {
    "use strict";

    mobileServices.factory('offlineSaveService', ["$log", "$rootScope", "swdbDAO","offlineSchemaService" ,"$ionicPopup", "offlineEntities", "offlineAttachmentService", "crudContextHolderService", "searchIndexService","metadataModelService", function ($log, $rootScope, swdbDAO,offlineSchemaService, $ionicPopup, offlineEntities, offlineAttachmentService, crudContextHolderService, searchIndexService,metadataModelService) {



        var entities = offlineEntities;

        const doSave = function (applicationName, item, title, showConfirmationMessage, saveCustomMessage) {
            const idxArrays = crudContextHolderService.getIndexes();
            const idx = searchIndexService.buildIndexes(idxArrays.textIndexes, idxArrays.numericIndexes, idxArrays.dateIndexes, item.datamap);

            const jsonString = JSON.stringify(item.datamap);
            const localId = item.id;

            if (localId == null && applicationName.contains("workorder") && applicationName !== "workorder") {
                //workaround to enforce that all created entries go to the created menu
                applicationName = "workorder";
            }

            const generatedId = localId ? null : persistence.createUUID();

            const isAlreadyDirty = _.contains([true, 1, "true"], item.isDirty);
            const cameFromServer = !!item.remoteId;
            const shouldIncludeOriginalDatamap = !isAlreadyDirty && cameFromServer; // not created locally and first time saving
            const originalDatamap = crudContextHolderService.getCrudContext().originalDetailItemDatamap;

            item.isDirty = true;
            item.datamap["#offlinesavedate"] = new Date();

            const queryToExecute = !localId
                // inserting new item
                ? { query: entities.DataEntry.insertLocalPattern, args: [applicationName, jsonString, generatedId, idx.t1, idx.t2, idx.t3, idx.t4, idx.t5, idx.n1, idx.n2, idx.d1, idx.d2, idx.d3] }
                // updating existing item
                : shouldIncludeOriginalDatamap 
                    // setting originaldatamap
                    ? { query: entities.DataEntry.updateLocalSetOriginalPattern, args: [jsonString, JSON.stringify(item.originaldatamap = originalDatamap), idx.t1, idx.t2, idx.t3, idx.t4, idx.t5, idx.n1, idx.n2, idx.d1, idx.d2, idx.d3, localId] }
                    // regular update
                    : { query: entities.DataEntry.updateLocalPattern, args: [jsonString, idx.t1, idx.t2, idx.t3, idx.t4, idx.t5, idx.n1, idx.n2, idx.d1, idx.d2, idx.d3, localId] };

            const log = $log.get("offlineSaveService#doSave", ["crud", "detail", "save"]);
            log.debug(`saving item ${localId} for application ${applicationName}, storing original: ${shouldIncludeOriginalDatamap}`);

            return swdbDAO.executeQuery(queryToExecute)
                .then(() => {
                    //enforcing the real application that got saved
                    item.application = applicationName;
                    if (!localId) {
                        item.newId = generatedId;
                    } else {
                        crudContextHolderService.updateOriginalItemDatamap(item.datamap);    
                    }
                    $rootScope.$broadcast(JavascriptEventConstants.CrudSaved);
                    return showConfirmationMessage === undefined || showConfirmationMessage === null || showConfirmationMessage === true
                        ? $ionicPopup.alert({ title: saveCustomMessage ? saveCustomMessage : `${title} Saved Successfully` }).then(() => item)
                        : item;
                });
        };

        return {

            saveItem: function (applicationName, item, title, showConfirmationMessage) {
                return doSave(applicationName, item, title, showConfirmationMessage);
            },

            addAndSaveComposition: function (applicationName, item, compositionItem, compositionMetadata, saveCustomMessage, showConfirmationMessage) {
                const datamap = item.datamap;
                const associationKey = compositionMetadata.associationKey;
                const compositionAppMetadata = metadataModelService.getCompositionByName(compositionMetadata.attribute);
                const title = (compositionAppMetadata && compositionAppMetadata.data && compositionAppMetadata.data.title) || compositionMetadata.label;
                datamap[associationKey] = datamap[associationKey] || [];

                const log = $log.get("offlineSaveService#addAndSaveComposition", ["crud", "detail", "save"]);
                log.debug(`adding and saving a new composition ${compositionMetadata.associationKey} for application ${applicationName}`);

                const isLocalCreate = !compositionItem[constants.localIdKey];
                if (isLocalCreate) {
                    const id = persistence.createUUID();
                    compositionItem[constants.localIdKey] = id;
                    const field = offlineSchemaService.locateDisplayableByQualifier(compositionMetadata.schema.schemas.list,"externalid");
                    if (!!field){
                        compositionItem[field.attribute] = id;
                    }
                }

                if (compositionMetadata.associationKey === "attachment_") {
                    return offlineAttachmentService.saveAttachment(null, compositionItem).then( attachmentObj => {
                        compositionItem["#offlinehash"] = attachmentObj.id;
                        //this will be stored on the Attachement entity instead
                        delete compositionItem["newattachment"];
                        datamap[associationKey].push(compositionItem);
                        return doSave(applicationName, item, title, showConfirmationMessage, saveCustomMessage);
                    });
                }

                if (isLocalCreate) {
                    datamap[associationKey].push(compositionItem);
                } else {
                    // TODO: when we allow update of remote compositions, change this to delete the corresponding CompositionDataEntry and then pushing to the array
                    const itemPosition = datamap[associationKey].findIndex(e => e[constants.localIdKey] === compositionItem[constants.localIdKey]);
                    datamap[associationKey][itemPosition] = compositionItem;
                }
                return doSave(applicationName, item, title, showConfirmationMessage, saveCustomMessage);
            },
        }

    }]);

})(mobileServices, _);
;
(function (mobileServices, $) {
    "use strict";

    function offlineRestService($log, $http, settingsService) {
        //#region Utils
        function getActionUrl(controller, action, parameters) {
            action =  action || "get";
            var params = parameters || {};
            return settingsService.getServerUrl().then(function(url) {
                return `${url}/api/generic/${controller}/${action}?${$.param(params)}`;
            });
        }
        //#endregion

        //#region Public methods
        function post(controller, action, params, json) {
            return getActionUrl(controller, action, params).then(function(url) {
                $log.get("offlineRestService#post").info("invoking post on url", url);
                return $http.post(url, json);
            });
        }
        function get(controller, action, params, configHeaders = {}) {

            return getActionUrl(controller, action, params).then(function (url) {
                $log.get("offlineRestService#get").info("invoking get on url", url);
                return $http.get(url, configHeaders);
            });
        }
        //#endregion

        //#region Service Instance
        const service = {
            get,
            post
        };
        return service;
        //#endregion
    }

    //#region Service registration
    mobileServices.factory("offlineRestService", ["$log", "$http", "settingsService", offlineRestService]);
    //#endregion


})(mobileServices, jQuery);
;
(function (mobileServices) {
    "use strict";

    mobileServices.factory("operationService", ["schemaService", "crudConstants", operationService]);

    function operationService(schemaService, crudConstants) {

        var service = {
            getCrudOperation: getCrudOperation
        };

        return service;

        function getCrudOperation(dataEntry, detailSchema) {
            var isNew = schemaService.getId(dataEntry.datamap, detailSchema) == null;
            return isNew ? crudConstants.operation.create : crudConstants.operation.update;
        }

    }
})(mobileServices);
;
(function (angular, mobileServices) {
    "use strict";

    function cameraService($cordovaCamera, fileConstants) {
        //#region Utils
        const config = {
            options: {
                quality: 50,
                destinationType: Camera.DestinationType.FILE_URI,
                sourceType: Camera.PictureSourceType.CAMERA,
                mediaType: Camera.MediaType.PICTURE,
                encodingType: Camera.EncodingType.JPEG,
                cameraDirection: Camera.Direction.BACK,
                targetWidth: window.innerWidth,
                targetHeight: window.innerHeight,
                allowEdit: false,
                saveToPhotoAlbum: false,
                correctOrientation: true,
                // popoverOptions: new CameraPopoverOptions(300, 300, 100, 100, Camera.PopoverArrowDirection.ARROW_ANY), --> iOS only
            }
        };

        function mergedOptions(options) {
            if (!options) return config.options;
            const merged = angular.copy(config.options);
            angular.forEach(options, (value, key) => merged[key] = value);
            return merged;
        }
        //#endregion

        //#region Public methods
        
        /**
         * Captures data from camera.
         * 
         * @param {cordova.Camera.options} options 
         * @returns {Promise<String>} image's path (cache) | image's base64 encoded content
         */
        function capture(options) {
            const optionsToUse = mergedOptions(options);
            return $cordovaCamera.getPicture(optionsToUse);
        }

        /**
         * Captures camera data as base64 encoded content.
         * 
         * @param {cordova.Camera.options} options 
         * @returns {Promise<fileConstants.FileContentWrapper>} 
         */
        function captureData(options) {
            const optionsToUse = options || {};
            optionsToUse.destinationType = Camera.DestinationType.DATA_URL;
            return capture(optionsToUse).then(data => new fileConstants.FileContentWrapper(`data:image/jpeg;base64,${data}`));
        }

        /**
         * Captures data from camera as file url.
         * 
         * @param {cordova.Camera.options} options 
         * @returns {Promise<fileConstants.FilePathWrapper>} 
         */
        function captureFile(options) {
            const optionsToUse = options || {};
            optionsToUse.destinationType = Camera.DestinationType.FILE_URI;
            return capture(optionsToUse).then(url => new fileConstants.FilePathWrapper(url));
        }

        //#endregion

        //#region Service Instance
        const service = {
            capture,
            captureData,
            captureFile
        };
        return service;
        //#endregion
    }

    //#region Service registration
    mobileServices.factory("cameraService", ["$cordovaCamera", "fileConstants", cameraService]);
    //#endregion

})(angular, mobileServices);;
(function (mobileServices) {
    "use strict";

    /**
     * Wrapper around $cordovaNetwork so it doesn't call cordova 
     * related stuff in simulated environment.
     */
    function networkConnectionService($cordovaNetwork) {
        //#region Utils
        var simulator = isRippleEmulator();
        //#endregion

        //#region Public methods
        function isOnline() {
            if (simulator) {
                return navigator.onLine;
            }
            return $cordovaNetwork.isOnline();
        }

        function isOffline() {
            if (simulator) {
                if (sessionStorage.mockoffline === "true") {
                    return true;
                }

                return !navigator.onLine;
            }
            return $cordovaNetwork.isOffline();
        }
        //#endregion

        //#region Service instance
        const service = {
            isOnline,
            isOffline
        };
        return service;
        //#endregion
    }

    //#region Service registration
    mobileServices.factory("networkConnectionService", ["$cordovaNetwork", networkConnectionService]);
    //#endregion

})(mobileServices);;
(function (angular) {
    "use strict";

    function cookieService($log, $q, dao, settingsService, entities) {
        //#region Utils

        //#region cordova-cookie-master plugin adapter promisefying methods
        class CordovaCookieMasterAdapter {
            constructor(cookieMaster, q) {
                this.cookieMaster = cookieMaster;
                this.$q = q;
            }
            getCookieValue(url, name) {
                const deferred = this.$q.defer();
                this.cookieMaster.getCookieValue(url, name, cookie => deferred.resolve(cookie.cookieValue), error => deferred.reject(error));
                return deferred.promise;
            }
            setCookieValue(url, name, value) {
                const deferred = this.$q.defer();
                this.cookieMaster.setCookieValue(url, name, value, () => deferred.resolve(value), error => deferred.reject(error));
                return deferred.promise;
            }
            clearCookies() {
                const deferred = this.$q.defer();
                this.cookieMaster.clear(() => deferred.resolve(), error => deferred.reject(error));
                return deferred.promise;
            }
        }
        //#endregion

        const $cookie = new CordovaCookieMasterAdapter(window.cookieMaster, $q);

        /**
         * Fetches the value of a cookie that is persisted locally.
         * 
         * @param {String} name 
         * @returns {String} 
         */
        function getCookie(name) {
            return dao.findSingleByQuery("Cookie", `name='${name}'`).then(c => !c ? null : c.value);
        }

        /**
         * Fetches the value of a cookie available in the webview by name.
         * 
         * @param {String} name 
         * @returns Promise<String> 
         */
        function getWebCookie(name) {
            return settingsService.getServerUrl().then(url => $cookie.getCookieValue(url, name));
        }

        /**
         * Sets the value of a cookie in the webview.
         * 
         * @param {String} name 
         * @param {String} value 
         * @returns Promise<String> resolved with the value 
         */
        function setWebCookie(name, value) {
            return settingsService.getServerUrl().then(url => $cookie.setCookieValue(url, name, value));
        }

        function rippleProxy(method) {
            return function() {
                return isRippleEmulator() ? $q.when() : method.apply(null, arguments);
            }
        }

        //#endregion

        //#region Public methods

        /**
         * Clears all cookies from the webview and persisted locally.
         * 
         * @returns {Promise<Void>} 
         */
        function clearCookies() {
            return $cookie.clearCookies().then(() => dao.executeStatement(entities.Cookie.deleteAllStatement));
        }

        /**
         * Fetches cookie from webview and persists it locally.
         * 
         * @param {string} name 
         * @returns {Promise<String>} resolved with the cookie value 
         */
        function persistCookie(name) {
            return $q.all([
                dao.countByQuery("Cookie", `name = '${name}'`),
                getWebCookie(name)
            ]).spread((count, value) => {
                const promise = count <= 0
                    ? dao.executeStatement(entities.Cookie.insertStatement, [persistence.createUUID(), name, value])
                    : dao.executeStatement(entities.Cookie.updateByNameStatement, [value, name]);
                return promise.then(() => {
                    $log.get("cookieService#persistCookie", ["cookie"]).debug(`persisted cookie {name:${name}, value: ${value}}`);
                    return value;
                });
            });
        }

        /**
         * Fetches the value of a cookie persisted locally and sets it back into the webview.
         * 
         * @param {String} name 
         * @returns {Promise<String>} cookie value 
         */
        function restoreCookie(name) {
            const logger = $log.get("cookieService#restoreCookie", ["cookie"]);

            const promise = getCookie(name).then(value => !value ? null : setWebCookie(name, value));

            return logger.isLevelEnabled("debug")
                ? promise.then(value => {
                    logger.debug(`restore cookie {name:${name}, value: ${value}}`);
                    return value;
                })
                : promise;
        }

        //#endregion

        //#region Service Instance
        const service = {
            clearCookies: rippleProxy(clearCookies),
            persistCookie: rippleProxy(persistCookie),
            restoreCookie: rippleProxy(restoreCookie)
        };
        return service;
        //#endregion
    }

    //#region Service registration

    angular.module("sw_mobile_services").factory("cookieService", ["$log", "$q", "swdbDAO", "settingsService", "offlineEntities", cookieService]);

    //#endregion

})(angular);;
(function (mobileServices, ionic, _) {
    "use strict";

    function securityService($rootScope, $state, localStorageService, routeService, $http, $q, dao, $ionicHistory, cookieService, $injector, indexCreatorService) {

        //#region Utils

        const config = {
            eventnamespace:"sw4:security:",
            authkey: "security:auth:user",
            previouskey: "security:auth:previous",
            authCookieName: "swcookie",
            message: {
                sessionexpired: "Your session has expired. Please log in to resume your activities. ",
                unauthorizedaccess: "You're not authorized to access this resource. " +
                                    "Contact support if you're receiving this message in error."
            },
            keyblacklist: [ "security:", "settings:" ]
        };

        const $event = name => config.eventnamespace + name;

        const isLoginState = () => $state.current.name === "login";

        const setUserProperties = (user, properties) => {
            if (!properties || _.isEmpty(properties)) {
                delete user["properties"];
            } else {
                user["properties"] = properties;
                if (!!properties["siteid"]) user["SiteId"] = properties["siteid"];
                if (!!properties["orgid"]) user["OrgId"] = properties["orgid"];
            }
            delete user["Properties"];
        };

        const trackLogin = () => {
            const tracking = $injector.get("trackingService");
            tracking.trackStates("securityService#login", ["settings", "configs", "user", "device"], "User successfully logged in");
        };

        /**
         * Authenticates the user locally initializing it's client-side session, persisting the authentication cookie
         * and $broadcasts the event "security:login" in $rootScope with two parameters
         * the current just logged in user and the last logged user.
         * Users have the following format:
         * {
         * "UserName": String,
         * "OrgId": String,
         * "SiteId": String
         * }
         * 
         * @param {Object} user
         * @return {Object} user
         */
        const loginLocal = user => 
            cookieService.persistCookie(config.authCookieName).then(() => {
                var previous = localStorageService.get(config.authkey);
                previous = !!previous ? previous : localStorageService.get(config.previouskey);
                setUserProperties(user, user["Properties"]);
                localStorageService.put(config.authkey, user);
                $rootScope.$broadcast($event("login"), user, previous);
                trackLogin();
                return user;
            });

        const cleanLocalStorage = () => {
            Object.keys(localStorage)
                .filter(k => !config.keyblacklist.some(b => k.startsWith(b)))
                .forEach(k => localStorage.removeItem(k));
        };

        const setHasChanged = (user, changed) => {
            if (!user.meta) user.meta = {};
            user.meta.changed = changed;
        };

        //#endregion

        //#region Public methods

        /**
         * Authenticates the user remotelly then locally.
         * User has the following format:
         * {
         * "UserName": String,
         * "OrgId": String,
         * "SiteId": String
         * }
         * 
         * @param {String} username 
         * @param {String} password 
         * @returns {Promise<UserData>} resolved with the user retuned from the server
         */
        const login = (username, password, ignoreFailure, skipClearCache) => 
            //this was set during bootstrap of the application, or on settingscontroller.js (settings screen)
            routeService.loginURL().then(url => 
                $http({
                    method: "POST",
                    url: url,
                    data: { username: username, password: password, userTimezoneOffset: new Date().getTimezoneOffset() },
                    headers: { ignorefailure: ignoreFailure },
                    timeout: 20 * 1000 // 20 seconds
                })
            )
            .then(response => {
                if (!skipClearCache) {
                    //cleaning history so that back button does not return user to login page
                    $ionicHistory.clearCache();
                }

                const userdata = response.data;

                return !!userdata["Found"]
                    ? loginLocal(userdata)
                    : $q.reject(new Error("Invalid username or password"));
            });
        

        /**
         * User has the following format:
         * {
         * "UserName": String,
         * "OrgId": String,
         * "SiteId": String
         * }
         * 
         * @returns logged user 
         */
        const currentFullUser = function () {
            return localStorageService.get(config.authkey);
        };

        /**
         * @returns username of the logged user. 
         * @deprecated use currentFullUser and querry it for wanted property instead
         */
        const currentUser = function () {
            const user = currentFullUser();
            if (!user) {
                return null;
            }
            return user["UserName"];
        };

        /**
         * @returns true if there's a user logged in, false otherwise 
         */
        const hasAuthenticatedUser = function () {
            const user = currentFullUser();
            return !!user;
        };

        /**
         * Finishes the current user session, wipes the database
         * and $broadcasts the event "security:logout" with the just now logged out user.
         * User has the following format:
         * {
         * "UserName": String,
         * "OrgId": String,
         * "SiteId": String
         * }
         * 
         * @return Promise resolved with the logged out user 
         */
        const logout = function (clearSettings =false, clearCookies = true) {
            // invalidate current session

            let current = null;

            if (clearCookies) {
                current = localStorageService.remove(config.authkey);
            } else {
                current = localStorageService.get(config.authkey);
            }
            
            // making sure the previous user is always the last "active" user
            if (!!current) {
                localStorageService.put(config.previouskey, current);
            }
            $rootScope.$broadcast($event("logout"), current);
            const toAvoid = clearSettings ? [] : ["Settings"];
            const promises = [dao.resetDataBase(toAvoid)];
            if (clearCookies) {
                promises.push(cookieService.clearCookies());
            }

            return $q.all(promises).then(() => {
                $ionicHistory.clearCache(); // clean cache otherwise some views may remain after a consecutive login
                cleanLocalStorage(); // clean non-blacklisted localstorage entries used by apps as cache
                indexCreatorService.dropIndexes(); //drop sql indexes to allow fast sync insertion
                return current;
            });
        };

        /**
         * Updates the current user's properties.
         * (will update the user properties declared in properties parameters instead of completely overriding them).
         * Will mark the current user as changed (<current_user>.metad.chaged === true).
         * Get the updated properties by using {@link #currentFullUser}.properties.
         * 
         * @param {Object} properties
         * @param {Boolean} merge if true will only 
         */
        const updateCurrentUserProperties = function (properties) {
            const current = currentFullUser();
            const merged = current.properties || {};
            angular.forEach(properties || {}, (value, key) => merged[key] = value);
            setUserProperties(current, merged);
            setHasChanged(current, true);
            localStorageService.put(config.authkey, current);
        };

        /**
         * Overrides the current user properties.
         * Will mark the current user as not changed (<current_user>.metad.chaged === false).
         * Get the updated properties by using {@link #currentFullUser}.properties.
         * 
         * @param {Object} properties 
         */
        const overrideCurrentUserProperties = function(properties) {
            if (!properties){
                return;
            }

            const current = currentFullUser();

            if (current){
                //mostly for unit tests
                setUserProperties(current, properties);
                setHasChanged(current, false);
                localStorageService.put(config.authkey, current);
            }

            
        }

        /**
         * Handles the case in which the current user is received an "unauthorized"
         * response status (indicating the user requires remote authentication).
         * For now just calls logout.
         */
        const handleUnauthorizedRemoteAccess = ionic.debounce((rejection) => {
            if (rejection &&
                rejection.config &&
                rejection.config.headers &&
                rejection.config.headers["ignorefailure"]) {
                return;
            }
            const logoutPromise = logout();
            // not at login state, transition to it with proper message
            if (!isLoginState()) {
                logoutPromise.then(() => routeService.go("login", { message: config.message.unauthorizedaccess }));
            }
        }, 0, true); //debouncing for when multiple parallel requests are unauthorized

        /**
         * Restores locally persisted authentication cookie to the webview.
         * 
         * @returns {Promise<String>} cookie value 
         */
        const restoreAuthCookie = function() {
            return cookieService.restoreCookie(config.authCookieName);
        };

        //#endregion

        //#region Service Instance

        const service = {
            login,
            loginLocal,
            currentUser,
            currentFullUser,
            hasAuthenticatedUser,
            logout,
            handleUnauthorizedRemoteAccess,
            updateCurrentUserProperties,
            overrideCurrentUserProperties,
            restoreAuthCookie
        };
        return service;

        //#endregion
    }
    //#region Service registration

    mobileServices.factory("securityService",
        ["$rootScope", "$state", "localStorageService", "routeService", "$http", "$q", "swdbDAO", "$ionicHistory", "cookieService", "$injector","indexCreatorService", securityService]);

    //#endregion

})(mobileServices, ionic, _);;
(function (mobileServices, _) {
    "use strict";

    function menuModelService(swdbDAO, $log, $injector, offlineEntities, offlineSchemaService, queryListBuilderService, dispatcherService, metadataModelService) {

        const initialMenuModel = {
            dbData: {},
            listItems: [],
            menuWc: {},
            appCount: {}
        };

        var menuModel = angular.copy(initialMenuModel);

        const reservedMenuContainers = {
            admin: "admin-section",
            user: "user-section"
        }

        function isReservedContainer(leaf) {
            return leaf.type === "MenuContainerDefinition" && _.contains(Object.values(reservedMenuContainers), leaf.id);
        }

        function isContainerMatchingId(leaf, id) {
            return leaf.type === "MenuContainerDefinition" && leaf.id === id;
        }

        function getMenuItems() {
            return menuModel.listItems;
        }

        function getApplicationMenuItems() {
            return getMenuItems().filter(leaf => !isReservedContainer(leaf));
        }

        function getReservedMenuContainers() {
            return getMenuItems().filter(isReservedContainer);
        }

        function getMenuContainerItems(id) {
            const container = getMenuItems().find(leaf => isContainerMatchingId(leaf, id));
            return container ? container.leafs : [];
        };

        function getAdminMenuItems() {
            return getMenuContainerItems(reservedMenuContainers.admin);
        }

        function getUserMenuItems() {
            return getMenuContainerItems(reservedMenuContainers.user);
        }

        function getAppCount(menuId) {
            return menuModel.appCount[menuId] || 0;
        }

        function buildListQuery(appName, menuId, extraWhereClause) {
            const menuWc = menuId && menuModel.menuWc[menuId] ? menuModel.menuWc[menuId] : "1=1";

            extraWhereClause = extraWhereClause || "1=1";

            //appending root prefix, since a left join could be present leading to ambiguity amongst columns
            return "`root`.application = '{0}' and ({1}) and ({2}) ".format(appName, menuWc, extraWhereClause);
        }

        function buildJoinObj(menu) {
            const application = metadataModelService.getApplicationByName(menu.application);
            if (!application) {
                return {};
            }
            const listSchema = offlineSchemaService.locateSchema(application, menu.schema);
            if (!listSchema) {
                return {};
            }
            return queryListBuilderService.buildJoinParameters(listSchema);
        }

        function updateAppCount(menu) {
            const joinObj = buildJoinObj(menu);
            if (menu.parameters && menu.parameters.offlinemenuwc) {
                menuModel.menuWc[menu.id] = dispatcherService.invokeServiceByString(menu.parameters.offlinemenuwc);
            }

            const query = buildListQuery(menu.application, menu.id);

            swdbDAO.countByQuery("DataEntry", query, joinObj).then((count) => {
                menuModel.appCount[menu.id] = count;
            });
        }

        function updateAppsCount() {
            const leafs = getApplicationMenuItems();
            angular.forEach(leafs, (leaf) => {
                if (leaf.type === "ApplicationMenuItemDefinition") {
                    updateAppCount(leaf);
                    return;
                }
                if (leaf.type !== "MenuContainerDefinition") {
                    return;
                }
                angular.forEach(leaf.explodedLeafs, (subLeaf) => {
                    if (subLeaf.type === "ApplicationMenuItemDefinition") {
                        updateAppCount(subLeaf);
                    }
                });
            });
        }

        function initAndCacheFromDB() {
            const log = $log.getInstance("menuModelService#initAndCacheFromDB", ["init", "metadata", "botstrap"]);
            return swdbDAO.findSingleByQuery("Menu","data is not null").then(menu => {
                if (!!menu) {
                    log.info("restoring menu");
                    menuModel.dbData = menu;
                }
                if (!menu) {
                    menu = new offlineEntities.Menu();
                    log.info("creating first menu");
                    return swdbDAO.save(menu);
                } else if (menu.data) {
                    log.info("restoring menu data");
                    menuModel.listItems = menu.data.leafs;
                }
                return menu;
            });
        }

        function updateMenu(serverMenu) {
            return !serverMenu || _.isEmpty(serverMenu)
                ? initAndCacheFromDB()
                : swdbDAO.instantiate("Menu", menuModel.dbData).then(menu => {
                    menu.data = serverMenu;
                    return swdbDAO.save(menu).then(item => {
                        menuModel.dbData.data = serverMenu;
                        menuModel.listItems = serverMenu.leafs;
                        return item;
                    });
                });
        }

        function reset() {
            menuModel = angular.copy(initialMenuModel);
        }

        const service = {
            getMenuItems,
            getApplicationMenuItems,
            getReservedMenuContainers,
            getMenuContainerItems,
            getAdminMenuItems,
            getUserMenuItems,
            buildListQuery,
            getAppCount,
            updateAppsCount,
            updateMenu,
            initAndCacheFromDB,
            reset
        };
        return service;
    };

    mobileServices.factory("menuModelService", ["swdbDAO", "$log", "$injector", "offlineEntities", "offlineSchemaService", "queryListBuilderService", "dispatcherService", "metadataModelService", menuModelService]);

})(mobileServices, _);;
(function (angular) {
    "use strict";

    function menuRouterService($injector, crudContextService, $q) {
        //#region Utils
        function executeMenuService(menuleaf) {
            const menuService = menuleaf.service;
            const menuMethod = menuleaf.method;
            if (!$injector.has(menuService)) {
                return $q.reject(new Error(`service '${menuService}' not found`));
            }
            const menuServiceInstance = $injector.getInstance(menuService);
            const menuMethodInstance = menuServiceInstance[menuMethod];
            if (!angular.isFunction(menuMethodInstance)) {
                return $q.reject(new Error(`service '${menuService}' has no method '${menuMethod}'`));
            }
            return $q.when(
                menuMethodInstance.apply(menuServiceInstance, [menuleaf])
            );
        }

        //#endregion

        //#region Public methods

        function routeFromMenuItem(menuleaf) {
            switch (menuleaf.type) {
                case "ApplicationMenuItemDefinition":
                    return crudContextService.loadApplicationGrid(menuleaf.application, menuleaf.schema, menuleaf.id, menuleaf.parameters);
                case "ServiceMenuItemDefinition":
                    return executeMenuService(menuleaf);
                default:
                    return $q.reject(new Error(`Unsupported menu type '${menuleaf.type}'`));
            }
        }

        //#endregion

        //#region Service Instance
        const service = {
            routeFromMenuItem
        };
        return service;
        //#endregion
    }

    //#region Service registration

    angular.module("sw_mobile_services").factory("menuRouterService", ["$injector", "crudContextService", "$q", menuRouterService]);

    //#endregion

})(angular);;
(function (angular, mobileServices, _) {
    "use strict";

    function offlineCommandService(dao, $q, $log, commandCommonsService, $injector) {
        //#region Utils
        var cachedCommands = {};
        //#endregion

        //#region Public methods

        function initAndCacheFromDataBase() {
            return dao.findAll("CommandBar").then(bars => {
                var commandBars = {};
                if (!bars || bars.length <= 0) {
                    return commandBars;
                }
                $log.get("offlineCommandService#initAndCacheFromDataBase").debug("init ");
                angular.forEach(bars, (bar) => commandBars[bar.key] = bar.data);
                return cachedCommands = commandBars;
            });
        }

        function updateCommandBars(bars) {
            $log.get("commandService#updateCommandBars", ["metadata", "commands"]).debug("updating commandbars", bars);
            return !bars || _.isEmpty(bars)
                ? $q.when()
                : dao.deleteTable("CommandBar")
                    .then(() => $q.all(Object.keys(bars).map(key => dao.instantiate("CommandBar", { key, data: bars[key] }))))
                    .then(b => $q.when(persistence.transaction(tx => dao.bulkSave(b, tx))))
                    .then(b => cachedCommands = bars);
        }

        function getCommands(schema, position) {
            return commandCommonsService.getCommands(schema, position, cachedCommands);
        }

        function executeCommand(command, schema, datamap) {
            const log = $log.get("offlineCommandService#executeCommand", ["commands"]);
            log.debug(`Executing command ${command.service}.${command.method}`);
            const q = $q.defer();
            try {
                const commandService = $injector.getInstance(command.service);
                q.resolve(commandService[command.method](schema, datamap));
            } catch (e) {
                const error = new Error(`Failed to execute command ${command.service}.${command.method} due to ${e}`);
                log.error(error);
                q.reject(error);
            }
            return q.promise;
        }

        function isCommandHidden(datamap, schema, command) {
            return commandCommonsService.isCommandHidden(datamap, schema, command);
        }

        //#endregion

        //#region Service Instance
        const service = {
            updateCommandBars,
            getCommands,
            initAndCacheFromDataBase,
            executeCommand,
            isCommandHidden
        };
        return service;
        //#endregion
    }

    //#region Service registration

    mobileServices.factory("offlineCommandService", ["swdbDAO", "$q", "$log", "commandCommonsService", "$injector", offlineCommandService]);

    //#endregion

})(angular, mobileServices, _);;
(function (angular) {
    "use strict";

    function iconProviderService($log, crudContextService, $state, $injector, offlineSchemaService, statuscolorService) {
        //#region Utils

        const providerCache = {};


        function getCurrentSchema() {
            const state = $state.current.name;
            if (state.startsWith("main.crudlist")) {
                return crudContextService.currentListSchema();
            } else if (state.startsWith("main.cruddetail")) {
                return crudContextService.currentDetailSchema();
            }
            return null;
        }

        const schemaKey = (schema) => schema.applicationName + "#" + schema.schemaId;

        function innerCurrentIconProvider(schema) {
            const iconProviderName = schema.properties["mobile.icon.provider"];
            if (!iconProviderName) return null;

            const log = $log.get("iconProviderService#currentIconProvider", ["icon", "metadata"]);
            if (!$injector.has(iconProviderName)) {
                log.warn(`service '${iconProviderName}' not found`);
                return null;
            }

//            log.debug(`using '${iconProviderName}' as icon provider for schema '${schema.schemaId}' in application '${schema.applicationName}'`);
            return $injector.get(iconProviderName);
        }

        function currentIconProvider() {
            const schema = getCurrentSchema();
            if (!schema || !schema.properties) return null;

            const key = schemaKey(schema);
            if (providerCache.hasOwnProperty(key)) {
                return providerCache[key];
            }

            const provider = innerCurrentIconProvider(schema);
            providerCache[key] = provider;
            return provider;
        }

        function delegateToDeclaredServiceProxy(method, methodName, iconService) {
            // const methodName = method.name; --> does not work in uglified scripts
            return function () {
                if (!iconService || !iconService[methodName] || !angular.isFunction(iconService[methodName])) {
                    return method.apply(null, arguments);
                }
                const serviceResult = iconService[methodName].apply(iconService, arguments);
                return serviceResult == null
                    ? method.apply(null, arguments)
                    : serviceResult;
            };
        }

        //#endregion

        //#region Public methods

        function getIconColor(item) {
            if (!item) {
                return null;
            }

            const datamap = item.datamap;
            const defaultColor = "#808080";

            if (!datamap) {
                return defaultColor;
            }

            const displayable = offlineSchemaService.locateDisplayableByQualifier(crudContextService.currentListSchema(), "icon");

            if (!displayable || !displayable.attribute || displayable.attribute === "status") {
                if (!!datamap) {
                    return statuscolorService.getColor(datamap["status"], crudContextService.currentApplicationName());
                }
            }

            if (!displayable || !displayable.attribute || displayable.attribute === "wopriority") {
                return statuscolorService.getPriorityColor(datamap[displayable.attribute]);
            }

            return defaultColor;
        }

        function getTextColor(item) {
            const background = getIconColor(item);
            return background === "white" || background === "transparent" ? "black" : "white";
        }

        function getIconClass(item, iscomposition) {
            if (!item) {
                return null;
            }

            if (item.hasProblem) {
                return 'hasproblem';
            }

            if ((iscomposition === "true" && !item.id) || (iscomposition !== "true" && !item.remoteId)) {
                return "isnew";
            }

            if (item.isDirty || item[constants.localIdKey]) {
                return 'isdirty';
            }

            if (item.pending) {
                return 'ispending';
            }

            //composition item
            if (iscomposition === "true") {
                return crudContextService.tabIcon();
            }

            return null;
        }

        function getIconText(item, iscomposition) {
            if (!item) {
                return null;
            }
            if (item.isDirty || item.pending || item.hasProblem) {
                return "";
            }

            const datamap = item.datamap;

            if (!datamap) {
                return null;
            }

            if ((iscomposition === "true" && !item.id) || (iscomposition !== "true" && !item.remoteId)) {
                return "";
            }

            const displayable = offlineSchemaService.locateDisplayableByQualifier(crudContextService.currentListSchema(), "icon");

            if (!displayable || !displayable.attribute || displayable.attribute === "status") {
                var status = null;

                if (!!datamap) {
                    status = datamap["status"];
                }

                return status == null ? "N" : status.charAt(0);
            }

            var value = datamap[displayable.attribute];

            if (!displayable || !displayable.attribute || displayable.attribute === "wopriority") {
                item.icon = value ? null : "flag";
                return value ? value.substring(0, 1) : "";
            }

            if (!value) {
                return null;
            }
            value += "";

            return value.substring(0, 1);
        }

        function getIconIcon(item, iscomposition) {
            if (!item) {
                return null;
            }

            if (item.hasProblem) {
                return "exclamation-triangle";
            }

            if ((iscomposition === "true" && !item.id) || (iscomposition !== "true" &&!item.remoteId)) {
                return "plus";
            }

            if (item.isDirty || item[constants.localIdKey]) {
                return "refresh";
            }

            if (item.pending) {
                return "cloud";
            }

            const displayable = offlineSchemaService.locateDisplayableByQualifier(crudContextService.currentListSchema(), "icon");
            if (!displayable) {
                return null;
            }

            if (!item.datamap) {
                return null;
            }

            const value = item.datamap[displayable.attribute];
            if (displayable.attribute === "wopriority" && !value) {
                return "flag";
            }

            return null;
        }

        function getIcon(item, iscomposition) {
            const iconService = currentIconProvider();
            return {
                color: delegateToDeclaredServiceProxy(getIconColor, "getIconColor", iconService)(item),
                text: delegateToDeclaredServiceProxy(getIconText, "getIconText", iconService)(item, iscomposition),
                icon: delegateToDeclaredServiceProxy(getIconIcon, "getIconIcon", iconService)(item, iscomposition),
                textColor: delegateToDeclaredServiceProxy(getTextColor, "getTextColor", iconService)(item),
                clazz: delegateToDeclaredServiceProxy(getIconClass, "getIconClass", iconService)(item, iscomposition)
            }
        }

        //#endregion

        //#region Service Instance
        const service = {
            getIcon
        };
        return service;
        //#endregion
    }

    //#region Service registration

    angular.module("sw_mobile_services").factory("iconProviderService", ["$log", "crudContextService", "$state", "$injector", "offlineSchemaService", "statuscolorService", iconProviderService]);

    //#endregion

})(angular);;
(function (mobileServices) {
    "use strict";

    mobileServices.factory('metadataModelService', ["$q", "$log", "swdbDAO", "dispatcherService", function ($q, $log, swdbDAO, dispatcherService) {

    var initialMetadataModel = {
        topLevelApplications: [],
        compositionApplications: [],
        associationApplications: []
    }
    
    //so that we have the original object available for resetting it
    var metadataModel = angular.copy(initialMetadataModel);

    function loadEntityInstance(serverMetadata, memoryArrayName, mergefunctionCBK) {

        var applicationName = serverMetadata.applicationName;
        const applications = metadataModel[memoryArrayName];
        const loadedEntity = $.findFirst(applications, function (el) {
            return el.application === applicationName;
        });
        var dbId = null;
        if (loadedEntity) {
            //setup database id for merging
            dbId = loadedEntity.id;
        }
        return swdbDAO.instantiate('Application', { id: dbId }, function (memoryObject, entity) {
            entity.data = serverMetadata;
            entity.application = applicationName;
            mergefunctionCBK(memoryObject, entity);
            return entity;
        });
    }


    function doUpdateMetadata(serverMetadatas, memoryArrayName, mergefunctionCbk) {
        /// <summary>
        /// Receives a list of metadas from the server, and update the memory instance and the database, 
        /// so that next time the customer has the updated data.
        /// 
        /// 
        /// </summary>
        /// <param name="serverMetadatas">an array of metadatas received from the server</param>
        /// <param name="memoryArray">which memory array to use</param>
        /// <returns type="promise"></returns>
        var defer = $q.defer();
        const memoryArray = metadataModel[memoryArrayName];
        if (isArrayNullOrEmpty(serverMetadatas)) {
            defer.resolve();
            return defer.promise;
        }
        const instancesToSavePromises = [];
        var instancesToDelete = [];

        for (let i = 0; i < serverMetadatas.length; i++) {
            const applicationMetadata = serverMetadatas[i];
            instancesToSavePromises.push(loadEntityInstance(applicationMetadata, memoryArrayName, mergefunctionCbk));
        }

        for (let j = 0; j < memoryArray.length; j++) {
            var entity = memoryArray[j];
            const serverInstance = $.findFirst(serverMetadatas, function (el) {
                return el.applicationName === entity.application;
            });
            if (!serverInstance) {
                //this means that this entry was not returned from the server, and hence needs to be deleted
                instancesToDelete.push(entity);
            }
        }

        return $q.all(instancesToSavePromises)
            .then(function (results) {
                return $q.all([swdbDAO.bulkSave(results), swdbDAO.bulkDelete(instancesToDelete)]);
            }).then(function (savedInstances) {
                //updating the model, only if save is actually performed
                metadataModel[memoryArrayName] = savedInstances[0];
                defer.resolve();
            });
    };


    return {

        getMetadatas: function () {
            return metadataModel.topLevelApplications;
        },

        getApplicationByName: function (applicationName, includeAssociations) {
            const metadatas = this.getMetadatas();
            for (let i = 0; i < metadatas.length; i++) {
                const metadata = metadatas[i];
                if (metadata.application === applicationName) {
                    return metadata;
                }
            }
            if (!!includeAssociations) {
                return metadataModel.associationApplications.find(a => a.application === applicationName);
            }
            return null;
        },

     

        getApplicationNames: function () {
            const appNames = [];
            const metadatas = this.getMetadatas();
            if (!metadatas) {
                return appNames;
            }
            for (let i = 0; i < metadatas.length; i++) {
                appNames.push(metadatas[i].application);
            }
            return appNames;
        },


        updateTopLevelMetadata: function (serverMetadatas) {
            return doUpdateMetadata(serverMetadatas, 'topLevelApplications',
                function (memoryObject, entity) {
                    entity.association = false;
                    entity.composition = false;
                    return entity;
                });
        },

        updateCompositionMetadata: function (serverMetadatas) {
            return doUpdateMetadata(serverMetadatas, 'compositionApplications',
                function (memoryObject, entity) {
                    entity.association = false;
                    entity.composition = true;
                    return entity;
                });
        },

        updateAssociationMetadata: function (serverMetadatas) {
            return doUpdateMetadata(serverMetadatas, 'associationApplications',
                function (memoryObject, entity) {
                    entity.association = true;
                    entity.composition = false;
                    return entity;
                });
        },


        initAndCacheFromDB: function () {
            var log = $log.getInstance("metadataModelService#initAndCacheFromDB",["init","metadata", "botstrap"]);
            var defer = $q.defer();
            swdbDAO.findAll("Application").then(function (applications) {
                metadataModel.associationApplications = [];
                metadataModel.compositionApplications = [];
                metadataModel.topLevelApplications = [];
                for (let i = 0; i < applications.length; i++) {
                    const application = applications[i];
                    if (application.association) {
                        log.info("caching association {0}".format(application.application));
                        metadataModel.associationApplications.push(application);
                    } else if (application.composition) {
                        log.info("caching composition {0}".format(application.application));
                        metadataModel.compositionApplications.push(application);
                    } else {
                        log.info("caching topLevel App {0}".format(application.application));
                        metadataModel.topLevelApplications.push(application);
                    }
                }
                defer.resolve();
            });
            return defer.promise;

        },

        getCompositionByName: function (applicationName) {
            const comps = metadataModel.compositionApplications;
            return !comps ? null : comps.find(a => a.application === applicationName);
        },

        reset:function() {
            metadataModel = angular.copy(initialMetadataModel);
        }

    }
}]);

})(mobileServices);
;
(function (angular, _) {
    "use strict";

    mobileServices.factory('offlineAssociationService', ["swdbDAO", "fieldService", "crudContextHolderService", "$log", "searchIndexService", "dispatcherService",
        function (swdbDAO, fieldService, crudContextHolderService, $log, searchIndexService, dispatcherService) {

        function testEmptyExpression(label) {
            return `(!!${label} && ${label} !== \'null\' && ${label} !== \'undefined\')`;
        }

        function fieldValueExpression(fieldMetadata) {
            return `datamap.${fieldMetadata.valueField}`;
        };

        function fieldLabelExpression(fieldMetadata) {
            const associationValueField = this.fieldValueExpression(fieldMetadata);
            if ("true" === fieldMetadata.hideDescription) {
                return associationValueField;
            }
            const label = `datamap.${fieldMetadata.labelFields[0]}`;

            return _.contains([false, "false", "False", 0, "0"], fieldMetadata.rendererParameters["showCode"])
                // show only label/description
                ? `(${testEmptyExpression(label)} ? ${label} : \'\')`
                // show <code> - <label>
                : `(${testEmptyExpression(associationValueField)} ? ${associationValueField} : \'\' ) + (${testEmptyExpression(label)} ? (\' - \'  + ${label}) : \'\')`;
        };

        function getWhereClause(displayable, parentdatamap) {
            var whereClause = displayable.schema.dataProvider.whereClause;
            if (whereClause.startsWith("@")) {
                whereClause = dispatcherService.invokeServiceByString(whereClause.substring(1));
            }
            return searchIndexService.parseWhereClause(whereClause, parentdatamap);
        }

        function filterPromise(parentSchema, parentdatamap, associationName, filterText, preCalcDisplayable, pageNumber, useWhereClause, currentValue) {
            const log = $log.get("offlineAssociationService#filterPromise", ["association", "query"]);

            const displayable = preCalcDisplayable || fieldService.getDisplayablesByAssociationKey(parentSchema, associationName)[0];

            if (associationName.endsWith("_")) {
                associationName = associationName.substring(0, associationName.length-1);
            }
            var associationAsEntityName = displayable.entityAssociation.to;
            
            //the related application could have been downloaded using either the qualifier or the entity name, 
            //but it doesnÂ´t matter here, as the other relationships will be used
            var baseQuery = " (application = '{0}' or application = '{1}' )".format(associationName, associationAsEntityName);
            if (!nullOrEmpty(filterText)) {
                baseQuery += " and datamap like '%{0}%' ".format(filterText);
            }

            angular.forEach(displayable.entityAssociation.attributes, function (attribute) {
                if (attribute.primary) {
                    return;
                }
                var allowsNull = false;
                var fromValue;
                if (attribute.literal) {
                    //siteid = 'SOMETHING'
                    fromValue = attribute.literal;
                } else {
                    //siteid = siteid
                    allowsNull = attribute.allowsNull;
                    fromValue = parentdatamap[attribute.from];
                }
                if (allowsNull) {
                    baseQuery += ' and ( datamap like \'%"{0}":"{1}"%\' or datamap like \'%"{0}":null%\' )'.format(attribute.to, fromValue);
                } else {
                    if (!fromValue) {
                        log.info(`field ${attribute.from} could not be found on the datamap ignoring it`);
                    } else {
                        baseQuery += ' and datamap like \'%"{0}":"{1}"%\''.format(attribute.to, fromValue);
                    }

                    
                }
            });

            if (displayable.schema && displayable.schema.dataProvider && displayable.schema.dataProvider.whereClause && useWhereClause) {
                baseQuery += ` and (${getWhereClause(displayable, parentdatamap)}) `;
            }

            if (currentValue) {
                baseQuery += ` order by (datamap like "%${currentValue}%") desc `;
            }

            pageNumber = pageNumber || 1;
            return swdbDAO.findByQuery("AssociationData", baseQuery, { pagesize: 10, pageNumber: pageNumber, projectionFields: ["datamap"] });
        }

        function updateExtraProjections(associationDataEntry, associationKey) {
            const log = $log.get("offlineAssociationService#updateExtraProjections", ["association"]);
            const isComposition = !crudContextHolderService.isOnMainTab();
            const detailSchema = isComposition
                ? crudContextHolderService.getCompositionDetailSchema()
                : crudContextHolderService.currentDetailSchema();
            const associationMetadata = fieldService.getDisplayablesByAssociationKey(detailSchema, associationKey)[0];
            if (!associationMetadata || !associationMetadata.extraProjectionFields) {
                log.trace(`no extraprojectionfields to update for ${associationKey}`);
                return;
            }
            
            const dm = crudContextHolderService.currentDetailItemDataMap();
            const associationDataMap = associationDataEntry.datamap;
            log.info(`updating extraprojection fields for ${associationKey}`);
            associationMetadata.extraProjectionFields.forEach(item => {
                const projectedKey = associationKey + "." + item;
                const value = associationDataMap[item];
                log.debug(`updating ${projectedKey} to ${value}`);
                dm[projectedKey] = value;
            });

        }

        function updateExtraProjectionsForOptionField(optionFieldEntry, associationKey) {
            const log = $log.get("offlineAssociationService#updateExtraProjections", ["association"]);
            const isComposition = !crudContextHolderService.isOnMainTab();
            const detailSchema = isComposition
                ? crudContextHolderService.getCompositionDetailSchema() 
                : crudContextHolderService.currentDetailSchema();
            const associationMetadata = fieldService.getDisplayablesByAssociationKey(detailSchema, associationKey)[0];
            const extrafields = optionFieldEntry.extrafields;

            if (!associationMetadata || !extrafields) {
                log.trace(`no extraprojectionfields to update for ${associationKey}`);
                return;
            }
            const dm = crudContextHolderService.currentDetailItemDataMap();

            log.info(`updating extraprojection fields for ${associationKey}`);
            Object.keys(extrafields).forEach((item )=> {
                const projectedKey = associationKey + "_." + item;
                const value = extrafields[item];
                log.debug(`updating ${projectedKey} to ${value}`);
                dm[projectedKey] = value;
            });

        }


        const api = {
            filterPromise,
            fieldLabelExpression,
            fieldValueExpression,
            updateExtraProjections,
            updateExtraProjectionsForOptionField,
        }
        return api;

    }]);

})(angular, _);;
(function (angular, _) {
    "use strict";

    angular.module("sw_mobile_services").factory("offlineSchemaService", ["$log", "fieldService","formatService", "schemaService", "securityService", "dispatcherService",  "metadataModelService", offlineSchemaService]);

    function offlineSchemaService($log, fieldService,formatService, schemaService, securityService, dispatcherService, metadataModelService) {

        const dateFormat = "MMM DD";
        const dateFormatHours = "MMM DD hh a";
        const dateFormatMinutes = "MMM DD hh:mm a";

        function loadDetailSchema(currentListSchema, currentApplication, selectedItem) {
            var detailSchemaId = "detail";
            var schemaDetailService = schemaService.getProperty(currentListSchema, "list.click.service");
            var overridenSchema = !!schemaDetailService && !!selectedItem
                                    ? dispatcherService.invokeServiceByString(schemaDetailService, [currentApplication, currentListSchema, selectedItem])
                                    : schemaService.getProperty(currentListSchema, "list.click.schema");
            if (overridenSchema) {
                detailSchemaId = overridenSchema;
            }
            return this.locateSchema(currentApplication, detailSchemaId);
        };

        function locateSchema(application, schemaId) {
            var schemasList = application.data.schemasList;

            for (var i = 0; i < schemasList.length; i++) {
                var schema = schemasList[i];
                if ("list".equalsIc(schema.stereotype)) {
                    //build dict cache
                    buildQualifierCache(schema);
                }
                if (schema.schemaId.equalsIc(schemaId)) {
                    return schema;
                }
            }
            return null;
        };


        function buildQualifierCache(schema) {
            schema.jscache = schema.jscache || {};
            if (schema.jscache.griddisplayables) {
                //already cached
                return;
            }
            schema.jscache.qualifiercache = {};
            var displayables = schema.displayables;
            for (var i = 0; i < displayables.length; i++) {
                var displayable = displayables[i];
                if (displayable.qualifier) {
                    schema.jscache.qualifiercache[displayable.qualifier] = displayable;
                }
            }
        };

        function locateSchemaByStereotype(application, stereotype) {
            if (isString(application)) {
                application = metadataModelService.getApplicationByName(application,true);
            }
            if (application == null) {
                return null;
            }

            var schemasList = application.data.schemasList;

            for (var i = 0; i < schemasList.length; i++) {
                var schema = schemasList[i];
                if (schema.stereotype == "list") {
                    //build dict cache
                    buildQualifierCache(schema);
                }
                if (stereotype.equalsIc(schema.stereotype)) {
                    return schema;
                }
                else if ("detail".equalsIc(stereotype) && schema.schemaId.equalsIc("detail")) {
                    return schema;
                }
            }
            return null;
        };

        function setValueIfNotPresent(item, field, value) {
            if (!item[field]) {
                item[field] = value;
            }
        }

        function fillDefaultOfflineValues(schema, item) {
            var user = securityService.currentFullUser();
            // TODO: handle case where no default value is supposed to be used (client forcefully regitered empty default value)
            setValueIfNotPresent(item, "siteid", user["SiteId"]);
            setValueIfNotPresent(item, "orgid", user["OrgId"]);
        };

        function fillDefaultValues(schema, item, parent) {
            var scope = !!parent ? { previousdata: { fields: parent }, parentdata: { fields: parent } } : {};
            fieldService.fillDefaultValues(schema.displayables, item, scope);
            fillDefaultOfflineValues(schema, item);
        };

        function locateDisplayableByQualifier(schema, qualifier) {
            if (schema == null) {
                return null;
            }

            schema.jscache = schema.jscache || {};
            if (schema.jscache.qualifiercache) {
                //already cached
                return schema.jscache.qualifiercache[qualifier];
            }
            buildQualifierCache(schema);
            const item = schema.jscache.qualifiercache[qualifier];
            return item ? item.attribute : null;
        }

        function formatDate(dateString, showHours, showMinutes) {
            if (!dateString) {
                return null;
            }
            const dateMoment = moment(dateString);
            if (showMinutes) {
                return dateMoment.format(dateFormatMinutes);
            }
            if (showHours) {
                return dateMoment.format(dateFormatHours);
            }
            return dateMoment.format(dateFormat);
        }


        function locateRelatedListSchema(mainListSchema, childEntityName) {
            const entityAssociation = mainListSchema.offlineAssociations[childEntityName];
            const application = metadataModelService.getApplicationByName(entityAssociation.to, true);
            return application.data.schemasList.find(s => s.stereotypeAttr === "list");
        }

        /**
         * Receives a field on the format #xxx_.yyy and returns the relationship name (i.e xxx_ )
         * @param {} transientFieldName 
         * @returns {} 
         */
        function findRelatedEntityName(transientFieldName) {
            if (!transientFieldName.contains(".")) {
                return { attribute: transientFieldName };
            }

            const nonTransientValue = transientFieldName.substr(1);
            const entityName = nonTransientValue.substr(0, nonTransientValue.indexOf("."));
            const attribute = nonTransientValue.substr(nonTransientValue.indexOf(".")+1);
            return { entityName, attribute };
        }

        function buildDisplayValue(schema, qualifier, item) {
            if (schema == null) {
                return null;
            }

            const displayable = locateDisplayableByQualifier(schema, qualifier);
            if (!displayable || !displayable.attribute || !item) {
                return null;
            }

            if ("featured" === qualifier && ("datetime" === displayable.dataType || "timestamp" === displayable.dataType || "datetime" === displayable.rendererType )) {
                return formatDate(item[displayable.attribute], true, true);
            }
            if ("featured" === qualifier && ("date" === displayable.dataType || "date" === displayable.rendererType)) {
                return formatDate(item[displayable.attribute], false, false);
            }

            if (_.contains([true, "true"], displayable.rendererParameters["showLabel"])) {
                return `${displayable.label}: ${item[displayable.attribute]}`;
            }

            if (displayable.rendererParameters["formatter"]){
                return formatService.format(item[displayable.attribute],displayable,item);
            }

            return item[displayable.attribute];
        }

        function getFieldByAttribute(schema, attribute) {
            Validate.notEmpty(schema);
            const fields = schema.displayables;
            return !fields || fields.length <= 0 ? null : fields.find(f => f.attribute === attribute);
        }



        const service = {
            loadDetailSchema,
            locateSchema,
            locateSchemaByStereotype,
            locateRelatedListSchema,
            fillDefaultValues,
            findRelatedEntityName,
            locateDisplayableByQualifier,
            buildDisplayValue,
            getFieldByAttribute
        };
        return service;

    }
})(angular, _);;
(function (angular) {
    "use strict";

    let areSettingsFullFilled;

    class initialRouterService {

        constructor($log,$q, settingsService, securityService, loadingService, swAlertPopup, routeService,crudContextService) {
            this.$log = $log;
            this.$q = $q;
            this.settingsService = settingsService;
            this.securityService = securityService;
            this.loadingService = loadingService;
            this.swAlertPopup = swAlertPopup;
            this.routeService = routeService;
            this.crudContextService = crudContextService;

            areSettingsFullFilled = function (settings) {
                return !!settings && !!settings.serverurl && settings.serverurl !== "http://";
            }
        }

        doInit() {

            const log = this.$log.get("initialRouteService#doInit", ["init", "bootstrap"]);

            const authenticated = this.securityService.hasAuthenticatedUser();
            this.crudContextService.restoreState();

            //should not be present at production mode
            const localdata = window.localdevdata;
            if (localdata && !!localdata.debuglogs) {
                const debugarr = localdata.debuglogs;
                debugarr.forEach(log => {
                    swlog.debug(log);
                });
            }

            if (!localdata || localdata.showlogin) {
                log.debug("redirecting to initial state");
                return this.routeService.loadInitialState(authenticated);
            }

            

            log.debug("applying local rules");

            //if we are on development mode letÂ´s handle authentication automatically to boost productivity
            return this.settingsService.getSettings().then(s => {
                
                

                if (areSettingsFullFilled(s) && authenticated) {
                    this.crudContextService.restoreState();
                    return this.routeService.loadInitialState(authenticated);
                }

                this.loadingService.showDefault();
                const serverurl = isRippleEmulator() ? localdata.serverurl.ripple : localdata.serverurl.device;

                const that = this;

                return this.settingsService.saveSettings({ serverurl })
                    .then(() => {
                        return that.securityService.login(localdata.username, localdata.password);
                    }).then(() => {
                        if (isRippleEmulator()) {
                            return this.$q.when();
                        }
                        return that.routeService.go("main.home");
                    }).catch(function(error) {
                        that.securityService.logout();
                        that.swAlertPopup.show({
                            title: "Login failed",
                            template: !!error && !!error.message ? error.message : "Please check your credentials."
                        });
                        return that.routeService.loadInitialState(authenticated);
                    }).finally(function() {
                        that.loadingService.hide();
                    });
            });

            

            
        }
    }


    initialRouterService["$inject"] = ["$log", "$q", "settingsService", "securityService", "loadingService", "swAlertPopup", "routeService", "crudContextService"];

    angular.module("sw_mobile_services").service("initialRouterService", initialRouterService);

})(angular);;
(function (angular) {
    "use strict";

    angular.module("sw_mobile_services").constant("routeConstants", {
        events: {
            'sameStateTransition': "sw:$state:transition:same"
        }
    });

})(angular);;
(function (mobileServices) {
    "use strict";



    class routeService {
        constructor($state, contextService, settingsService, localStorageService, loadingService, $rootScope, routeConstants) {
            this.$state = $state;
            this.localStorageService = localStorageService;
            this.contextService = contextService;
            this.settingsService = settingsService;
            this.loadingService = loadingService;
            this.$rootScope = $rootScope;
            this.routeConstants = routeConstants;
            this.loginURL = () => this.settingsService.getServerUrl().then(url => url + "/SignIn/SignInReturningUserData");
        }

        go(stateName, params) {
            // TODO: insert params in the context and recover
            this.contextService.insertIntoContext("currentstate", stateName);
            return this.loadingService.showDefault().finally(() => {
                const isSameState = this.$state.$current.name === stateName;
                const stateTransition = this.$state.go(stateName, params);
                if (isSameState) {
                    stateTransition.then(state => this.$rootScope.$broadcast(this.routeConstants.events.sameStateTransition, state));
                }
                this.loadingService.hide();
            });
        }


        loadInitialState(authenticated) {
            if (!authenticated) {
                return !this.localStorageService.get("settings:serverurl") ? this.go("settings") : this.go("login");
            }
            const currentState = this.contextService.getFromContext("currentstate");
            if (isRippleEmulator() && currentState) {
                return this.go(currentState);
            }
            return this.go("main.home");
        }

    }

    routeService["$inject"] = ["$state", "contextService", "settingsService", "localStorageService", "loadingService", "$rootScope", "routeConstants"];

    mobileServices.service('routeService', routeService);


})(mobileServices)
;
(function (mobileServices) {
    "use strict";

    mobileServices.factory("associationDataSynchronizationService",
        ["$http", "$log", "$q", "swdbDAO", "metadataModelService", "offlineRestService", "rowstampService", "offlineEntities", "searchIndexService", "securityService", "applicationStateService",
            function ($http, $log, $q, swdbDAO, metadataModelService, restService, rowstampService, offlineEntities, searchIndexService, securityService, applicationStateService) {

                return {

                    doInsert: function (queryToUse, result, appArray) {

                        const queryArray = [];

                        for (let i = 0; i < appArray.length; i++) {
                            const app = appArray[i];

                            const associationData = result.data.associationData;
                            const textIndexes = result.data.textIndexes[app];
                            const numericIndexes = result.data.numericIndexes[app];
                            const dateIndexes = result.data.dateIndexes[app];

                            const associationDatadto = associationData[app];

                            let dataToInsert = associationDatadto.individualItems;
                            const remoteIdFieldName = associationDatadto.remoteIdFieldName;

                            for (let j = 0; j < dataToInsert.length; j++) {
                                const data = dataToInsert[j];
                                const id = persistence.createUUID();

                                const json = data.jsonFields || JSON.stringify(data);//keeping backwards compatibility //newJson = datamapSanitizationService.sanitize(newJson);
                                const datamap = data.jsonFields ? JSON.parse(data.jsonFields) : data; //keeping backwards compatibility //newJson = datamapSanitizationService.sanitize(newJson);
                                const remoteid = datamap[remoteIdFieldName];

                                let idx = data.indexData;
                                if (!data.indexData){
                                    //legacy mode
                                    idx = searchIndexService.buildIndexes(textIndexes, numericIndexes, dateIndexes, datamap)
                                }
                                const query = { query: queryToUse, args: [data.application, json, String(data.approwstamp), id, idx.t1, idx.t2, idx.t3, idx.t4, idx.t5, idx.n1, idx.n2, idx.d1, idx.d2, idx.d3, remoteid] };
                                queryArray.push(query);
                            }
                        }
                        return swdbDAO.executeQueries(queryArray).then(() => {
                            return queryArray.length;
                        });
                    },


                    doInsertRecursively: function (queryToUse, result, apps, chunkSize, initialSliceIndex, count) {
                        const log = $log.get("associationDataSynchronizationService#doInsertRecursively", ["association", "sync"]);
                        var doInsertRecursivelyFn = this.doInsertRecursively.bind(this);
                        var finalIndex = initialSliceIndex + chunkSize;
                        if (finalIndex > apps.length) {
                            finalIndex = apps.length;
                        }
                        const appsToInsert = apps.slice(initialSliceIndex, finalIndex);
                        log.debug(`inserting association apps ${appsToInsert.join(',')}`);


                        return this.doInsert(queryToUse, result, appsToInsert).then(r => {
                            count += r;
                            if (apps.length > finalIndex) {
                                initialSliceIndex += chunkSize;
                                return doInsertRecursivelyFn(queryToUse, result, apps, chunkSize, initialSliceIndex, count);
                            }
                            return $q.when(count);
                        });
                    },

                    /// <summary>
                    /// 
                    /// </summary>
                    /// <param name="applicationToFetch">a single application to fetch. If not provided, all the applications would be fetched</param>
                    /// <returns type=""></returns>
                    syncData: function (firstTime, clientOperationId, applicationsToFetch = [], chunkRound = 1, totalCount = 0, completeCacheEntries = []) {

                        return applicationStateService.getServerDeviceData()
                            .then(deviceData => {
                                const log = $log.get("associationDataSynchronizationService#syncData", ["association", "sync"]);

                                log.info("bringing server side data to apply based on rowstampmap");

                                const syncDataFn = this.syncData.bind(this);

                                const doInsertFn = this.doInsertRecursively.bind(this);

                                const params = {};

                                return rowstampService.generateAssociationRowstampMap(applicationsToFetch, firstTime).then(rowstampMap => {
                                    const payload = { rowstampMap, clientOperationId, deviceData };
                                    const current = securityService.currentFullUser();
                                    if (current && current.meta && current.meta.changed) {
                                        payload.userData = current;
                                    }
                                    payload.applicationsToFetch = applicationsToFetch;
                                    payload.initialLoad = firstTime;
                                    payload.completeCacheEntries = completeCacheEntries;

                                    return restService.post("Mobile", "PullAssociationData", params, payload);
                                }).then(result => {
                                    const associationData = result.data.associationData;

                                    if (result.data.isEmpty) {
                                        return totalCount;
                                    }

                                    //for first time, letÂ´s not use the replace keyword in order to make the query faster (we know for sure they are all insertions)
                                    //TODO: check possibility of having different arrays
                                    const queryToUse = firstTime ? offlineEntities.AssociationData.InsertionPattern.format("") : offlineEntities.AssociationData.InsertionPattern.format(" or REPLACE ");

                                    const apps = Object.keys(associationData);
                                    return doInsertFn(queryToUse, result, apps, apps.length, 0, 0).then(r => {
                                        totalCount += r;
                                        if (result.data.hasMoreData) {
                                            var appsforLog = result.data.incompleteAssociations.join(",");
                                            log.info(`bringing next round of chunked data (${++chunkRound}) for applications ${appsforLog}`);
                                            return syncDataFn(firstTime, clientOperationId, result.data.incompleteAssociations, chunkRound, totalCount, result.data.completeCacheEntries);
                                        }
                                        return totalCount;
                                    });
                                }).catch(err =>
                                    !err
                                        ? $q.when(0) // normal interruption 
                                        : $q.reject(err)
                                    );
                            })


                    }
                }
            }]);

})(mobileServices);;
(function (mobileServices, angular) {
    "use strict";

    /**
     * @constructor 
     */
    var AsyncSynchronizationService = function ($q, restService, $log, swdbDAO, $interval, $rootScope) {

        // Batches indexed by their id
        var batchRegistry = {};
        // list of callbacks to be called on Batch completion
        var completionCallBacks = [];
        // polling interval in milliseconds
        var pollingDelay = 60 * 1000; // TODO: get from config

        var self = this;

        // clear batchRegistry (only user related state) on logout
        $rootScope.$on("sw4:security:logout", function () {
            batchRegistry = {};
        });

        var getBatchIds = function () {
            var ids = [];
            for (var id in batchRegistry) {
                if (!batchRegistry.hasOwnProperty(id)) {
                    continue;
                }
                ids.push(id);
            }
            return ids;
        };

        var fetchBatchStatus = function () {
            var log = $log.get("asyncSynchronizationService#fetchBatchStatus");
            var ids = getBatchIds();
            if (ids.length <= 0 || completionCallBacks.length <= 0) {
                return;
            }
            var now = new Date();
            log.info("Polling request started at {0}".format(now));
            restService.get("Mobile", "BatchStatus", { ids: ids })
                .then(function (response) {
                    log.info("Polling response received");
                    return response.data;
                })
                .then(function (batches) {
                    var batchTuples = [];
                    angular.forEach(batches, function (batch) {
                        if (batch.status !== "COMPLETE") return;
                        var localBatch = batchRegistry[batch.remoteId];
                        batchTuples.push({ remote: batch, local: localBatch });
                    });
                    return batchTuples;
                })
                .then(function (batchTuples) {
                    if (batchTuples.length <= 0) {
                        log.info("no 'COMPLETE' batches received");
                        return;
                    }
                    angular.forEach(completionCallBacks, function (callback) {
                        callback({ start: now.getTime(), batchTuples: batchTuples });
                    });
                    angular.forEach(batchTuples, function (tuple) {
                        delete batchRegistry[tuple.local.id];
                    });
                })
                .catch(function (error) {
                    log.error(error);
                });
        };

        /**
         * Registers a Batch to be asynchronously processed i.e. it's "status" will be fetched asynchronously from the server.
         * If the Batch was already registered it won't be registered again (checks equality by Batch#id).
         * Since it's an assynchronous process callback functions will be called once it's status are fetched.
         * The callbacks can be registered in {@link AsyncSynchronizationService#onBatchesCompleted}.
         * 
         * @param Batch batch 
         */
        this.registerForAsyncProcessing = function (batch) {
            if (batchRegistry[batch.id]) {
                return;
            }
            batchRegistry[batch.id] = batch;
        };

        /**
         * Registers a list of Batches to be asynchronously processed.
         * Calls {@link AsyncSynchronizationService#registerForAsyncProcessing} on each element of the list
         * 
         * @param [Batch] batches 
         */
        this.registerListForAsyncProcessing = function (batches) {
            angular.forEach(batches, function (batch) {
                self.registerForAsyncProcessing(batch);
            });
        };

        /**
         * Register/add a callback to be called when a Batch status response is received.
         * The callback receives a single object as parameter:
         * <pre>
         * {
         *  "start": Number, // timestamp of when the request was made
         *  "batchTuples": [{
         *      "local": Batch, // Batch entity that was registered for async processing
         *      "remote": Object // Batch response from the server
         *  }]
         *  }
         * </pre>
         * Note that the callback receives an array of Batches instead of a single Batch. 
         * That's because this client requests the status of multiple Batches at once in order to 
         * optimize network usage.
         * Also the callback will only be called passing the Batches with status "COMPLETE" i.e. 
         * there's no need for the caller to worry about re-registering a non-complete Batch for async processing,
         * only complete Batches will be sent to the callbacks and non-complete ones will remain registered to 
         * await further completion.
         * 
         * @param Function callback 
         */
        this.onBatchesCompleted = function (callback) {
            completionCallBacks.push(callback);
        };

        /**
         * Fills the batchRegistry with initial data.
         */
        var loadBatchesForProcessing = function () {
            var ids = getBatchIds();
            ids = ids.map(function (id) {
                return "'{0}'".format(id);
            });
            var query = "status!='COMPLETE'";
            if (ids.length > 0) {
                query += " and id not in ({0})".format(ids);
            }
            swdbDAO.findByQuery("Batch", query)
                .then(function (batches) {
                    var promises = [];
                    angular.forEach(batches, function (batch) {
                        var deferred = $q.defer();
                        batch.items.prefetch("dataentry").prefetch("problem").list(null, function (items) {
                            batch.loadeditems = items;
                            deferred.resolve(batch);
                        });
                        promises.push(deferred.promise);
                    });
                    return $q.all(promises);
                })
                .then(function (batches) {
                    self.registerListForAsyncProcessing(batches);
                });
        };

        var startPolling = function () {
            var interval = isRippleEmulator() ? 10 * 1000 : pollingDelay;
            $interval(fetchBatchStatus, interval);

        };

        loadBatchesForProcessing();
        startPolling();

    };

    mobileServices.service("asyncSynchronizationService", ["$q", "offlineRestService", "$log", "swdbDAO", "$interval", "$rootScope", AsyncSynchronizationService]);

})(mobileServices, angular);
;
(function (mobileServices, angular) {
    "use strict";

    function attachmentDataSynchronizationService($q, $log, swdbDAO, entities, restService) {
        //#region Utils

        const numberOfParallelDownloads = 2;


        const matchinfFilesResolver = (matchingFiles, doclinksArray, log) => {

            

            const updateFiltercondition = syncItem => matchingFiles.some(m => m.id === syncItem.hash && (m.compositionRemoteId == null || m.docinfoRemoteId == null));

            //result will hold a list of matching files, ie, files whose hash(ids) match the ones returned from the server batch
            const attachmentsToUpdateQuery = doclinksArray.filter(updateFiltercondition).map(item => {
                //we only need to update the attachments whose compositionRemoteId are still null on the database, since the others would mean a useless operation
                return { query: entities.Attachment.UpdateRemoteIdOfExistingAttachments, args: [String(item.compositionRemoteId), String(item.docinfoid), item.hash] }
            });

            //using == instead of === to avoid string/numeric breakings
            const attachmentsToInsertQuery = doclinksArray.filter(syncItem => !matchingFiles.some(m => (m.docinfoRemoteId == syncItem.docinfoid)))
                .filter(syncItem => !matchingFiles.some(m => m.id === syncItem.hash && (m.compositionRemoteId == null || m.docinfoRemoteId == null)))
                .map(item => {
                //creating the attachments which could not be found for a given composition, excluding the ones that just got updated on the previous condition
                return { query: entities.Attachment.CreateNewBlankAttachments, args: [item.ownerTable, String(item.ownerId), String(item.compositionRemoteId), String(item.docinfoid), persistence.createUUID()] }
            });
            const attachmentQueries = attachmentsToUpdateQuery.concat(attachmentsToInsertQuery);

            if (attachmentQueries.length === 0) {
                log.debug("no attachments to be inserted/updated");
            }

            if (attachmentsToUpdateQuery.length !== 0) {
                log.debug(`${attachmentsToUpdateQuery.length} locally created attachments will get updated`);
            }

            if (attachmentsToInsertQuery.length !== 0) {
                log.debug(`${attachmentsToInsertQuery.length} attachments will get created locally`);
            }

            return $q.when(attachmentQueries);
        }

        //#endregion

        //#region Public methods
        /**
         *  Generates the queries for 
         *  1) inserting into Attachments ones that were not created locally (either on other devices or on the online mode)
         *  2) updating the remoteids for the attachments that were created locally on this particular device
         * 
         * @param {} doclinksArray 
         * @returns {} 
         */
        function generateAttachmentsQueryArray(doclinksArray) {

            if (doclinksArray.length === 0) {
                return $q.when([]);
            }
            const querySt = entities.Attachment.NonPendingAttachments;
            //gathering the list of hashs that is coming from the server sync, and checking which ones already exist locally
            //hashs would only exist for files that got created on offline devices!!

            let ids = doclinksArray.filter(f => f.hash != null).map(item => item.hash).join("','");

            let docinfoRemoteId = "'" + doclinksArray.map(item => item.docinfoid).join("','") + "'";

            const log = $log.get("attachmentDataSynchronizationService#generateAttachmentsQueryArray", ["attachment", "sync", "download"]);

            if (ids !== "") {
                ids = "'" + ids + "'";
            } 

            log.debug(`determining which attachments should be downloaded amongst ${ids} and remoteids ${docinfoRemoteId} `);
            return swdbDAO.executeQuery(entities.Attachment.NonPendingAttachments.format(ids, docinfoRemoteId)).then((results) => {
                return matchinfFilesResolver(results, doclinksArray, log);
            });
        }

        function bufferedDownload(attachmentsToDownload, originalDeferred, log) {
            const promiseDownloadBuffer = [];
            if (attachmentsToDownload.length === 0) {
                log.info(`finishing download process for attachments`);
                originalDeferred.resolve();
                return;
            }

            for (let i = 0; i < numberOfParallelDownloads; i++) {
                const promiseObj = attachmentsToDownload.shift();
                promiseDownloadBuffer.push(promiseObj);
            }
            const promisesToExecute = promiseDownloadBuffer.filter(f=> f != null);
            if (promisesToExecute.length === 0) {
                originalDeferred.resolve();
                return;
            }

            $q.all(promisesToExecute.map(p => p.promise)).then(function (results) {
                const updateQueriesObject = [];
                for (let i = 0; i < promisesToExecute.length; i++) {
                    const result = results[i];
                    const localFileId = promisesToExecute[i].id;
                    if (!result || !result.data) {
                        log.warn("server returned with a null file result... saving a error file to prevent downloading");
                        const queryObj = { query: entities.Attachment.UpdatePendingAttachment, args: ["error", "error", localFileId] }
                        updateQueriesObject.push(queryObj);
                    } else {
                        log.info("storing attachment for localid {0} ".format(localFileId));
                        const data = result.data;
                        const queryObj = { query: entities.Attachment.UpdatePendingAttachment, args: [data.content, data.mimeType, localFileId] }
                        updateQueriesObject.push(queryObj);
                    }

                }
                swdbDAO.executeQueries(updateQueriesObject).then(bufferedDownload(attachmentsToDownload, originalDeferred, log));
            });

        }

        function downloadAttachments() {
            const log = $log.get("attachmentDataSynchronizationService#downloadAttachments", ["attachment", "sync", "download"]);

            return swdbDAO.executeQuery(entities.Attachment.PendingAttachments).then((attachmentsToDownload) => {
                if (attachmentsToDownload.length === 0) {
                    log.debug("no attachments to download, resuming");
                    return null;
                }

                log.info(`starting download process for ${attachmentsToDownload.length} attachments`);

                var deferred = $q.defer();

                var fullPromiseBuffer = [];
                var length = attachmentsToDownload.length;

                attachmentsToDownload.forEach(value => {
                    const attachment = value;
                    const promise = restService.get("OfflineAttachment", "DownloadBase64", { id: attachment.docinfoRemoteId });
                    fullPromiseBuffer.push({ id: attachment.id, promise: promise });
                });
                bufferedDownload(fullPromiseBuffer, deferred, log);

                return deferred.promise;


            });
        }

        /**
         * Called just before the sync to insert the base64 data into the parent datamaps. Amongst other possible reasons, we prevent this data on the datamap so that the global search doesn't get impacted.
         * 
         * @param {} applicationName the name of the application being synced. On a sync operation we might call this method each time per application
         * @param {} dataEntries the parent entries in which the attachments should be inserted into
         * @returns {Promise} the new dataentries containing the base64 data
         */
        function mergeAttachmentData(applicationName, dataEntries) {
            const log = $log.get("attachmentDataSynchronizationService#mergeAttachmentData", ["attachment", "sync"]);
            if (!dataEntries || dataEntries.length <= 0) {
                return $q.when([]);
            }



            let ids = dataEntries.map(entry => entry.id).join("','");

            if (ids !== "") {
                ids = "'" + ids + "'";
            } 

            const queryObj = { query: entities.Attachment.ByApplicationAndIds.format(ids), args: [applicationName] };
            return swdbDAO.executeQuery(queryObj).then(attachments => {
                if (attachments.length === 0) {
                    log.debug("no attachments to uppload for application {0}".format(applicationName));
                    return $q.when(dataEntries);
                }
                attachments.forEach(attachment => {
                    var dataEntry = dataEntries.find(f => f.id === attachment.parentId);
                    var attachmentArray = dataEntry.datamap["attachment_"];
                    if (attachmentArray == null) {
                        log.trace("skipping entry {0} since it hold no attachment".format(dataEntry.id));
                        return;
                    }
                    //                    #offlinehash
                    var rightAttachmentDatamap = attachmentArray.find(a => a["#offlinehash"] === attachment.id);
                    if (rightAttachmentDatamap == null) {
                        log.warn(`could not locate attachment ${attachment.id} in any of the ${applicationName} of ids ${ids}`);
                        return;
                    }
                    rightAttachmentDatamap["newattachment"] = attachment.content;

                });
                return dataEntries;
            });


        }

        //#endregion

        //#region Service Instance
        const service = {
            generateAttachmentsQueryArray,
            downloadAttachments,
            mergeAttachmentData
        };
        return service;
        //#endregion
    }

    //#region Service registration

    mobileServices.factory("attachmentDataSynchronizationService", ["$q", "$log", "swdbDAO", "offlineEntities", "offlineRestService", attachmentDataSynchronizationService]);

    //#endregion

})(mobileServices, angular);;
(function (mobileServices, angular, persistence) {
    'use strict';

    //#region Service registration
    mobileServices.factory('batchService', ['$q', 'offlineRestService', 'swdbDAO', '$log', 'schemaService', 'offlineSchemaService', 'operationService', 'dispatcherService', 'offlineEntities', "attachmentDataSynchronizationService", "applicationStateService", service]);
    //#endregion

    function service($q, restService, swdbDAO, $log, schemaService, offlineSchemaService, operationService, dispatcherService, entities, attachmentDataSynchronizationService, applicationStateService) {

        //#region Utils

        //#region DataEntry Rollback
        /**
         * internal rollback context
         */
        var rollbackContext = {
            // Queue: DataEntry instances currently being submitted to the server
            submittingEntries: []
        };

        var logIdsIfEnabled = function (logger, level, entities, messageTemplate) {
            // just so it doesn't waste time and memory creating a message that won't be logged
            if (!logger.isLevelEnabled(level)) {
                return;
            }
            const ids = entities.map(function (e) {
                return "'{0}'".format(e.id);
            });
            logger[level](messageTemplate.format(ids));
        };

        /**
         * Adds the dataentry to the rollbackcontext.
         * 
         * @param [DataEntry] dataentry either an array of entries or a single entry
         */
        var addToRollbackContext = function (dataentry) {
            const log = $log.get("BatchService#rollback");
            if (angular.isArray(dataentry)) {
                logIdsIfEnabled(log, "debug", dataentry, "marking DataEntries {0} to rollback");
                angular.forEach(dataentry, function (e) {
                    rollbackContext.submittingEntries.push(e);
                });
            } else {
                log.debug("marking DataEntry '{0}' to rollback".format(dataentry.id));
                rollbackContext.submittingEntries.push(dataentry);
            }
        };

        /**
         * Updates the entries added to the rollbackcontext
         * setting their pending property to false.
         * 
         * (?) If the rollbackk mechanism fails for any reason the entries 
         * will remain in the rollbackcontext. (?)
         */
        var rollBackSubmittingDataEntries = function () {
            var log = $log.get("BatchService#rollback");
            log.debug("executing rollback");
            var nonPendingEntries = [];
            while (rollbackContext.submittingEntries.length > 0) {
                // evicting entries from internal state
                const entry = rollbackContext.submittingEntries.shift();
                if (!entry) continue;
                // mark as not pending
                entry.pending = false;
                // pushing to this function scoped state
                nonPendingEntries.push(entry);
            }
            swdbDAO.bulkSave(nonPendingEntries)
                .then(function (entries) {
                    logIdsIfEnabled(log, "debug", entries, "DataEntries {0} rolledback successfully");
                }).catch(function (error) {
                    logIdsIfEnabled(log, "warn", nonPendingEntries, "Failed to rollback DataEntries {0} due to " + error);
                    // (?) addToRollbackContext(nonPendingEntries); (?)
                });
        };

        /**
         * Empties the rollbackcontext.
         * 
         * (?) Maybe do a per-entry eviction: only remove those passed as arguments. 
         * Useful if we decide to maintain the entries in the context if their rollback fail (?)
         */
        var evictRollBackContext = function () {
            rollbackContext.submittingEntries = [];
        };

        //#endregion

        function generateDatamapDiff(batchItem) {
            if (batchItem.operation) {
                return batchItem.operation.datamap;
            }
            const datamap = batchItem.dataentry.datamap; //TODO: implement the diff, passing also the ID + siteid all the time
            return datamap;
        };

        //#region Post-Batch Handlers
        var postBatchHandlers = [];

        /**
         * Adds a handler callback to be executed before a Batch submit request.
         * The callback function receives the just created Batch, the request parameters and the request payload 
         * as arguments in this order.
         * The callback should return either the payload received as argument (possibly modified by it) 
         * or a promise that resolves with it to continue the callback chain.
         * The payload received by the next callback in the chain will be the payload generated by the previous one.
         * 
         * @param function handler 
         */
        function onBeforeBatchSubmit(handler) {
            postBatchHandlers.push(handler);
        }

        /**
         * Executes the callbacks in a promise chain in a way similar to a 
         * 'chain-of-responsability' pattern.
         * Made a small jsfiddle to quickly test it: http://jsfiddle.net/dEkgK/8/
         * 
         * @param Batch batch 
         * @param {} params 
         * @param {} payload 
         * @returns Promise resolved with payload updated by the handlers 
         */
        function executePostBatchHandlers(batch, params, payload) {
            if (postBatchHandlers.length <= 0) return $q.when(payload);
            var promise = null;
            var payloadToUse = angular.copy(payload);
            // sequentially promise chaining
            angular.forEach(postBatchHandlers, function (handler) {
                if (!promise) {
                    promise = $q.when(handler(batch, params, payloadToUse));
                } else {
                    promise = promise.then(function (result) {
                        payloadToUse = !!result ? result : payloadToUse;
                        return handler(batch, params, payloadToUse);
                    });
                }
            });
            return promise;
        }

        //#endregion

        //#endregion

        //#region Public methods

        function getIdsFromBatch(batch) {
            const items = batch.items;
            const ids = [];
            for (let i = 0; i < items.length; i++) {
                const batchItem = items[i];
                ids.push(batchItem['remoteId']);
            }
            return ids;
        };

        /**
         * Saves a Batch it's children BatchItems and another possible 
         * list of a related entity (such as DataEntry or Problem) in a single transaction.
         * This method requires all parameters to be currently in a persistence "managed" state
         * i.e. they need to be actual entity instances, it won't work with "simple" objects/dictionaries.
         * 
         * @param Batch batch 
         * @param [BatchItem] batchItems (optional) 
         * @param [persistence.Entity] managedEntities (optional)
         * @returns Promise: resolved with the saved batch; rejected with Database error
         */
        function saveBatch(batch, batchItems, managedEntities) {
            var log = $log.getInstance("batchService#saveBatch");
            var deferred = $q.defer();
            persistence.transaction(function (tx) {
                log.debug("executing batching db tx");
                //save managed entities before the batchItems so that their properties are not null for loaded items
                if (managedEntities) swdbDAO.bulkSave(managedEntities, tx);
                if (batchItems) swdbDAO.bulkSave(batchItems, tx);
                swdbDAO.save(batch, tx);
                persistence.flush(tx, function () {
                    batch.items.list(null, function (results) {
                        batch.loadeditems = results;
                        return deferred.resolve(batch);
                    });
                });
            });
            return deferred.promise;
        }

        /**
         * Updates a local Batch entity according to a Batch response from the server.
         * The updates includes: updating related BatchItem's problems, updating related DataEntries's flags
         * and updating status of the Batch and the realted entities. 
         * The method also checks if the remoteBatch is a synchronous/asynchronous response 
         * and takes the correct action flow.
         * 
         * @param Batch batch entity 
         * @param Object remoteBatch Batch response from server 
         * @returns Promise: resolved with the updated Batch. 
         */
        function updateBatch(batch, remoteBatch) {
            const log = $log.get("batchService#updateBatch");
            var returnedBatchStatus = remoteBatch.status;
            batch.status = returnedBatchStatus; // always update status
            var indexedItems = {}; // items indexed by their id
            batch.loadeditems.forEach(function (item) {
                // status update
                item.status = returnedBatchStatus;
                // indexing items
                indexedItems[item.id] = item;
            });
            log.info("Batch response received (id='{0}') with Batch.status = '{1}'".format(remoteBatch.remoteId, returnedBatchStatus));
            // assynchronous case: awaiting to be processed
            if (returnedBatchStatus !== "COMPLETE") {
                // update batch status
                return saveBatch(batch, batch.loadeditems);
            }
            // synchronous case: request already processed
            // has to update with problems and/or success
            const problems = remoteBatch.problems; // indexed by related batchItem.id
            const problemEntities = [];
            for (let itemId in problems) {
                if (!problems.hasOwnProperty(itemId)) continue;
                // instantiate Problem (synchronously actually helps in this case)
                const problem = problems[itemId];
                const problemEntity = new entities.Problem();
                problemEntity.message = problem.message;
                // item pointing to Problem and status update
                const problematicItem = indexedItems[itemId.toUpperCase()]; // uppercasing in case the server camelcased the keys
                problematicItem.problem = problemEntity;
                // add to array
                problemEntities.push(problemEntity);
            }
            const successItems = remoteBatch.successItems;
            angular.forEach(successItems, function (successId) {
                const successItem = indexedItems[successId.toUpperCase()]; // uppercasing in case the server camelcased the keys
                if (successItem.problem) successItem.problem = null; // problem shouldn't be deleted for history purposes
            });
            // update items's DataEntries's flags
            angular.forEach(batch.loadeditems, function (item) {
                item.dataentry.pending = false;
                item.dataentry.isDirty = !!item.problem;
            });
            // save problems, update statuses and flags
            const hasProblems = problemEntities.length;
            batch.hasProblems = hasProblems;
            if (hasProblems > 0) {
                return saveBatch(batch, batch.loadeditems, problemEntities);
            }
            // no problems found: just update statuses and flags
            return saveBatch(batch, batch.loadeditems);
        }

        /**
         * Executes a request to submit a Batch and handles the returned response.
         * 
         * @param Batch batch 
         * @param [Object] items to be sent as payload
         * @returns Promise: resolved with updated Batch; rejected with Http or Database error 
         */
        function doSubmitBatch(batch, items, clientOperationId) {
            var log = $log.getInstance('batchService#doSubmitBatch', ["batch", ["sync"]]);

            return applicationStateService.getServerDeviceData()
                .then(deviceData => {
                    // preparing the request
                    var batchParams = {
                        application: batch.application,
                        remoteId: batch.id,
                        clientOperationId,
                        deviceData,
                        downloadImmediately: batch.forcedownload || false //used for quick sync
                    }

                    var objectToSend = { items: items };
                    // execute all handlers and send the result
                    return executePostBatchHandlers(batch, batchParams, objectToSend)
                        .then(function (result) {
                            const jsonToSend =
                                !!result ? angular.toJson(result) : angular.toJson(objectToSend); // performing the request
                            log.info("Submitting a Batch (id='{0}') to the server.".format(batch.id));
                            return restService.post("Mobile", "SubmitBatch", batchParams, jsonToSend);
                        }).then(function (response) {
                            const returnedBatch = response.data;
                            return updateBatch(batch, returnedBatch);;
                        });;
                });

        };

        function submitBatches(batches, clientOperationId) {
            const log = $log.getInstance('batchService#submitBatches');
            var promises = []; // parallel requests promises
            batches.forEach(function (batch) {
                if (!batch || !batch.loadeditems) {
                    return;
                }
                const items = batch.loadeditems.map(batchItem => {
                    return {
                        datamap: generateDatamapDiff(batchItem),
                        itemId: batchItem.dataentry.remoteId,
                        //local id becomes remote from the server perspective
                        remoteId: batchItem.id,
                        application: batch.application,
                        operation: batchItem.crudoperation,
                        dataentry: batchItem.dataentry.id,
                        additionaldata: {}
                    };
                }); // put the batch submission promise in the array
                promises.push(doSubmitBatch(batch, items, clientOperationId));
            });

            // no batches were submitted: reject it
            if (promises.length <= 0) {
                log.info("no batches submitted");
                return $q.when();
            }

            // joined promises: resolves with array of Batch
            return $q.all(promises)
                .then(function (results) {
                    // entries can be removed from rollbackcontext
                    evictRollBackContext();
                    return results;
                })
                .catch(function (error) {
                    // rollback DataEntries update
                    rollBackSubmittingDataEntries();
                    // still reject the error to communicate it along the promise chain
                    return $q.reject(error);
                });
        };


        /**
         * Creates a batch for all the items marked as a dirty on a given application or for a particular item passed as a parameter
         * @param {} dbapplication 
         * @param {} dataEntryToSync used on quick sync operations
         * @returns {} 
         */
        function createBatch(dbapplication, dataEntryToSync) {
            var applicationName = dbapplication.application;
            const log = $log.getInstance('batchService#createBatch', ["sync", "batch"]);
            const detailSchema = offlineSchemaService.locateSchemaByStereotype(dbapplication, "detail");
            const queryToUse = "isDirty=1 and pending=0 and application='{0}'".format(applicationName);
            const isQuickSync = dataEntryToSync != null;
            let promiseToUse;
            if (isQuickSync) {
                promiseToUse = $q.when([dataEntryToSync]);
            } else {
                promiseToUse = swdbDAO.findByQuery('DataEntry', queryToUse);
            }
            return promiseToUse
                .then(dataEntries => attachmentDataSynchronizationService.mergeAttachmentData(applicationName, dataEntries))
                .then(dataEntries => {

                    if (!dataEntries || dataEntries.length <= 0) {
                        log.debug("no items to submit to the server. returning null batch");
                        return null;
                    }

                    var batchItemPromises = [];

                    angular.forEach(dataEntries, function (entry) {
                        // execute per application registered pre-sync service
                        const mobilePresyncserviceName = dbapplication.data.parameters["mobile.presyncservice"];
                        if (!!mobilePresyncserviceName) {
                            dispatcherService.invokeServiceByString(mobilePresyncserviceName, [entry.datamap, entry.originaldatamap]);
                        }

                        // if batch submission fails, remember to rollback this state (otherwise dataentry will be in limbo)
                        entry.pending = true;
                        addToRollbackContext(entry);

                        batchItemPromises.push(swdbDAO.instantiate('BatchItem', entry, function (dataEntry, batchItem) {
                            batchItem.dataentry = dataEntry;
                            batchItem.status = 'pending';
                            batchItem.label = schemaService.getTitle(detailSchema, dataEntry.datamap, true);
                            batchItem.crudoperation = operationService.getCrudOperation(dataEntry, detailSchema);
                            return batchItem;
                        }));
                    });
                    var dbPromises = [];
                    log.debug('creating db promises');
                    var batchPromise = swdbDAO.instantiate('Batch');
                    dbPromises.push(batchPromise);
                    dbPromises.push($q.when(dataEntries));
                    dbPromises = dbPromises.concat(batchItemPromises);
                    return $q.all(dbPromises);
                }).then(function (items) {
                    if (!items) {
                        return items;
                    }
                    const batch = items[0];
                    const dataEntries = items[1];
                    const batchItemsToCreate = items.subarray(2, length + 1);
                    batch.application = applicationName;
                    batch.sentDate = new Date();

                    for (let i = 0; i < batchItemsToCreate.length; i++) {
                        //creating relationships
                        const item = batchItemsToCreate[i];
                        batch.items.add(item);
                        item.batch = batch;
                    }
                    return saveBatch(batch, batchItemsToCreate, dataEntries);
                });
        }

        //#endregion

        //#region Service instance
        const api = {
            getIdsFromBatch,
            submitBatches,
            generateDatamapDiff,
            createBatch,
            saveBatch,
            updateBatch,
            onBeforeBatchSubmit
        };
        return api;

        //#endregion
    };



})(mobileServices, angular, persistence);





;
(function (mobileServices, angular, _) {
    "use strict";

    //private functions
    let userDataIfChanged, invokeCustomServicePromise, buildIdsString, errorHandlePromise, entities;

    class dataSynchronizationService {



        constructor($http, $q, $log, swdbDAO, dispatcherService, offlineRestService, metadataModelService, rowstampService, offlineCompositionService, offlineEntities, searchIndexService, securityService, applicationStateService, configurationService, settingsService) {
            this.$http = $http;
            this.$q = $q;
            this.$log = $log;
            this.swdbDAO = swdbDAO;
            this.dispatcherService = dispatcherService;
            this.restService = offlineRestService;
            this.metadataModelService = metadataModelService;
            this.rowstampService = rowstampService;
            this.offlineCompositionService = offlineCompositionService;

            this.searchIndexService = searchIndexService;
            this.securityService = securityService;
            this.applicationStateService = applicationStateService;
            this.configurationService = configurationService;
            this.settingsService = settingsService;

            entities = offlineEntities;


            userDataIfChanged = function () {
                const current = securityService.currentFullUser();
                if (!current) {
                    return securityService.logout();
                }
                return current.meta && current.meta.changed ? current : null;
            };

            invokeCustomServicePromise = (result, queryArray) => {
                return $q.when(dispatcherService.invokeService(`${result.data.clientName}.dataSynchronizationHook`, 'modifyQueries', [result.data, queryArray])).then(() => queryArray);
            }


            buildIdsString = function (deletedRecordIds) {
                var ids = [];
                angular.forEach(deletedRecordIds, function (id) {
                    ids.push("'{0}'".format(id));
                });
                return ids;
            };

            errorHandlePromise = function (error) {
                if (!error) {
                    return $q.when();
                }
                return $q.reject(error);
            };




        }

        /**
         * 
         * @param {*} firstInLoop 
         * @param {*} app null if this is a full sync, or a specific application for a quick sync
         * @param {*} currentApps the list of all available applications
         * @param {*} compositionMap a map of all compositions rowstamps, to
         * @param {*} clientOperationId for auditing the operation at server side
         */
        createAppSyncPromise(firstInLoop, app, currentApps, compositionMap, clientOperationId) {
            var log = this.$log.get("dataSynchronizationService#createAppSyncPromise");

            const resultHandlePromise = this.resultHandlePromise.bind(this);
            const that = this;

            return this.applicationStateService.getServerDeviceData()
                .then(deviceData => {
                    return that.rowstampService.generateRowstampMap(app)
                        .then(rowstampMap => {
                            return { deviceData, rowstampMap }
                        });
                }).then(({ rowstampMap, deviceData }) => {
                    //see samplerequest.json
                    rowstampMap.compositionmap = compositionMap;
                    log.debug("invoking service to get new data");
                    const payload = {
                        applicationName: app,
                        clientCurrentTopLevelApps: currentApps,
                        returnNewApps: firstInLoop,
                        clientOperationId,
                        userData: userDataIfChanged(),
                        rowstampMap,
                        deviceData
                    };
                    return that.restService.post("Mobile", "PullNewData", null, payload);
                })
                .then(resultHandlePromise);
        }



        /**
         *  Returns an object (promise) containing the query array to run and the number of downloads (which excludes the compositions count)
         * 
         * 
         * @param {*} result coming from MobileController#PullNewData 
         */
        generateQueriesPromise(result) {
            const data = result.data;
            const log = this.$log.get("dataSynchronizationService#generateQueries", ["sync"]);

            const topApplicationData = data.topApplicationData;
            const compositionData = data.compositionData;

            const userProperties = data.userProperties;
            const fullUser = this.securityService.currentFullUser();

            const currentFacilities = (fullUser && fullUser.properties && fullUser.properties["sync.facilities"]) || [];
            const serverFacilities = (userProperties && userProperties["sync.facilities"]) || [];
            const facilityChanges = data.facilitiesUpdated || !_.isEqual(currentFacilities.sort(), serverFacilities.sort());
            this.configurationService.getFullConfig(ConfigurationKeys.FacilitiesChanged).then(config => {
                const save = config === null || (config && config.value === false && facilityChanges);
                if (save) {
                    this.configurationService.saveConfig({ key: ConfigurationKeys.FacilitiesChanged, value: facilityChanges });
                }
            });

            this.securityService.overrideCurrentUserProperties(userProperties);

            //do not modify to const as this array is modified internally to append compositions and custom entries
            let queryArray = [];

            if (data.isEmpty) {
                log.info("no new data returned from the server");
                return invokeCustomServicePromise(result, queryArray).then(queryArray => {
                    //interrupting async calls
                    const numberOfDownloadedItems= 0;
                    return { queryArray, numberOfDownloadedItems };
                })

            }

            log.info("receiving new topLevel data from the server");

            angular.forEach(topApplicationData, application => {
                //multiple applications can be returned on a limit scenario where itÂ´s the first sync, or on a server update.
                const newDataMaps = application.newdataMaps;
                const updatedDataMaps = application.updatedDataMaps;
                const insertUpdateDatamap = application.insertOrUpdateDataMaps;
                const deletedIds = application.deletedRecordIds;
                log.debug("{0} topleveldata: inserting:{1} | updating:{2} | deleting: {3}".format(application.applicationName, newDataMaps.length, updatedDataMaps.length, deletedIds.length));

                angular.forEach(newDataMaps, newDataMap => {
                    const id = persistence.createUUID();

                    const newJson = newDataMap.jsonFields || JSON.stringify(newDataMap); //keeping backwards compatibility //newJson = datamapSanitizationService.sanitize(newJson);
                    const datamap = newDataMap.jsonFields ? JSON.parse(newDataMap.jsonFields) : newDataMap; //keeping backwards compatibility //newJson = datamapSanitizationService.sanitize(newJson);

                    const idx = newDataMap.indexData || this.searchIndexService.buildIndexes(application.textIndexes, application.numericIndexes, application.dateIndexes, datamap);
                    const insertQuery = { query: entities.DataEntry.insertOrReplacePattern, args: [newDataMap.application, newJson, newDataMap.id, String(newDataMap.approwstamp), id, idx.t1, idx.t2, idx.t3, idx.t4, idx.t5, idx.n1, idx.n2, idx.d1, idx.d2, idx.d3] };
                    queryArray.push(insertQuery);
                });

                angular.forEach(insertUpdateDatamap, insertOrUpdateDatamap => {
                    const id = persistence.createUUID();

                    const newJson = insertOrUpdateDatamap.jsonFields || JSON.stringify(insertOrUpdateDatamap); //keeping backwards compatibility //newJson = datamapSanitizationService.sanitize(newJson);
                    const datamap = insertOrUpdateDatamap.jsonFields ? JSON.parse(insertOrUpdateDatamap.jsonFields) : insertOrUpdateDatamap; //keeping backwards compatibility //newJson = datamapSanitizationService.sanitize(newJson);

                    const idx = insertOrUpdateDatamap.indexData || this.searchIndexService.buildIndexes(application.textIndexes, application.numericIndexes, application.dateIndexes, datamap);
                    const insertOrUpdateQuery = { query: entities.DataEntry.insertOrReplacePattern, args: [insertOrUpdateDatamap.application, newJson, insertOrUpdateDatamap.id, String(insertOrUpdateDatamap.approwstamp), id, idx.t1, idx.t2, idx.t3, idx.t4, idx.t5, idx.n1, idx.n2, idx.d1, idx.d2, idx.d3] };
                    queryArray.push(insertOrUpdateQuery);
                });

                angular.forEach(updatedDataMaps, updateDataMap => {
                    const updateJson = updateDataMap.jsonFields || JSON.stringify(updateDataMap); // keeping backward compatibility //updateJson = datamapSanitizationService.sanitize(updateJson);
                    const datamap = updateDataMap.jsonFields ? JSON.parse(updateDataMap.jsonFields) : updateDataMap; //keeping backwards compatibility //newJson = datamapSanitizationService.sanitize(newJson);

                    const idx = updateDataMap.indexData || this.searchIndexService.buildIndexes(application.textIndexes, application.numericIndexes, application.dateIndexes, datamap);
                    const updateQuery = { query: entities.DataEntry.updateQueryPattern, args: [updateJson, String(updateDataMap.approwstamp), idx.t1, idx.t2, idx.t3, idx.t4, idx.t5, idx.n1, idx.n2, idx.d1, idx.d2, idx.d3, updateDataMap.id, updateDataMap.application] };
                    queryArray.push(updateQuery);
                });

                if (deletedIds.length > 0) {
                    const fnName = isRippleEmulator() ? "push" : "unshift";
                    const deleteQuery = { query: entities.DataEntry.deleteQueryPattern.format(buildIdsString(deletedIds), application.applicationName) };
                    queryArray[fnName](deleteQuery);
                    //TODO: treat the case where AuditEntries that have no refId shouldn't be deleted (e.g. crud_create operations)
                    const deleteAuditQuery = {
                        query: entities.AuditEntry.deleteRelatedByRefIdStatement.format(buildIdsString(deletedIds)),
                        args: [application.apllicationName]
                    };
                    queryArray[fnName](deleteAuditQuery);
                }
            });

            //test
            // ignoring composition number to SyncOperation table
            const numberOfDownloadedItems = queryArray.length;

            return this.offlineCompositionService.generateSyncQueryArrays(compositionData)
                .then(compositionQueriesToAppend => queryArray.concat(compositionQueriesToAppend))
                .then((queryArray) => {
                    return invokeCustomServicePromise(result, queryArray);
                }).then(queryArray => {
                    return { queryArray, numberOfDownloadedItems };
                })

        }


        resultHandlePromise(result) {

            return this.generateQueriesPromise(result).then(result => {
                return this.swdbDAO.executeQueries(result.queryArray).then(() => {
                    return result.numberOfDownloadedItems;
                })
            });
        }

        /**
         *  Main sync operation, receives a clientOperationId for storing an audit entry at server side.
         * 
         *  
         * 
         * @param {String} clientOperationId for storing an offline audit entry at server side
         */
        syncData(clientOperationId) {


            const resultHandlePromise = this.resultHandlePromise.bind(this);
            const createAppSyncPromise = this.createAppSyncPromise.bind(this);
            const that = this;

            return this.applicationStateService.getServerDeviceData()
                .then(deviceData => {
                    var currentApps = this.metadataModelService.getApplicationNames();
                    const firstTime = currentApps.length === 0;
                    var payload;
                    if (firstTime) {
                        //upon first synchronization let's just bring them all, since we donÂ´t even know what are the metadatas
                        payload = {
                            clientCurrentTopLevelApps: currentApps,
                            returnNewApps: true,
                            clientOperationId,
                            deviceData,
                            userData: userDataIfChanged()
                        };
                        //single server call
                        return that.restService.post("Mobile", "PullNewData", null, payload)
                            .then(resultHandlePromise)
                            .catch(errorHandlePromise);
                    }
                    return that.rowstampService.generateCompositionRowstampMap()
                        .then(function (compositionMap) {
                            const httpPromises = [];
                            const promise = createAppSyncPromise(true, null, currentApps, compositionMap, clientOperationId).catch(errorHandlePromise);
                            httpPromises.push(promise);

                            return that.$q.all(httpPromises);
                        });
                });


        }

        syncSingleItem(item, clientOperationId) {
            const app = item.application;
            const resultHandlePromise = this.resultHandlePromise.bind(this);

            return this.applicationStateService.getServerDeviceData().then(deviceData => {
                return this.rowstampService.generateCompositionRowstampMap().then(compositionMap => {
                    const rowstampMap = {
                        compositionmap: compositionMap
                    }
                    const payload = {
                        applicationName: app,
                        itemsToDownload: [item.remoteId],
                        userData: userDataIfChanged(),
                        rowstampMap,
                        deviceData,
                        clientOperationId
                    };
                    var promise = this.restService.post("Mobile", "PullNewData", null, payload).then(resultHandlePromise)
                        .catch(errorHandlePromise);
                    return this.$q.all([promise]);
                });
            });
        }

    }

    dataSynchronizationService.$inject = ["$http", "$q", "$log", "swdbDAO", "dispatcherService", "offlineRestService", "metadataModelService", "rowstampService", "offlineCompositionService", "offlineEntities", "searchIndexService", "securityService", "applicationStateService", "configurationService", "settingsService"];

    mobileServices.service('dataSynchronizationService', dataSynchronizationService);

})(mobileServices, angular, _);
;
(function (mobileServices) {
    "use strict";

    mobileServices.factory("metadataSynchronizationService",
        ["$q", "offlineRestService", "menuModelService", "metadataModelService", "configurationService", "offlineCommandService", "securityService","searchIndexService","applicationStateService",
            function ($q, restService, menuModelService, metadataModelService, configurationService, offlineCommandService, securityService, searchIndexService, applicationStateService) {

    var toConfigurationArray = function (configuration) {
        const configArray = Object.keys(configuration).map(k => ({ key: k, value: configuration[k] }));
        return configArray;
    };

    return {
        syncData: function (currentServerVersion, clientOperationId) {

            return applicationStateService.getServerDeviceData()
                .then(deviceData => {
                    return restService.post("Mobile", "DownloadMetadatas",null, { clientOperationId, deviceData });
                }).then(metadatasResult => {

                searchIndexService.refreshIndexCaches();

                const serverMenu = JSON.parse(metadatasResult.data.menuJson);
                const topLevelMetadatas = JSON.parse(metadatasResult.data.topLevelMetadatasJson);
                const associationMetadatasJson = JSON.parse(metadatasResult.data.associationMetadatasJson);
                const compositionMetadatasJson = JSON.parse(metadatasResult.data.compositionMetadatasJson);
                const commandBars = JSON.parse(metadatasResult.data.commandBarsJson);
                const config = metadatasResult.data.appConfiguration;

                const menuPromise = menuModelService.updateMenu(serverMenu);
                const topLevelPromise = metadataModelService.updateTopLevelMetadata(topLevelMetadatas);
                const associationPromise = metadataModelService.updateAssociationMetadata(associationMetadatasJson);
                const compositionPromise = metadataModelService.updateCompositionMetadata(compositionMetadatasJson);
                const commandBarsPromise = offlineCommandService.updateCommandBars(commandBars);

                const configArray = toConfigurationArray(config);
                const configServicePromise = configurationService.saveConfigs(configArray);

                return $q.all([menuPromise, topLevelPromise, associationPromise, compositionPromise, commandBarsPromise, configServicePromise]);

            }).then(function (results) {
                //TODO: return whether changes where downloaded or not
                return true;
            });
        }
    }
}]);

})(mobileServices);
;
(function (mobileServices) {
    "use strict";

    function notificationPluginWrapper($window, $rootScope, $timeout) {

        /**
         * Register's ngCordova's notification event listeners.
         * Has to be called within "$ionicPlatform.ready" callback.
         * Hack: the plugin isn't ready at the time the listeners are originally bound by ngCordova and, 
         * since ngCordova doesn't expose their binding to be called externally, it is required to be manually called.
         */
        var init = function() {
            // ----- "Scheduling" events

            // A local notification was scheduled
            $window.cordova.plugins.notification.local.on("schedule", function (notification, state) {
                $timeout(function () {
                    $rootScope.$broadcast("$cordovaLocalNotification:schedule", notification, state);
                });
            });

            // A local notification was triggered
            $window.cordova.plugins.notification.local.on("trigger", function (notification, state) {
                $timeout(function () {
                    $rootScope.$broadcast("$cordovaLocalNotification:trigger", notification, state);
                });
            });

            // ----- "Update" events

            // A local notification was updated
            $window.cordova.plugins.notification.local.on("update", function (notification, state) {
                $timeout(function () {
                    $rootScope.$broadcast("$cordovaLocalNotification:update", notification, state);
                });
            });

            // ----- "Clear" events

            // A local notification was cleared from the notification center
            $window.cordova.plugins.notification.local.on("clear", function (notification, state) {
                $timeout(function () {
                    $rootScope.$broadcast("$cordovaLocalNotification:clear", notification, state);
                });
            });

            // All local notifications were cleared from the notification center
            $window.cordova.plugins.notification.local.on("clearall", function (state) {
                $timeout(function () {
                    $rootScope.$broadcast("$cordovaLocalNotification:clearall", state);
                });
            });

            // ----- "Cancel" events

            // A local notification was cancelled
            $window.cordova.plugins.notification.local.on("cancel", function (notification, state) {
                $timeout(function () {
                    $rootScope.$broadcast("$cordovaLocalNotification:cancel", notification, state);
                });
            });

            // All local notifications were cancelled
            $window.cordova.plugins.notification.local.on("cancelall", function (state) {
                $timeout(function () {
                    $rootScope.$broadcast("$cordovaLocalNotification:cancelall", state);
                });
            });

            // ----- Other events

            // A local notification was clicked
            $window.cordova.plugins.notification.local.on("click", function (notification, state) {
                $timeout(function () {
                    $rootScope.$broadcast("$cordovaLocalNotification:click", notification, state);
                });
            });
        }

        var service = {
            init: init
        };

        return service;
    }

    mobileServices.factory("notificationPluginWrapper", ["$window", "$rootScope", "$timeout", notificationPluginWrapper]);

})(mobileServices);
;
(function (mobileServices) {
    "use strict";

    mobileServices.constant("rowstampConstants", {
        //above this limit framework shall no longer produce the full rowstamp map, but rather just pass the maxrowstamp to the server
        maxItemsForFullStrategy: 1000
    });

    mobileServices.factory('rowstampService', ["$q", "$log", "swdbDAO", "offlineEntities", "rowstampConstants", function ($q, $log, swdbDAO, offlineEntities, rowstampConstants) {
        var entities = offlineEntities;

        return {

            generateRowstampMap: function (application) {
                var log = $log.get("rowstampService#generateRowstampMap");
                var start = new Date().getTime();
                
                var applicationQuery = !application  ? "1=1" : "application ='{0}'".format(application);
                //https://controltechnologysolutions.atlassian.net/browse/SWOFF-140
                var shouldUseFullStrategy = true;
                return swdbDAO.countByQuery("DataEntry", applicationQuery)
                    .then(function (result) {

                        shouldUseFullStrategy = result < rowstampConstants.maxItemsForFullStrategy;
                        //for small datasets we sall bring it all
                        if (!shouldUseFullStrategy) {
                            if (!application) {
                                return swdbDAO.findByQuery('DataEntry', null, { fullquery: entities.DataEntry.maxRowstampGeneralQuery });
                            }

                            return swdbDAO.findByQuery('DataEntry', null, { fullquery: entities.DataEntry.maxRowstampByAppQuery.format(application) });
                        }
                        return swdbDAO.findByQuery("DataEntry", applicationQuery, { projectionFields: ["application","remoteId", "rowstamp"] });
                    }).then(function (queryResults) {
                        const rowstampMap = {};
                        if (shouldUseFullStrategy) {
                            //small dataset scenario
                            if (application != null) {
                                const resultItems = queryResults.map(function(item) {
                                    return {
                                        id: item.remoteId,
                                        rowstamp: item.rowstamp
                                    }
                                });
                                rowstampMap.items = resultItems;
                                const end = new Date().getTime();
                                log.debug("generated rowstampmap for application {0} with {1} entries. Ellapsed {2} ms"
                                    .format(application, resultItems.length, (end - start)));
                                return rowstampMap;
                            } else {
                                const applications = {};
                                for (let i = 0; i < queryResults.length; i++) {
                                    var item = queryResults[i];
                                    if (!applications[item.application]) {
                                        applications[item.application] = {};
                                    }
                                    if (!applications[item.application].items) {
                                        applications[item.application].items = [];
                                    }
                                    applications[item.application].items.push({
                                        id: item.remoteId,
                                        rowstamp: item.rowstamp
                                    });
                                }
                                rowstampMap.applications = applications;
                                return rowstampMap;
                            }
                        } else {
                            if (application != null) {
                                rowstampMap.maxrowstamp = queryResults[0].rowstamp;
                                rowstampMap.application = application;
                            } else {
                                rowstampMap.applications = {};
                                for (let i = 0; i < queryResults.length; i++) {
                                    var res = queryResults[i];
                                    rowstampMap.applications[[res.application]] = res.rowstamp;
                                }
                            }

                            
                            return rowstampMap;
                        }
                    });
            },

            generateCompositionRowstampMap: function () {
                var log = $log.get("rowstampService#generateCompositionRowstampMap");
                var deferred = $q.defer();
                var start = new Date().getTime();
                swdbDAO.findByQuery('CompositionDataEntry', null, { fullquery: entities.CompositionDataEntry.maxRowstampQueries })
                    .then(function (queryResults) {
                        const resultItems = {};
                        for (let i = 0; i < queryResults.length; i++) {
                            const item = queryResults[i];
                            resultItems[item.application] = item.rowstamp;
                        }
                        const end = new Date().getTime();
                        log.debug("generated rowstampmap for compositions. Ellapsed {0} ms".format(end - start));
                        deferred.resolve(resultItems);
                    });
                return deferred.promise;
            },

            generateAssociationRowstampMap: function (apps, initialLoad) {
                var log = $log.get("rowstampService#generateAssociationRowstampMap", ["sync","association"]);
                var deferred = $q.defer();
                var start = new Date().getTime();
                //either for query for a single app, or for all of them
                //TODO: use AssociationCache in the future
                var formattedApps = null;
                const hasApps = !!apps && apps.length > 0;

                if (hasApps) {
                    formattedApps = "'" + apps.join("','") + "'";
                }
                let query;
                if (initialLoad) {
                    query = hasApps ? entities.AssociationData.maxRemoteIdQueryByApps.format(formattedApps) : entities.AssociationData.maxRemoteIdQueries;    
                } else {
                    query = hasApps ? entities.AssociationData.maxRowstampQueryByApps.format(formattedApps) : entities.AssociationData.maxRowstampQueries;    
                }

                
                swdbDAO.findByQuery('AssociationData', null, { fullquery: query })
                    .then(function (queryResults) {
                        const result = {};
                        const associationmap = {};
                        for (let i = 0; i < queryResults.length; i++) {
                            const item = queryResults[i];
                            if (initialLoad) {
                                associationmap[item.application] = { "maximouid": item.remoteid }
                            } else {
                                associationmap[item.application] = { "maximorowstamp": item.rowstamp }
                            }
                            
                        }
                        const end = new Date().getTime();
                        log.debug("generated rowstampmap for associations. Ellapsed {0} ms".format(end - start));
                        result.associationmap = associationmap;
                        deferred.resolve(result);
                    });
                return deferred.promise;
            }



        }
    }]);

})(mobileServices);;
(function (mobileServices) {
    "use strict";

    class scriptsSynchronizationService {

        constructor(restService, $q,$log, localStorageService, dynamicScriptsCacheService, $cordovaAppVersion) {
            this.restService = restService;
            this.$q = $q;
            this.$log = $log;
            this.localStorageService = localStorageService;
            this.dynamicScriptsCacheService = dynamicScriptsCacheService;
            this.$cordovaAppVersion = $cordovaAppVersion;
        }

        syncData() {

            const clientState = this.dynamicScriptsCacheService.getClientState();

            const clientVersionPromise = isRippleEmulator() ? this.$q.when("ripple") : this.$cordovaAppVersion.getVersionNumber();
            const offlineDevice = ionic.Platform.isAndroid() ? "android" : "ios";

            return clientVersionPromise.then(offlineVersion => {
                const data = {
                    clientState,
                    offlineDevice,
                    offlineVersion
                };
                return this.restService.post("Mobile", "BuildSyncMap", {}, data);
            }).then(scriptsResult => {
                return this.dynamicScriptsCacheService.syncWithServerSideScripts(scriptsResult.data);
            }).catch (err => {
                this.$log.warn("[dynamic-scripts]incompatible server side version");
                return this.$q.when();
            });
        }

    }

    scriptsSynchronizationService.$inject = ["offlineRestService", "$q","$log", "localStorageService", "dynamicScriptsCacheService", "$cordovaAppVersion"];


    mobileServices.service("scriptsSynchronizationService", scriptsSynchronizationService);


})(mobileServices);;
(function (mobileServices, angular, _) {
    "use strict";

    function synchronizationFacade($log, $q, $rootScope, $timeout, dataSynchronizationService, metadataSynchronizationService, scriptsSynchronizationService, associationDataSynchronizationService, batchService, metadataModelService, synchronizationOperationService, laborService,
        asyncSynchronizationService, synchronizationNotificationService, offlineAuditService, dao, loadingService, $ionicPopup, crudConstants, entities, problemService, tracking, menuModelService, networkConnectionService, restService, securityService, configurationService) {

        //#region Utils

        function getDownloadDataCount(dataDownloadResult) {
            let count = 0;
            angular.forEach(dataDownloadResult, result => {
                if (!angular.isArray(result)) {
                    count += result;
                    return;
                }
                // in some cases, each result is an array of numbers
                // in that case we need to iterate through each number of result
                angular.forEach(result, element => count += element);
            });
            return count;
        }

        /**
         * Deletes the 'deletable' DataEntries related to the batches.
         * A 'deletable' DataEntry is one which's related BatchItem: 
         * - has a crudoperation === crudConstants.operation.create
         * - has no problem associated with it
         * 
         * @param [Batch] batches 
         * @returns Promise resolved with the batches, rejected with database error 
         */
        function handleDeletableDataEntries(batches) {
            const statements = _.chain(batches)
                .pluck("loadeditems") // [[BatchItem]]
                .flatten() // [BatchItem]
                .filter(item => item.crudoperation === crudConstants.operation.create && !item.problem) // [BatchItem] crud_create and doesn't have problem  
                .pluck("dataentry") // [DataEntry]
                .groupBy("application") // { DataEntry['application'] : [DataEntry] }
                .map((entries, application) => {
                    // for some reason this query only works if there are no '' around the ids
                    var ids = _.pluck(entries, "id");


                    return { query: entities.DataEntry.deleteInIdsStatement.format(buildIdsString(ids)), args: [application] };
                }) // [PreparedStatement]
                .value();

            // nothing to delete: resolve with batches immediately
            if (statements.length <= 0) return $q.when(batches);
            // resolve with batches if delete wass successful
            return dao.executeQueries(statements).then(() => batches);
        }

        /**
         * Updates the Batches, deletes DataEntries that should be deleted 
         * and creates a SyncOperation.
         * 
         * @param Object completionResult 
         */
        function onBatchesCompleted(completionResult) {
            const log = $log.get("dataSynchronizationService#onBatchesCompleted");
            const start = completionResult.start;
            const batchTuples = completionResult.batchTuples;
            const promises = _.map(batchTuples, tuple => {
                const remoteBatch = tuple.remote;
                const batch = tuple.local;
                return batchService.updateBatch(batch, remoteBatch);
            });
            $q.all(promises)
                .then(batches => handleDeletableDataEntries(batches))
                .then(batches => problemService.updateHasProblemToDataEntries(batches))
                // update the related syncoperations as 'COMPLETE'
                // TODO: assuming there's only a single batch/application per syncoperation -> develop generic case
                .then(batches => synchronizationOperationService.completeFromAsyncBatch(batches)
                    // resolve with the saved batches to transparently continue the promise 
                    // chain as it was before (not aware of syncoperations update)
                    .then(operations => batches))
                .then(batches =>
                    $q.all([dataSynchronizationService.syncData(), associationDataSynchronizationService.syncData(false, null)])
                        .then(downloadResults => {
                            var dataCount = getDownloadDataCount(downloadResults[0]);
                            return synchronizationOperationService.createSynchronousBatchOperation(start, null, dataCount, batches);
                        })
                )
                .then(operation => {
                    log.info("created SyncOperation for async Batch Processing");
                    synchronizationNotificationService.notifySynchronizationReceived(operation);
                })
                .catch(error => log.error(error));
        }

        /**
         * For each item in the payload adds the related AuditEntries in their 'additionaldata' field.
         * 
         * @returns Promise resolved with the updated payload
         */
        function onBeforeBatchSubmit(batch, params, payload) {
            const promises = payload.items.map(item =>
                offlineAuditService.getEntriesForEntity(item.dataentry, batch.application).then(entries => {
                    item.additionaldata.auditentries = entries;
                    return item;
                }));
            return $q.all(promises).then(items => {
                // substitute payload's items by items with auditentries
                payload.items = items;
                return payload;
            });
        }

        //#endregion

        //#region Public methods

        function hasDataToSync() {
            return dao.countByQuery("DataEntry", "isDirty=1 and pending=0").then(count => count > 0);
        }

        /**
         * Executes a full download (data, metadata and association data) and creates a SyncOperation
         * reflecting the execution.
         * 
         * @returns Promise: resolved with created SyncOperation; rejected with HTTP or Database error 
         */
        function fullDownload(clientOperationId = persistence.createUUID()) {
            if (networkConnectionService.isOffline()) {
                return $q.reject({ message: "Cannot synchronize application without internet connection" });
            }
            const log = $log.get("synchronizationFacade#fullDownload");
            log.info("Executing full download");
            const start = new Date().getTime();

            const currentApps = metadataModelService.getApplicationNames();
            const firstTime = currentApps.length === 0;

            //            const clientOperationId = persistence.createUUID();

            const httpPromises = [
                metadataSynchronizationService.syncData("1.0", clientOperationId),
                scriptsSynchronizationService.syncData(),
                associationDataSynchronizationService.syncData(firstTime, clientOperationId)
            ].concat(dataSynchronizationService.syncData(clientOperationId));

            return $q.all(httpPromises)
                .then(results => {
                    const end = new Date().getTime();
                    log.info("finished full download process. Ellapsed {0}".format(end - start));

                    const metadataDownloadedResult = results[0];
                    const associationDataDownloaded = results[2];
                    const dataDownloadedResult = results.subarray(3);
                    const totalNumber = getDownloadDataCount(dataDownloadedResult);

                    return synchronizationOperationService.createNonBatchOperation(start, clientOperationId, end, totalNumber, associationDataDownloaded, metadataDownloadedResult);
                });
        }

        function checkRelogin() {
            return restService.get("Mobile", "PingAuth", {}, { headers: { ignorefailure: true } }).catch((cause) => {
                if (cause.status !== 401) {
                    return $q.reject({ message: "Cannot synchronize application, failed to reach server." });
                }

                loadingService.hide();

                return $ionicPopup.prompt({
                    title: "Relogin Required",
                    subTitle: "Please reenter password.",
                    inputType: "password",
                    okText: "Login",
                    inputPlaceholder: "Your password"
                }).then((result) => {
                    if (result === undefined) {
                        throw {
                            data: {
                                errorMessage: "Relogin required.",
                                requestSupportReport: false
                            }
                        }
                    }
                    loadingService.showDefault();
                    const user = securityService.currentUser();
                    return securityService.login(user, result, true, true).catch(() => {
                        throw {
                            data: {
                                errorMessage: "Failed to login.",
                                requestSupportReport: false
                            }
                        }
                    });
                });
            });
        }

        function handleError(error) {
            var message = "";
            let requestSupportReport = true;
            let notifyException = true;
            if (!!error && !!error.data) {
                message = error.data.errorMessage;
                requestSupportReport = error.data.requestSupportReport;
                notifyException = error.data.notifyException;
                var e = new Error(message);
                e.title = "Error Synchronizing Data";
                e.requestSupportReport = requestSupportReport;
                e.notifyException = notifyException;
                throw e;
            }

            if (isString(error)){
                error = new Error(error);
            }

            error.title = "Error Synchronizing Data";
            throw error;
        }

        /**
         * Used when facilies were changed and the user needs a full resync to have only the data related to the new facility set.
         */
        function shouldFullResync(considerDirty) {
            const dirtyPromise = considerDirty ? hasDataToSync() : $q.when(false);

            return dirtyPromise.then(hasDirty => {
                if (hasDirty) {
                    return $q.when(false);
                }
                return configurationService.getConfig(ConfigurationKeys.FacilitiesChanged).then(facilitiesChanged => !!facilitiesChanged);
            });
        }


        /**
         * If the user caused a Batches to be created (altering and/or creating new content) then the Batches 
         * will be submitted to the server: If it receives a synchronous response from the server 
         * a data download will be executed.
         * Otherwise (no Batches) a full download (data, metadata and association data) will be executed. 
         * In any case a SyncOperation reflecting the method execution (Batch or Batach+download or full download) will be created.
         * 
         * @returns Promise: resolved with created SyncOperation; rejected with HTTP or Database error
         */
        function fullSync() {
            const log = $log.get("synchronizationFacade#fullSync", ["sync"]);
            log.info("init full synchronization process");
            tracking.trackFullState("synchornizationFacace#fullSync pre-sync");

            if (networkConnectionService.isOffline()) {
                return $q.reject({ message: "Cannot synchronize application without internet connection" });
            }

            let laborPromise;
            // finish labor if there is a labor started and is not the first sync
            if (laborService.hasActiveLabor()) {
                laborPromise = isFirstSync().then(first => {
                    if (!first) {
                        loadingService.hide(); // workaround - was showing load on stop labor prompt
                        return laborService.finishLaborBeforeSynch();
                    } 
                    return $q.when(true);
                });
            } else {
                laborPromise = $q.when(true);
            }

            return laborPromise.then((laborFinished) => {
                if (!laborFinished) {
                    return $q.reject({});
                }

                loadingService.showDefault(); // workaround - was showing load on stop labor prompt

                return checkRelogin().then(() => {
                    const clientOperationId = persistence.createUUID();
                    const start = new Date().getTime();
                    const dbapplications = metadataModelService.getMetadatas();

                    // one Batch per application
                    const batchPromises = dbapplications.map(dbapplication => batchService.createBatch(dbapplication));

                    return $q.all(batchPromises)
                        .then(batches => {
                            // no batches created: full download instead of full sync
                            if (!batches || batches.length <= 0 || !batches.some(s => s != null)) {
                                log.info("No batches created: Executing full download instead of full sync.");
                                return fullDownload(clientOperationId);
                            }
                            // batches created: submit to server
                            log.info("Batches created locally: submitting to server.");
                            return batchService.submitBatches(batches, clientOperationId).then(batchResults => {
                                // check for synchronous or asynchronous case
                                var asyncBatches = batchResults.filter(batch => batch.status !== "COMPLETE");
                                // async case
                                if (asyncBatches.length > 0) {
                                    // register async Batches for async processing
                                    angular.forEach(asyncBatches, asyncBatch => asyncSynchronizationService.registerForAsyncProcessing(asyncBatch));
                                    // create batch/offline SyncOperation
                                    return synchronizationOperationService.createBatchOperation(start, batchResults);
                                }
                                // sync case: 
                                // - delete DataEntries that should be deleted
                                // - updates the hasProblem flag on DataEntries
                                // - download ONLY data and create a SyncOperation indicating both a Batch submission and a download
                                return handleDeletableDataEntries(batchResults)
                                    .then(() => problemService.updateHasProblemToDataEntries(batchResults))
                                    .then(() => {
                                        var httpPromises = [associationDataSynchronizationService.syncData(false, clientOperationId), dataSynchronizationService.syncData(clientOperationId)];
                                        return $q.all(httpPromises);
                                    })
                                    .then(downloadResults => {
                                        log.debug("Batch returned synchronously --> performing download");
                                        var dataCount = getDownloadDataCount(downloadResults[1]);
                                        return synchronizationOperationService.createSynchronousBatchOperation(start, clientOperationId, dataCount, batchResults);
                                    });
                            });
                        })
                        .finally(() => {
                            tracking.trackFullState("synchornizationFacace#fullSync post-sync");
                            menuModelService.updateAppsCount();
                        });
                });
            });
        }

        function syncItem(item) {
            const log = $log.get("synchronizationFacade#syncItem", ["sync"]);
            log.info("init quick sync process");
            tracking.trackFullState("synchornizationFacace#syncItem pre-quicksync");

            const laborPromise = laborService.hasItemActiveLabor(item)
                ? laborService.finishLaborBeforeSynch(item)
                : $q.when(true);

            return laborPromise.then((laborFinished) => {
                if (!laborFinished) {
                    return $q.reject({});
                }

                return checkRelogin().then(() => {
                    const clientOperationId = persistence.createUUID();
                    const dbapplication = metadataModelService.getMetadatas().find(a => a.application === item.application);
                    const start = new Date().getTime();
                    loadingService.showDefault();
                    // one Batch per application
                    return batchService.createBatch(dbapplication, item)
                        .then(batch => batchService.submitBatches([batch], clientOperationId))
                        .then(batchResults => {
                            return handleDeletableDataEntries(batchResults)
                                .then(() => problemService.updateHasProblemToDataEntries(batchResults, item))
                                .then(() => {
                                    var httpPromises = [];
                                    httpPromises.push(associationDataSynchronizationService.syncData(false, clientOperationId));
                                    if (!!item.remoteId) {
                                        httpPromises.push(dataSynchronizationService.syncSingleItem(item, clientOperationId));
                                    } else {
                                        //TODO: return the remoteid on the operation
                                        //for creations since we donÂ´t have the remote id yet
                                        httpPromises.push(dataSynchronizationService.syncData(clientOperationId));
                                    }
                                    return $q.all(httpPromises);
                                })
                                .then(downloadResults => {
                                    var dataCount = getDownloadDataCount(downloadResults[1]);
                                    return synchronizationOperationService.createSynchronousBatchOperation(start, clientOperationId, dataCount, batchResults);
                                }).then(r => {
                                    $rootScope.$broadcast("sw.sync.quicksyncfinished");
                                    return r;
                                });
                        })
                        .finally(() => {
                            loadingService.hide();
                            menuModelService.updateAppsCount();
                            tracking.trackFullState("synchornizationFacace#syncItem post-quicksync");
                        });
                });
            });
        }

        /**
         * Attemps a synchronization.
         * If it succeeds resolve with <code>true</code> indicating sync was successfull.
         * If it fails prompts the user with a confirm popup ("continue anyway?").
         * Resolve with the user's response.
         * Before attempting synchronization show loading; after synchronization (success or fail) loading is toggled off.
         * 
         * @param {} failPopupConfig configuration of the confirm popup. Defaults to {title:"Synchronization failed",template:"Continue anyway?"}
         * @returns Promise resolved with Boolean indicating the caller it can continue it's workflow. 
         */
        function attempSyncAndContinue(failPopupConfig) {
            loadingService.showDefault();

            // try to sync
            return fullSync()
                .then(() => {
                    loadingService.hide();
                    return true;
                })
                .catch(() => {
                    loadingService.hide();
                    // sync failed: check if user wishes to logout regardless
                    return $ionicPopup.confirm({
                        title: failPopupConfig.title || "Synchronization Failed",
                        template: failPopupConfig.template || "Continue Anyway?"
                    })
                        .then(continueAnyway => !!continueAnyway);
                });
        }

        function isFirstSync() {
            if (menuModelService.getMenuItems().length > 0) {
                return $q.when(false);
            }
            return dao.countByQuery("Menu", "data is not null").then(r => {
                return r === 0;
            });
        }

        //#endregion

        //#region Service instance

        // registering batch submit callback on batchService
        batchService.onBeforeBatchSubmit(onBeforeBatchSubmit);
        // registering completion callback on the asyncSynchronizationService
        asyncSynchronizationService.onBatchesCompleted(onBatchesCompleted);



        const api = {
            hasDataToSync,
            fullDownload,
            fullSync,
            syncItem,
            attempSyncAndContinue,
            handleDeletableDataEntries,
            isFirstSync,
            handleError,
            shouldFullResync
        };
        return api;
        //#endregion
    }

    //#region Service registration
    mobileServices.factory("synchronizationFacade", ["$log", "$q", "$rootScope", "$timeout", "dataSynchronizationService", "metadataSynchronizationService", "scriptsSynchronizationService", "associationDataSynchronizationService", "batchService",
        "metadataModelService", "synchronizationOperationService", "laborService", "asyncSynchronizationService", "synchronizationNotificationService", "offlineAuditService", "swdbDAO", "loadingService", "$ionicPopup", "crudConstants", "offlineEntities", "problemService", "trackingService", "menuModelService", "networkConnectionService", "offlineRestService", "securityService", "configurationService", synchronizationFacade]);
    //#endregion

})(mobileServices, angular, _);;
(function (mobileServices, angular) {
    "use strict";

    var synchronizationNotificationService = function ($rootScope, menuModelService, routeService, $cordovaLocalNotification, $ionicPopup, notificationPluginWrapper) {

        /* DEFAULT CONFIGURATION */

        var notificationConfig = {
            title: "Synchronization Result",
            message: "A synchronization result has been received. Would you like to check it?",
            idseed: 0
        };

        /* UTILS */

        var isSimulator = !!isRippleEmulator();

        var buildNotification = function(operation) {
            return {
                id: notificationConfig.idseed++, // id has to be an Integer otherwise it is defaulted to 0
                title: notificationConfig.title,
                text: notificationConfig.message,
                data: {
                    operationId: operation.id
                }
            };
        };

        /* ACTIONS */

        /**
         * Registers a local notification on the device notification center.
         * 
         * @param SyncOperation operation 
         * @returns Promise 
         */
        var deviceNotifySyncReceived = function (operation) {
            var notification = buildNotification(operation);
            return $cordovaLocalNotification.schedule(notification);
        };

        /**
         * Prompts the user with a popup emulating a notification (clickable and dismissable, but a popup).
         * 
         * @param SyncOperation operation 
         * @returns Promise 
         */
        var simulatorNotifySyncReceived = function(operation) {
            return  $ionicPopup.confirm({
                title: notificationConfig.title,
                template: notificationConfig.message
            }).then(function (res) {
                if (res) {
                    // broadcast notification click event
                    var notification = buildNotification(operation);
                    $rootScope.$broadcast("$cordovaLocalNotification:click", notification);
                }
            });
        };

        /**
         * Registers a notification depending on the runtime the application is running in:
         * - device/device emulators: notification center
         * - Ripple emulator: popup
         * 
         * @param SyncOperation operation 
         * @returns Promise 
         */
        var notifySynchronizationReceived = function(operation) {
            if (isSimulator) {
                return simulatorNotifySyncReceived(operation);
            }
            return deviceNotifySyncReceived(operation);
        };

        /**
         * Check for permissions to show local notifications - iOS 8 NEEDS permission to run.
         * If permission is not granted prompt the user asking for permission.
         */
        var checkNotificationPermission = function() {
            if (isSimulator) {
                return;
            }
            $cordovaLocalNotification.hasPermission().then(function (granted) {
                $cordovaLocalNotification.cancelAll();
                if (!granted) {
                    $cordovaLocalNotification.promptForPermission();
                };
            });
        };

        /**
         * Prepares the app to use notification feature: registers plugin listeners and checks permission.
         */
        var prepareNotificationFeature = function() {
            if (!isSimulator) {
                notificationPluginWrapper.init();
                checkNotificationPermission();
            }
        };

        /* EVENT LISTENERS */

        $rootScope.$on("$cordovaLocalNotification:click", function ($event, notification, state) {
            var data = notification.data;
            if (angular.isString(notification.data)) {
                data = JSON.parse(data);
            }
            routeService.go("main.syncoperationdetail", { id: data.operationId });
            menuModelService.updateAppsCount();
        });

        /* SERVICE INSTANCE */

        var api = {
            notifySynchronizationReceived: notifySynchronizationReceived,
            checkNotificationPermission: checkNotificationPermission,
            prepareNotificationFeature: prepareNotificationFeature
        };
        
        return api;
    }

    mobileServices.factory("synchronizationNotificationService",
        ["$rootScope","menuModelService", "routeService", "$cordovaLocalNotification", "$ionicPopup", "notificationPluginWrapper", synchronizationNotificationService]);

})(mobileServices, angular);
;
(function(angular, modules) {
    "use strict";

    /**
     * Service contructor funtion.
     * 
     * @param {} $log 
     * @param {} $q 
     * @param {} swdbDAO 
     * @returns {} service instance
     * @constructor 
     */
    const SynchronizationOperationService = function ($log, $q, swdbDAO, formatter) {

        const saveBatchOperation = function (operation, relatedBatches) {
            return swdbDAO.instantiate("SyncOperation", operation)
                .then((operationEntity) => {
                    // all batches need to be complete in order for the syncoperation to be complete
                    const isComplete = relatedBatches.every(batch => batch.status === "COMPLETE");
                    // add relationships
                    relatedBatches.forEach(batch => {
                        operationEntity.batches.add(batch);
                        if (batch.loadeditems && batch.loadeditems !== null && batch.loadeditems.length > 0) {
                            operationEntity.items += batch.loadeditems.length;
                        }
                        batch.syncoperation = operationEntity;
                    });
                    if (isComplete) {
                        //if every batch returned as complete than we have a synchronous case and can close the sync operation
                        const hasProblem = relatedBatches.some(result => result.hasProblems);
                        operationEntity.status = "COMPLETE";
                        operationEntity.enddate = new Date().getTime();
                        operationEntity.hasProblems = hasProblem;
                    } else {
                        operationEntity.status = "PENDING";
                    }
                    var deferred = $q.defer();
                    persistence.transaction(tx => {
                        try {
                            swdbDAO.bulkSave(relatedBatches, tx);
                            swdbDAO.save(operationEntity, tx);
                            // flushing transaction
                            persistence.flush(tx, () => {
                                // resolve promise with the syncOperation
                                deferred.resolve(operationEntity);
                            });
                        } catch (error) {
                            // reject promise with DB error
                            deferred.reject(error);
                        }
                    });
                    return deferred.promise;
                });
        }

        this.createBatchOperation = function(startdate, relatedBatches) {
            const operation = {
                startdate: startdate,
                items: 0
            };
            // return promise chain initiated with the creation of SyncOperation
            return saveBatchOperation(operation, relatedBatches);
        };

        this.createSynchronousBatchOperation = function (startdate,clientOperationId, numberofdownloadeditems, relatedBatches) {
            //if every batch returned as complete than we have a synchronous case and can close the sync operation
            const hasProblem = relatedBatches.some(result => result.hasProblems);
            if (!clientOperationId) {
                clientOperationId = persistence.createUUID();
            }


            const operation = {
                startdate,
                numberofdownloadeditems,
                numberofdownloadedsupportdata: 0,
                hasProblems: hasProblem,
                clientOperationId,
                enddate: new Date()
            };
            return saveBatchOperation(operation, relatedBatches);
        };
        
        this.createNonBatchOperation = function (startdate, clientOperationId, enddate, numberofdownloadeditems, numberofdownloadedsupportdata, metadatachange) {
            const operation = {
                clientOperationId,
                startdate,
                enddate,
                status: "COMPLETE",
                numberofdownloadeditems,
                numberofdownloadedsupportdata,
                metadatachange
            };
            return swdbDAO.instantiate("SyncOperation", operation).then(item => swdbDAO.save(item));
        }

        this.hasProblems = function (operation) {
            return operation.hasProblems;
        };

        this.getSyncList = function (pageNumber) {
            const page = !pageNumber || pageNumber <= 0 ? 1 : pageNumber;
            return swdbDAO.findByQuery("SyncOperation", null, { pagesize: 10, pageNumber: page, orderby: "startdate", orderbyascending: false })
                .then(operations => 
                    !operations || operations.length <= 0 
                        ? operations
                        // format the operations found
                        : operations.map(operation => this.formatOperation(operation))
                );
        };

        /**
         * Fetches the SyncOperation the has the matching id 
         * 
         * @param int id primary key
         * @returns Promise: resolved with SyncOperation entity, rejected with database Error. 
         */
        this.getOperation = function (id) {
            return swdbDAO.findById("SyncOperation", id).then(operation => this.formatOperation(operation));
        };

        this.doneNoProblems = function(operation) {
            return operation.status.equalIc("complete") && !this.hasProblems(operation);
        };

        this.doneWithProblems = function(operation) {
            return operation.status.equalIc("complete") && this.hasProblems(operation);
        };

        this.isPending = function(operation) {
            return operation.status.equalIc("pending");
        };

        /**
         * Adds a few extra fields to the operation:
         * <ul>
         * <li>'formatteddate': String - formatted startdate </li>
         * <li>'formattedstatus': String - "displayable" status </li>
         * <li>'issuccess': Boolean </li>
         * <li>'ispending': Boolean </li>
         * <li>'hasproblems': Boolean </li>
         * </ul>
         * @param SyncOperation (entity) operation 
         * @returns SyncOperation (entity) formatted 
         */
        this.formatOperation = function (operation) {
            if (!operation) {
                return operation;
            }
            operation.formatteddate = formatter.formatDate(operation.startdate, "MM/dd/yyyy HH:mm");
            operation.elapsedtime = ((operation.enddate - operation.startdate) / 1000);

            if (this.doneNoProblems(operation)) {
                operation.formattedstatus = "Completed";
                operation.issuccess = true;
            } else if (this.isPending(operation)) {
                operation.formattedstatus = "Pending";
                operation.ispending = true;
            } else if (this.doneWithProblems(operation)) {
                operation.formattedstatus = "Completed with Issues";
                operation.hasproblems = true;
            }
            return operation;
        };

        /**
         * Fetches a SyncOperation's related BatchItems
         * 
         * @param SyncOperation operation 
         * @returns Promise: resolved with related BatchItem list, rejected with Database Error 
         */
        this.getBatchItems = function(operation) {
            return swdbDAO.findByQuery("Batch", "syncoperation = '{0}'".format(operation.id))
                .then(batches => {
                    const batchids = batches.map(batch => `'${batch.id}'`);
                    return swdbDAO.findByQuery("BatchItem", "batch in ({0})".format(batchids), { prefetch: "problem" });
                });
        };

        /**
         * Fetches the most recent (highest 'startdate') SyncOperation from the database.
         * 
         * @returns Promise: resolved with most recent operation, rejected with database error 
         */
        this.getMostRecentOperation = function() {
            return swdbDAO.findSingleByQuery("SyncOperation", null, { orderby: "startdate", orderbyascending: false })
                .then(operation => this.formatOperation(operation));
        };

        /**
         * Updates the status of the SyncOperations related to the batches to "COMPLETE"
         * and sets their enddate as now.
         * 
         * TODO: this method assumes there's a single batch/application per SyncOperation -> develop generic case
         * 
         * @param [Batch] batches 
         * @returns Promise resolved with array of updated SyncOperations 
         */
        this.completeFromAsyncBatch = function(batches) {
            var enddate = new Date();
            const operations = batches.map(function(batch) {
                batch.syncoperation.status = "COMPLETE";
                batch.syncoperation.enddate = enddate;
                return batch.syncoperation;
            });
            return swdbDAO.bulkSave(operations);
        };

    };

    modules.webcommons.service("synchronizationOperationService", ["$log", "$q", "swdbDAO", "formatService", SynchronizationOperationService]);

})(angular, modules);;
(function (angular) {
    "use strict";

    function commandBarDelegate($ionicScrollDelegate) {
        //#region Utils

        //#endregion

        //#region Public methods

        /**
         * Positions the commandBarElement in the FAB position.
         * 
         * @param {$(DOMNode)} commandBarElement 
         * @param {Number} scrollPosition optional current scroll handler's position.top
         */
        function positionFabCommandBar(commandBarElement, scrollPosition) {

            if (!scrollPosition) {

                let positionObj = $ionicScrollDelegate.$getByHandle('detailHandler').getScrollPosition();
                scrollPosition = !!positionObj ? positionObj.top : 0;
            }


            const toolbarPrimary = $(".bar-header.bar-positive:visible").outerHeight(true);
            const toolbarSecondary = $(".bar-subheader.bar-dark:visible").outerHeight(true);
            const headerTitle = $(".crud-details .crud-title:visible").outerHeight(true);
            const headerDescription = $(".crud-details .crud-description:visible").outerHeight(true);
            const componetHeights = toolbarPrimary + toolbarSecondary + headerTitle + headerDescription;
            const top = angular.isNumber(scrollPosition) && scrollPosition >= 0 ? scrollPosition : 0;
            const windowHeight = $(window).height();
            const offset = (windowHeight - componetHeights - 70) + top;

            $(commandBarElement).css("top", offset);

            const contentBody = $("ion-nav-view[name='body']");
            const contentPane = $(".list.pane[state='main.cruddetail.maininput']");

            if (componetHeights + contentBody.outerHeight(true) < windowHeight) {
                const minHeight = windowHeight - componetHeights - 8;

                $(contentBody).css("min-height", minHeight);
                $(contentPane).css("min-height", minHeight);
            }

        }

        //#endregion

        //#region Service Instance
        const service = {
            positionFabCommandBar
        };
        return service;
        //#endregion
    }

    //#region Service registration

    angular.module("sw_mobile_services").factory("commandBarDelegate", ["$ionicScrollDelegate", commandBarDelegate]);

    //#endregion

})(angular);;
(function (mobileServices, ionic) {
    "use strict";

    function loadingService($ionicLoading, $q, $timeout, $ionicPlatform) {
        //#region Utils


        var deregisterFn=[];


        //#endregion

        //#region Public methods

        function showDefault() {
            return this.show("Loading");
        }

        function show(message) {
            deregisterFn.push($ionicPlatform.registerBackButtonAction(e=> {
                this.hide();
            }, 501));
            const options = {
                template: `<ion-spinner icon='spiral'></ion-spinner><br><span>${message}<span>`,
                animation: "fade-in"
            };
            return $ionicLoading.show(options);
        }

        function hide() {
            if (deregisterFn) {
                deregisterFn.forEach((deregisterFn) => deregisterFn());
            }

            ionic.requestAnimationFrame(() => {
                $ionicLoading.hide();
            });
        }

        //#endregion

        //#region Service Instance
        const service = {
            showDefault,
            show,
            hide
        };

      

        return service;
        //#endregion
    }

    //#region Service registration

    mobileServices.factory("loadingService", ["$ionicLoading", "$q", "$timeout", "$ionicPlatform", loadingService]);

    //#endregion

})(mobileServices, ionic);;
(function (mobileServices, angular) {
    "use strict";

    function swAlertPopup($ionicPopup, $timeout) {

        //#region Utils

        var control = {
            queue: [], // queue of popup configs scheduled to be shown
            showing: false, // flag indicating if there's an active (showing) popup
            showinterval: 100 // empirically determined: 100 milliseconds interval in-between closing current and showing next one 
        }

        function showNext(previous) {
            // close previous (currently showing) popup before showing the next
            if (!!previous) {
                control.showing = false;
                previous.close();
            }

            // no popups scheduled to be shown
            if (control.queue.length <= 0) return;

            // schedule next popup to be shown
            $timeout(function () {
                const config = control.queue.shift();
                var popup = $ionicPopup.alert(config);
                control.showing = true;
                // schedule preconfigured (by the caller) alert popup close
                var timeid = null;
                const timeout = config.timeout;
                if (angular.isNumber(timeout) && timeout > 0) {
                    timeid = $timeout(function () {
                        showNext(popup);
                    }, timeout);
                }
                // popup was closed: open next on queue
                popup.then(function () {
                    // if closed by the user, cancel the timeout to automatically close it
                    if (timeid) $timeout.cancel(timeid);
                    showNext(popup);
                });

            }, control.showinterval); 

        }

        function hidrateConfig(config, timeout) {
            config.timeout = timeout;
            return config;
        }

        //#endregion

        //#region Public methods

        /**
         * Shows alert popup (same as $ionicPopup#showAlert)
         * 
         * @param {} config same as $ionicPopup#showAlert
         * @param Long timeout interval in milliseconds to automatically close the popup.
         *             If =< 0 or NaN, will be ignored.
         */
        function show(config, timeout) {
            config = hidrateConfig(config, timeout);
            control.queue.push(config);
            // if first on queue and no current active popup: trigger show mechanism 
            if (control.queue.length <= 1 && !control.showing) {
                showNext();
            }
        }

        function alertValidationErrors(errors, title, message) {
            const errorMessage = errors.join("<br>");
            const fullMessage = message ? `${message}<br>${errorMessage}` : errorMessage;
            return $ionicPopup.alert({
                title: title || "There are Validation Errors",
                subTitle: fullMessage,
                cssClass: "alert"
            });
        }

        //#endregion

        //#region Service Instance
        const service = {
            show,
            alertValidationErrors
        };
        return service;
        //#endregion
    }
    //#region Service registration
    mobileServices.factory("swAlertPopup", ["$ionicPopup", "$timeout", swAlertPopup]);
    //#endregion

})(mobileServices, angular);;
(function (angular) {
    "use strict";

    angular.module("softwrench").directive("associationDescription", ["$parse",function ($parse) {
        var directive = {
            restrict: 'A',
            require: '?ngModel',
            link: function (scope, element, attrs, modelCtrl) {

                modelCtrl.$formatters.push(function (modelValue) {
                    var field = scope.field;
                    if ("true" !== field.hideDescription) {
                        return modelValue + " - " + scope.datamap[field.associationKey + "." + field.labelFields[0]];
                    }
                    return modelValue;
                });

            }
        };

        return directive;

    }]);

})(angular);;
(function (angular) {
    "use strict";

    angular.module("softwrench").directive("autosizeTextarea", ["$timeout", function ($timeout) {
        const directive = {
            link: function (scope, element, attrs) {
                var width = $(element).width();
                var fontSize = $(element).css('font-size');
                var fontFamily = $(element).css('font-family');

                function getNumberOfLines(string) {
                    if (!string) {
                        return 1;
                    }

                    const textWidth = getTextWidth(string, fontSize + ' ' + fontFamily);
                    const lines = Math.ceil(textWidth / width);

                    return lines;
                }

                function getTextWidth(text, font) {
                    // re-use canvas object for better performance
                    var canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement("canvas"));
                    var context = canvas.getContext("2d");
                    context.font = font;
                    var metrics = context.measureText(text);
                    return metrics.width;
                }

                scope.$watch(attrs.ngModel, function (newValue) {
                    element[0].rows = getNumberOfLines(newValue);
                });

                scope.$on('sw:ionAutocomplete:viewValue', (event, value) => {
                    if (value.indexOf(element[0].value) > -1) {
                        $timeout(function () {
                            element[0].rows = getNumberOfLines(value);
                        });
                    }
                });

                scope.$on('sw:optionField:viewValue', (event, value) => {
                    $timeout(function() {
                        element[0].rows = getNumberOfLines(value);
                    });
                });
            }
        };

        return directive;
    }]);

})(angular);;
(function (angular) {
    "use strict";

    angular.module("softwrench").directive("commandBar", ["commandBarDelegate", function (commandBarDelegate) {
        const directive = {
            restrict: "E",
            templateUrl: getResourcePath("Content/Mobile/templates/directives/commandbar.html"),
            replace: false,
            scope: {
                position: "@",
                schema: "=",
                datamap: "=",
                label: "@"
            },

            controller: ["$scope", "$rootScope", "offlineCommandService", function ($scope, $rootScope, offlineCommandService) {
                //#region classes
                class CommandHolder {
                    constructor() {
                        if (this.constructor === CommandHolder) {
                            throw new TypeError("Cannot instantiate abstract class CommandHolder");
                        }
                    }
                    get activeCommands() {
                        throw new TypeError("Abstract getter for activeCommands not implemented");
                    }
                    get hasActiveCommands() {
                        return this.activeCommands.length > 0;
                    }
                }

                class SingleCommandHolder extends CommandHolder {
                    constructor() {
                        super();
                        if (this.constructor === SingleCommandHolder) {
                            throw new TypeError("Cannot instantiate abstract class SingleCommandHolder");
                        }
                    }
                    get isSingleActiveCommand() {
                        return this.activeCommands.length === 1;
                    }
                    get singleActiveCommand() {
                        return this.activeCommands[0];
                    }
                }

                class CommandContainer extends SingleCommandHolder {
                    constructor(commands) {
                        super();
                        this.commands = commands;
                    }
                    get activeCommands() {
                        return this.hasCommands
                            ? this.commands.filter(c => !offlineCommandService.isCommandHidden($scope.datamap, $scope.schema, c))
                            : [];
                    }
                    get hasCommands() {
                        return angular.isArray(this.commands) && this.commands.length > 0;
                    }
                }

                class CommandBar extends SingleCommandHolder {
                    constructor(commands) {
                        super();

                        const commandsDefined = angular.isArray(commands) && commands.length > 0;

                        this.containers = commandsDefined
                            ? commands.filter(c => c.type === "ContainerCommand").map(c => new CommandContainer(c.displayables))
                            : [];

                        this.childCommands = commandsDefined
                            ? new CommandContainer(commands.filter(c => c.type !== "ContainerCommand"))
                            : [];
                    }
                    get hasActiveCommands() {
                        return this.childCommands.hasActiveCommands || this.containers.some(c => c.hasActiveCommands);
                    }
                    get activeCommands() {
                        return this.childCommands.activeCommands;
                    }
                }
                //#endregion

                $scope.commandBar = new CommandBar([]);

                $scope.getCommandBarStyleClass = () => window.replaceAll($scope.position, "\\.", "-");

                $scope.executeCommand = command => offlineCommandService.executeCommand(command, $scope.schema, $scope.datamap).then(r => {
                    if (window.cordova && window.cordova.plugins && window.cordova.plugins.Keyboard) {
                        return cordova.plugins.Keyboard.close();
                    }
                });

                $scope.isCommandHidden = command => !command || offlineCommandService.isCommandHidden($scope.datamap, $scope.schema, command);

                $scope.shouldShowFabCommand = () => {
                    if (window.cordova && window.cordova.plugins && window.cordova.plugins.Keyboard) {
                        return !cordova.plugins.Keyboard.isVisible;
                    }
                    return true;
                };

                window.addEventListener('native.keyboardshow', keyboardToggleHandler);
                window.addEventListener('native.keyboardhide', keyboardToggleHandler);

                function keyboardToggleHandler(e) {
                    //forcing toggle visibility to be restored
                    console.log("keyboard toggle");

                    $scope.$digest();
                    commandBarDelegate.positionFabCommandBar($scope.element);
                }

                const updateCommandBar = (schema, position) => {
                    const commands = offlineCommandService.getCommands(schema || $scope.schema, position || $scope.position) || [];
                    $scope.commandBar = new CommandBar(commands);
                }

                const init = () => updateCommandBar();

                init();

                $scope.$watch("schema", (newSchema, oldSchema) => {
                    if (newSchema === oldSchema || angular.equals(newSchema, oldSchema)) return;
                    updateCommandBar(newSchema);
                }, true);
                $scope.$watch("position", (newPosition, oldPosition) => {
                    if (newPosition === oldPosition) return;
                    updateCommandBar(null, newPosition);
                });

                $scope.$on("sw_updatecommandbar", (event, position) => {
                    if (position === $scope.position) {
                        updateCommandBar();
                    }
                });
            }],

            link: function (scope, element, attrs) {
                commandBarDelegate.positionFabCommandBar(element);
                scope.element = element;
            }
        };

        return directive;
    }]);

})(angular);
;
(function (angular) {
    "use strict";

    angular.module("softwrench").directive("crudIcon", [function () {
        const directive = {
            restrict: "E",
            templateUrl: getResourcePath("Content/Mobile/templates/directives/crud/crud_icon.html"),
            transclude: false,
            replace: false,
            scope: {
                item: "=",
                isdetail: "=",
                iscomposition: "@",
                datamap: "=" // used on detail
            },
            controller: ["$scope", "iconProviderService", "crudContextService", "$rootScope", function ($scope, iconProviderService, crudContextService, $rootScope) {
                const createIcon = function (item) {
                    $scope.icon = iconProviderService.getIcon(item, $scope.iscomposition);
                }

                createIcon($scope.isdetail ? crudContextService.currentDetailItem() : $scope.item);

                if ($scope.isdetail) {
                    $rootScope.$on(JavascriptEventConstants.CrudSaved,() => {
                            createIcon(crudContextService.currentDetailItem());
                    });

                    $rootScope.$on("sw.labor.start", () => {
                        createIcon(crudContextService.currentDetailItem());
                    });

                    $rootScope.$on("sw.labor.stop", () => {
                        createIcon(crudContextService.currentDetailItem());
                    });

                    $rootScope.$on("sw.sync.quicksyncfinished", () => {
                        createIcon(crudContextService.currentDetailItem());
                    });

                    $rootScope.$on("sw.problem.problemupdated", () => {
                        createIcon(crudContextService.currentDetailItem());
                    });

                    $scope.$watch("datamap.approwstamp", (newRowstamp, oldRowstamp) => {
                        if (oldRowstamp && newRowstamp !== oldRowstamp) {
                            createIcon(crudContextService.currentDetailItem());
                        }
                    }, true);
                }
            }]
        };

        return directive;
    }]);

})(angular);;
(function (softwrench, angular, _) {
    "use strict";

    softwrench.directive('sectionElementInput', ["$compile", function ($compile) {
        return {
            restrict: "E",
            replace: true,
            scope: {
                schema: '=',
                datamap: '=',
                isDirty: '=',
                displayables: '=',
                associationOptions: '=',
                associationSchemas: '=',
                blockedassociations: '=',
                extraparameters: '=',
                elementid: '@',
                orientation: '@',
                islabelless: '@',
                lookupAssociationsCode: '=',
                lookupAssociationsDescription: '=',

            },
            template: "<div></div>",
            link: function (scope, element, attrs) {
                if (angular.isArray(scope.displayables)) {
                    element.append(
                    "<crud-input-fields displayables='displayables'" +
                    "schema='schema'" +
                    "datamap='datamap'" +
                    "is-dirty='isDirty'" +
                    "displayables='displayables'" +
                    "association-options='associationOptions'" +
                    "association-schemas='associationSchemas'" +
                    "blockedassociations='blockedassociations'" +
                    "elementid='{{elementid}}'" +
                    "orientation='{{orientation}}' insidelabellesssection='{{islabelless}}'" +
                    "outerassociationcode='lookupAssociationsCode' outerassociationdescription='lookupAssociationsDescription' issection='true'" +
                    "></crud-input-fields>"
                    );
                    $compile(element.contents())(scope);
                }
            }
        }
    }]);

    softwrench.directive('crudInputFields', [function () {

        return {
            restrict: 'E',
            replace: false,
            templateUrl: getResourcePath('Content/Mobile/templates/directives/crud/crud_input_fields.html'),
            scope: {
                schema: '=',
                datamap: '=',
                displayables: '=',
                allDisplayables: "="
            },

            link: function (scope, element, attrs) {
                scope.name = "crud_input_fields";
            },

            controller: ["$scope", "$rootScope", "offlineAssociationService", "crudContextService", "fieldService", "expressionService", "dispatcherService", "$timeout", "$log", "wizardService", "swdbDAO","searchIndexService","offlineSchemaService",
                function ($scope, $rootScope, offlineAssociationService, crudContextService, fieldService, expressionService, dispatcherService, $timeout, $log, wizardService, dao,searchIndexService, offlineSchemaService) {

                    $scope.associationSearch = function (query, componentId, pageNumber, useWhereClause, currentValue) {
                        return offlineAssociationService.filterPromise($scope.schema, $scope.datamap, componentId, query, null, pageNumber, useWhereClause, currentValue);
                    };

                    $scope.itemSelected = function (callback) {
                        return offlineAssociationService.updateExtraProjections(callback.item, callback.componentId);
                    }

                    $scope.optionFieldSelected = function (callback) {
                        return offlineAssociationService.updateExtraProjectionsForOptionField(callback.item, callback.componentId);
                    }

                    $scope.getAssociationLabelField = function (fieldMetadata) {
                        return offlineAssociationService.fieldLabelExpression(fieldMetadata);
                    }

                    $scope.getAssociationValueField = function (fieldMetadata) {
                        return offlineAssociationService.fieldValueExpression(fieldMetadata);
                    }

                    $scope.isReadOnly = function (field) {
                        return fieldService.isFieldReadOnly($scope.datamap, $scope.schema, field, $scope) || wizardService.isReadOnly(field, $scope.allDisplayables);
                    }

                    $scope.isFieldHidden = function (fieldMetadata) {
                        return fieldService.isFieldHidden($scope.datamap, $scope.schema, fieldMetadata);
                    }

                    $scope.isFieldRequired = function (requiredExpression) {
                        if (Boolean(requiredExpression)) {
                            return expressionService.evaluate(requiredExpression, $scope.datamap);
                        }
                        return requiredExpression;
                    };

                    $scope.hasUseWhereClause = function (field) {
                        const params = field.rendererParameters;
                        if (!params) {
                            return false;
                        }
                        return "true" === params["hasUseWhereClause"];
                    }

                    //#region assosiations and options label init

                    /**
                     * $broadcast's "sw:association:resolved" event with the entity.AssociationData for setting initial labels in the $viewValues.
                     */
                    function triggerAssociationsInitialLabels() {
                        //TODO: move to offlineassociationService

                        const log = $log.get("crud_input_fields#triggerAssociationsInitialLabels", ["association", "detail"]);

                        // association fields that have a value set in the datamap
                        const associationFields = fieldService
                                                    .getDisplayablesOfTypes($scope.allDisplayables, ["ApplicationAssociationDefinition"])
                                                    .filter(field => $scope.datamap.hasOwnProperty(field.attribute) && !!$scope.datamap[field.attribute]);

                        if (associationFields.length <= 0) {
                            log.debug("no associationfields with value set in the current datamap");
                            return;
                        }

                        if (log.isLevelEnabled("debug")) log.debug(`fetching values for fields ${associationFields.map(f => f.attribute)}`);

                        const whereClauses = associationFields.map(f => {
                            const associationKey = f.associationKey;
                            const associationName = associationKey.endsWith("_")
                                ? associationKey.substring(0, associationKey.length - 1)
                                : associationKey;
                            const associationEntityName = f.entityAssociation.to;
                            const associationValue = $scope.datamap[f.attribute];

                            // local transient name cache to be used further down the promise chain
                            f["#associationLocalCache"] = { associationName, associationEntityName };

                            var listSchema = offlineSchemaService.locateSchemaByStereotype(associationName, "list");
                            var nameToUse = associationName;
                            if (!listSchema) {
                                //falling back to entityName instead, due to multiple possibilities on the sync process, depending on how the association is declared (qualifier or not)
                                listSchema = offlineSchemaService.locateSchemaByStereotype(associationEntityName, "list");
                                nameToUse = associationEntityName;
                            }

                            const idx = !!listSchema? searchIndexService.getIndexColumn(associationName, listSchema, f.valueField) : null;

                            if (!!idx) {
                                log.debug("applying index query");
                                return `( application = '${nameToUse}' and ${idx} = '${associationValue}')`;
                            }

                            log.warn(`applying non-indexed query consider adjusting your metadata to include the proper index for ${associationName}: ${f.valueField}`);
                            // fetching by application and by value
                            return `(application in('${associationName}','${associationEntityName}') and datamap like '%"${f.valueField}":"${associationValue}"%')`;
                        });

                        const query = whereClauses.join("or");

                        log.debug(`fetching labels with query '${query}'`);

                        dao.findByQuery("AssociationData", query).then(results => {
                            const values = results.map(association => {
                                // field that corresponds to the AssociationData fetched: same application and same value on the datamap 
                                const correspondingField = associationFields.find(field =>
                                    (association.application === field["#associationLocalCache"].associationName || association.application === field["#associationLocalCache"].associationEntityName)
                                    && association.datamap[field.valueField] === $scope.datamap[field.attribute]
                                );                                

                                return { associationKey: correspondingField.associationKey, item: association };
                            });

                            associationFields.forEach(f => delete f["#associationLocalCache"]);

                            // indexing by associationKey to facilitate lookup
                            const indexed = _.indexBy(values, "associationKey");

                            log.debug(`resolved items for labels: ${indexed}`);

                            $scope.$broadcast("sw:association:resolved", indexed);
                        });
                    }

                    //#endregion

                    //#region afterchangeevent dispatcher
                    class ChangeEventDispatcher {
                        constructor(fields, dispatcher, timeout, logger) {
                            this.fields = fields;
                            this.dispatcher = dispatcher;
                            this.timeout = timeout;
                            this.logger = logger;
                            this.eventDescriptors = this.fields.map((f, i) => ({
                                name: f.attribute,
                                shouldWatch: true,
                                event: f.events["afterchange"]
                            }));
                            //properties on the datamap that must be watched
                            this.expressions = this.eventDescriptors.map(e => `datamap.${e.name}`);
                        }
                        getEvent(expression) {
                            return this.eventDescriptors.find(e => `datamap.${e.name}` === expression);
                        }

                        handleIgnoreWatchScenario(descriptor, newValue, datamap, ignoreWatchIdx) {
                            descriptor.shouldWatch = false;
                            let realValue = newValue.substring(0, ignoreWatchIdx);
                            if (realValue === "null") {
                                realValue = null;
                            }

                            this.logger.debug(`setting real value ${realValue} for association ${descriptor.name}`);
                            const dm = crudContextService.currentDetailItemDataMap();
                            dm[descriptor.name] = realValue;
                            datamap[descriptor.name] = realValue;
                            try {
                                $scope.$digest();
                                descriptor.shouldWatch = true;
                            } catch (e) {
                                //nothing to do, just checking if digest was already in place or not
                                $timeout(() => descriptor.shouldWatch = true, 0, false);
                            }
                        }

                        dispatchEventFor(position, schema, datamap, newValue) {
                            const descriptor = this.getEvent(position);
                            if (!descriptor.shouldWatch) {
                                this.logger.trace(`ignoring event for ${descriptor.name}`);
                                return;
                            }
                            const ignoreWatchIdx = newValue === null || newValue === undefined || !angular.isFunction(newValue.indexOf)
                                ? -1
                                : newValue.indexOf("$ignorewatch");
                            if (ignoreWatchIdx >= 0) {
                                return this.handleIgnoreWatchScenario(descriptor, newValue, datamap, ignoreWatchIdx);
                            }

                            const service = descriptor.event.service;
                            const method = descriptor.event.method;
                            const handler = this.dispatcher.loadService(service, method);
                            const params = { schema, datamap, newValue };

                            this.logger.debug(`dispatching 'afterchange' event for field '${descriptor.name}'. Value: ${newValue}`);
                            this.timeout(() => handler(params))
                                .catch(e => this.logger.error(`Failed to execute ${service}.${method} on 'afterchange' of field '${descriptor.name}'`, e));
                        }
                    }

                    function watchFields() {
                        // watching for changes to trigger afterchange event handlers
                        const watchableFields = $scope.allDisplayables.filter(f => f.events && f.events.hasOwnProperty("afterchange") && !!f.events["afterchange"]);
                        if (!watchableFields || watchableFields.length <= 0) return;

                        const logger = $log.get("crud_input_fields", ["datamap", "event", "association"]);
                        const dispatcher = new ChangeEventDispatcher(watchableFields, dispatcherService, $timeout, logger);

                        logger.debug(`watching ${dispatcher.expressions}`);

                        // flag that decides if change events should be dispatched
                        $rootScope.areChangeEventsEnabled = true;

                        dispatcher.expressions.forEach(expression => {
                            $scope.$watch(expression, (newValue, oldValue) => {
                                if (newValue === oldValue) {
                                    return;
                                }

                                if ($rootScope.areChangeEventsEnabled) {
                                    dispatcher.dispatchEventFor(expression, $scope.schema, $scope.datamap, newValue);
                                }
                            });
                        });
                    }
                    //#endregion

                    function init() {
                        $log.get("crud_input_fieldsl#init").debug("crud_input_fields init");
                        triggerAssociationsInitialLabels();
                        watchFields();
                    }

                    $scope.$on("sw_cruddetailrefreshed", () => {
                        $scope.datamap = crudContextService.currentDetailItemDataMap();
                        triggerAssociationsInitialLabels();
                    });

                    init();

                }]
        }
    }]);

})(softwrench, angular, _);
;
(function(softwrench) {
    "use strict";
        
softwrench.directive('crudOutputFields', ["$log", "fieldService", "crudContextService", "formatService", function ($log, fieldService, crudContextService, formatService) {

    return {
        restrict: 'E',

        // has to have this configuration otherwise the controller's methods are not accessible by the template
        replace: false,
        transclude: true,

        templateUrl: getResourcePath('Content/Mobile/templates/directives/crud/crud_output_fields.html'),
        scope: {
            displayables: '=',
            datamap:'='
        },

        link: function (scope, element, attrs) {
            scope.name = 'crud_output_fields';
        },

        controller: ["$scope", function ($scope) {

            $scope.getFormattedValue = function (value, column, datamap) {
                return formatService.format(value, column, datamap);
            };


            $scope.getDisplayables = function () {
                return $scope.displayables;
            }

            $scope.isFieldHidden = function (fieldMetadata) {
                return fieldService.isFieldHidden(crudContextService.currentDetailItem(), crudContextService.currentDetailSchema(), fieldMetadata);
            }

        }]
    }
}]);

})(softwrench);;
(function (angular) {
    "use strict";

    angular.module("softwrench").directive("dateconverter", ["formatService", function (formatService) {
        var directive = {
            restrict: 'A',
            require: '?ngModel',
            link: function (scope, element, attrs, modelCtrl) {

                modelCtrl.$parsers.push(function (inputValue) {
                    if (inputValue instanceof Date) {
                        return formatService.formatDate(inputValue, scope.field.rendererParameters['format']);
                    }
                    return inputValue;
                });

                modelCtrl.$formatters.push(function(modelValue) {
                    return new Date(modelValue);
                });

                scope.dateHandler = (function () {
                    function nowWhenNotAllowed(field, parameter) {
                        var rendererParameters = field.rendererParameters;
                        return (rendererParameters.hasOwnProperty(parameter)
                            && (rendererParameters[parameter] === "false" || rendererParameters[parameter] === false))
                                ? new Date()
                                : null;
                    }
                    function getMaxDateValue(field) {
                        return nowWhenNotAllowed(field, "allowfuture");
                    }
                    function getMinDateValue(field) {
                        return nowWhenNotAllowed(field, "allowpast");
                    }
                    return {
                        getMaxDateValue: getMaxDateValue,
                        getMinDateValue: getMinDateValue
                    };
                })();


            }
        };

        return directive;

    }]);

})(angular);


;
(function (angular) {
    "use strict";

    angular.module("softwrench").directive("messagesection", ["$log", "$rootScope", function ($log, $rootScope) {

        var directive = {
            restrict: "E",
            templateUrl: getResourcePath("Content/Mobile/templates/directives/messagesection.html"),
            scope: {

            },
            controller: ["$scope", function ($scope) {

                $scope.$on('$stateChangeSuccess',
                 function (event, toState, toParams, fromState, fromParams) {
                     $scope.hasValidationError = false;
                     $scope.validationArray = null;
                 });

            }],


            link: function (scope, element, attrs) {

                scope.$on("sw_validationerrors", function (event, validationArray) {
                    $log.get("messagesection#sw_validationerrors").debug('sw_validationerrors#enter');

                    if (validationArray == null || validationArray.length == 0) {
                        return;
                    }

                    scope.hasValidationError = true;
                    scope.validationArray = validationArray;

                });

                scope.removeValidationAlert = function () {
                    scope.hasValidationError = false;
                    scope.validationArray = null;
                };
            }
        };

        return directive;

    }]);

})(angular);

;
//taken from here:
//http://codepen.io/mhartington/pen/CImqy

(function (softwrench) {
    "use strict";

    softwrench.directive('optionField',
        [
            '$ionicModal','$log',
            function ($ionicModal,$log) {
                return {
                    /* Only use as <option-field> tag */
                    restrict: 'E',

                    /* Our template */
                    templateUrl: getResourcePath('Content/Mobile/templates/directives/option_field.html'),

                    /* Attributes to set */
                    scope: {
                        'items': '=', /* Items list is mandatory */
                        'text': '=', /* Displayed text is mandatory */
                        'value': '=', /* Selected value binding is mandatory */
                        'componentId': '@', /* componentId */
                        'callback': '=', /*TODO: refactor to use callback2*/
                        'callback2': '&',
                    },

                    link: function (scope, element, attrs) {
                        element.find("textArea").on("focus", (event) => {
                            event.target.blur(); // avoids the keyboard show
                        });

                        /* Default values */
                        scope.multiSelect = attrs.multiSelect === 'true' ? true : false;
                        scope.allowEmpty = attrs.allowEmpty === 'false' ? false : true;

                        /* Header used in ion-header-bar */
                        scope.headerText = attrs.headerText || '';

                        /* Text displayed on label */
                        // scope.text          = attrs.text || '';
                        scope.defaultText = scope.text || '';

                        /* Notes in the right side of the label */
                        scope.noteText = attrs.noteText || '';
                        scope.noteImg = attrs.noteImg || '';
                        scope.noteImgClass = attrs.noteImgClass || '';

                        const valueChanged = function (value) {
                            angular.forEach(scope.items, item => {
                                if (item.value === value) {
                                    item.checked = true;
                                }
                            });
                        }

                        const valuesChanged = function (values) {
                            angular.forEach(values, value => {
                                if (value) {
                                    valueChanged(value);
                                }
                            });
                        }

                        var lastUpdatedValue = null;

                        // watch changes on value to update the multiple select checked state
                        const watchForValueChanges = function () {
                            return scope.$watch("value", function (newValue, oldValue) {
                                if (newValue === lastUpdatedValue || !scope.items || !scope.multiSelect) {
                                    return;
                                }

                                lastUpdatedValue = newValue;

                                angular.forEach(scope.items, item => item.checked = false);

                                if (newValue) {
                                    valuesChanged(newValue.split(";"));
                                }
                            });
                        }

                        scope.deWatchValueChanges = watchForValueChanges();

                        /* Optionnal callback function */
                        // scope.callback = attrs.callback || null;

                        /* Instanciate ionic modal view and set params */

                        /* Some additionnal notes here : 
                         * 
                         * In previous version of the directive,
                         * we were using attrs.parentSelector
                         * to open the modal box within a selector. 
                         * 
                         * This is handy in particular when opening
                         * the "option field" from the right pane of
                         * a side view. 
                         * 
                         * But the problem is that I had to edit ionic.bundle.js
                         * and the modal component each time ionic team
                         * make an update of the FW.
                         * 
                         * Also, seems that animations do not work 
                         * anymore.
                         * 
                         */
                        $ionicModal.fromTemplateUrl(
                            getResourcePath('Content/Mobile/templates/directives/option_field_item.html'),
                              { 'scope': scope }
                        ).then(function (modal) {
                            scope.modal = modal;
                        });

                        // object to store if the user moved the finger to prevent opening the modal
                        var scrolling = {
                            moved: false,
                            startX: 0,
                            startY: 0
                        };

                        // store the start coordinates of the touch start event
                        scope.onTouchStart = function (e) {
                            $log.get("optionfield#ontouchstart",["association"]).trace("ontouchstart handler");
                            scrolling.moved = false;
                            // Use originalEvent when available, fix compatibility with jQuery
                            if (typeof (e.originalEvent) !== 'undefined') {
                                e = e.originalEvent;
                            }
                            scrolling.startX = e.touches[0].clientX;
                            scrolling.startY = e.touches[0].clientY;
                        };

                        // check if the finger moves more than 10px and set the moved flag to true
                        scope.onTouchMove = function (e) {
                            $log.get("optionfield#ontouchmove", ["association"]).trace("ontouchmove handler");
                            // Use originalEvent when available, fix compatibility with jQuery
                            if (typeof (e.originalEvent) !== 'undefined') {
                                e = e.originalEvent;
                            }
                            if (Math.abs(e.touches[0].clientX - scrolling.startX) > 10 ||
                                Math.abs(e.touches[0].clientY - scrolling.startY) > 10) {
                                scrolling.moved = true;
                            }
                        };

                        /* Show list */
                        scope.showItems = function (event) {
                            //if (scrolling.moved || ionic.scroll.isScrolling) {
                            //    return;
                            //}
                            //scrolling.moved = false;
                            event.preventDefault();
                            scope.modal.show();
                        }



                        /* Validate selection from header bar */
                        scope.validate = function (event) {
                            // Construct selected values and selected text
                            if (scope.multiSelect == true) {

                                // turns off the watch for value
                                // multiple select toggles are updated at this point
                                scope.deWatchValueChanges();

                                // Clear values
                                scope.value = '';
                                scope.text = '';

                                // Loop on items
                                if (scope.items) {
                                    jQuery.each(scope.items, function (index, item) {
                                        if (item.checked) {
                                            scope.value = scope.value + item.value + ';';
                                            scope.text = scope.text + item.label + ', ';
                                        }
                                    });
                                }

                                // Remove trailing comma
                                scope.value = scope.value.substr(0, scope.value.length - 1);
                                scope.text = scope.text.substr(0, scope.text.length - 2);

                                // turns the watch again on timeout to force - on timeout to force the watch run first
                                scope.deWatchValueChanges = watchForValueChanges();
                            }

                            // Select first value if not nullable
                            if (typeof scope.value == 'undefined' || scope.value == '' || scope.value == null) {
                                if (scope.allowEmpty == false) {
                                    scope.value = scope.items[0].value;
                                    scope.text = scope.items[0].label;

                                    // Check for multi select
                                    scope.items[0].checked = true;
                                } else {
                                    scope.text = scope.defaultText;
                                }
                            }

                            // Hide modal
                            scope.hideItems();

                            // Execute callback function
                            if (typeof scope.callback == 'function') {
                                scope.callback(scope.value);
                            }
                        }

                    

                        /* Hide list */
                        scope.hideItems = function () {
                            scope.modal.hide();
                        }

                        /* Destroy modal */
                        scope.$on('$destroy', function () {
                            scope.modal.remove();
                        });

                        /* Validate single with data */
                        scope.validateSingle = function (item) {

                            // Set selected text
                            scope.text = item.label;

                            // Set selected value
                            scope.value = item.value;

                            // Hide items
                            scope.hideItems();

                            if (typeof scope.callback == 'function') {
                                //TODO: remove this to use callback2
                                scope.callback(scope.value);
                            }

                            // Execute callback function
                            if (typeof scope.callback2 == 'function') {
                                scope.callback2({
                                    callback: {
                                        item: item,
                                        componentId: scope.componentId,
                                    }
                                });
                            }
                        }

                        // $formatter to show label
                        const inputElement = element[0].querySelector(".js_option_input");
                        const ngModel = angular.element(inputElement).controller("ngModel");
                        ngModel.$formatters.push(model => {
                            if (!model || !scope.items) return model;
                            const option = scope.items.find(o => o.value === model);
                            const label = !option ? model : option.label;

                            scope.$emit("sw:optionField:viewValue", label);
                            return label;
                        });

                    }
                };
            }
        ]
    );
})(softwrench);
;
(function (angular) {
    "use strict";

    angular.module("softwrench").directive("richTextField", [function () {
        const directive = {
            restrict: "E",
            templateUrl: getResourcePath("Content/Mobile/templates/directives/richtextfield.html"),
            replace: false,
            scope: {
                value: "=",
                readOnly: "=",
                maxLength: "=",
                isRequired: "="
            },

            controller: ["$scope", function ($scope) {
                $scope.config = {
                    options: {
                        toolbar: false,
                        statusbar: false,
                        debounce: true,
                        inline: false,
                        theme: "modern",
                        skin_url: "Content/Vendor/css/skins/lightgray",
                        content_css: "css/tinymce.css",
                        menubar: false,
                        readonly: $scope.readOnly,
                        // so it doesn't mess base64 images coming from the server
                        convert_urls: false,
                        urlconverter_callback: url => url 
                    }
                };
            }]

        };

        return directive;
    }]);

})(angular);;
(function (angular) {
    "use strict";

    angular.module("softwrench").directive("sideMenu", [function () {
        const directive = {
            restrict: "E",
            templateUrl: getResourcePath("Content/Mobile/templates/directives/sidemenu.html"),
            scope: {},

            controller: [
                "$scope", "menuModelService", "menuRouterService", "routeService", "$ionicSideMenuDelegate", "swAlertPopup", "$ionicPopup", "securityService", "synchronizationFacade", "networkConnectionService",
                function ($scope, menuModelService, menuRouterService, routeService, $ionicSideMenuDelegate, swAlertPopup, $ionicPopup, securityService, synchronizationFacade, networkConnectionService) {

                    $scope.vm = {
                        activeleaf: null
                    };


                    $scope.menuleafs = function () {
                        return menuModelService.getApplicationMenuItems();
                    };

                    $scope.isActive = function (leaf) {
                        

                        if (typeof leaf === 'string' || leaf instanceof String) {
                            if (!$scope.vm.activeleaf && leaf === "main.home") {
                                return true;
                            }

                            return $scope.vm.activeleaf === leaf;
                        }

                        return $scope.vm.activeleaf === leaf.id;
                    }

                    $scope.loadApplication = function ($event, menuleaf) {
                        menuRouterService.routeFromMenuItem(menuleaf)
                            .catch(e => swAlertPopup.show({ title: "Error", template: e.message }, 3000))
                            .finally(() => $ionicSideMenuDelegate.toggleLeft());

                        $event.stopImmediatePropagation();
                        $scope.vm.activeleaf = menuleaf.id;
                    };

                    $scope.loadAction = function (action) {
                        routeService.go(action);
                        $ionicSideMenuDelegate.toggleLeft();
                        $scope.vm.activeleaf = action;
                    };

                    $scope.adminMenuItems = function () {
                        return menuModelService.getAdminMenuItems();
                    };

                    $scope.userMenuItems = function () {
                        return menuModelService.getUserMenuItems();
                    };

                    $scope.getAppCount = function (menuId) {
                        return menuModelService.getAppCount(menuId);
                    }

                    //#region logout
                    function doLogout() {
                        return securityService.logout()
                            .then(() => true)
                            .catch(() => {
                                swAlertPopup.show({
                                    title: "Logout failed",
                                    template: "Unexpected logout error.<br>Please contact support."
                                }, 3000);
                                return false;
                            });
                    };

                    $scope.logout = function () {
                        synchronizationFacade.hasDataToSync()
                            .then(has => {
                                if (!has) {
                                    // no data to sync: just logout
                                    return doLogout();
                                }
                                // has data to sync
                                if (networkConnectionService.isOffline()) {
                                    // not online: no logout action will be executed
                                    swAlertPopup.show({
                                        title: "No internet connection detected",
                                        template: [
                                            "You still have data to synchronize",
                                            "Please connect to the internet to logout."
                                        ].join("<br>")
                                    }, 3000);
                                    return false;
                                }
                                // is online: prompt user for confirmation
                                return $ionicPopup.confirm({
                                    title: "Logout",
                                    template: [
                                        "A synchronization will be performed before the logout, but some data might be lost.",
                                        "A synchronization will be required after the next login.",
                                        "Are you sure you want to logout?"
                                    ].join(" ")
                                })
                                    .then(res => {
                                        // ok then sync before logging out, otherwise break promise chain
                                        return !res ? res : synchronizationFacade.attempSyncAndContinue({ template: "Do you wish to logout anyway?" });
                                    })
                                    .then(canlogout => {
                                        return !canlogout /* sync failed and user did not wish to continue */
                                            ? false
                                            /* sync sucessfull or sync failed and user wished to continue anyway */
                                            : doLogout();
                                    });
                            })
                            .then(didlogout => {
                                if (didlogout) {
                                    // logout was performed -> redirect to login screen
                                    routeService.go("login");
                                }
                            })
                            .finally(() => {
                                $ionicSideMenuDelegate.toggleLeft();
                            });
                    };
                    //#endregion
                }],
        };

        return directive;
    }]);

})(angular);;
(function (angular, $) {
    "use strict";

    angular.module("softwrench").directive("singleFileInput", [function () {
        const directive = {
            restrict: "E",
            templateUrl: getResourcePath("Content/Mobile/templates/directives/singlefileinput.html"),
            replace: false,
            scope: {
                datamap: "=",
                schema: "=",
                fieldName: "@"
                //field: "="
            },

            controller: ["$element", "$scope", "$timeout", "offlineSchemaService", "loadingService", function ($element, $scope, $timeout, offlineSchemaService, loadingService) {
                // can't get the field from the scope because it is a different cloned instance
                // have to get it through the schema
                $scope.model = { field: offlineSchemaService.getFieldByAttribute($scope.schema, $scope.fieldName) };

                const originalImagePreview = $scope.model.field.rendererParameters["showImagePreview"];

                const fileInput = $element[0].querySelector("input[type='file']");

                const changeListener = event => {
                    loadingService.showDefault();
                    const file = event.target.files[0];
                    const type = file.type;
                    const name = file.name;
                    const reader = new FileReader();
                    reader.onloadend = loadEvent =>
                        $timeout(() => {
                            $scope.datamap[$scope.fieldName] = loadEvent.target.result;
                            $scope.model.field.rendererParameters["showImagePreview"] = !!type && type.contains("image");
                            $scope.datamap["document"] = name;
                            $scope.datamap["newattachment_path"] = name;
                            $scope.datamap["#mimetype"] = type;
                        }).finally(() => loadingService.hide());

                    reader.readAsDataURL(file);
                };

                angular.element(fileInput).on("change", changeListener);
                $scope.$on("$destroy", function () {
                    angular.element(fileInput).off("change", changeListener);
                    $scope.model.field.rendererParameters["showImagePreview"] = originalImagePreview;
                });
            }]

        };

        return directive;
    }]);

})(angular, jQuery);;
(function(angular) {
    "use strict";

    angular.module("softwrench")
        .directive("swOperationIcon", [ function() {
            return {
                restrict: "E",
                templateUrl: getResourcePath("Content/Mobile/templates/directives/swoperationicon.html"),
                scope: {
                    operation: "=syncOperation"
                }
            }
        }]);

})(angular);;
(function (offlineMaximoApplications) {
    "use strict";

    function maximoDataService(dao, $q, $filter) {

        //#region Utils

        const capitalizer = $filter("capitalize");

        function loadEntries(application, field, value, list) {
            const method = list ? "findByQuery" : "findSingleByQuery";

            return dao[method]("DataEntry", `application='${application}' and datamap like '%"${field}":"${value}"%'`)
                .then(items => {
                    if (!items || (list && items.length <= 0)) {
                        return $q.reject(new Error(`${capitalizer(application)} with ${field} = ${value} not found`));
                    }
                    return items;
                });
        }

        //#endregion

        //#region Public methods

        /**
         * Finds the DataEntries matching the application and with field=value in their datamap.
         * 
         * @param {String} application 
         * @param {String} field
         * @param {Any} value 
         * @returns {Promise<Array<entities.DataEntry>>} resolved with the entry found, rejected with error if no entry is found. 
         */
        function loadItemsByField(application, field, value) {
            return loadEntries(application, field, value, true);
        }

        /**
         * Finds the DataEntry matching the application and with field=value in it's datamap.
         * 
         * @param {String} application 
         * @param {String} field
         * @param {Any} value 
         * @returns {Promise<entities.DataEntry>} resolved with the entry found, rejected with error if no entry is found. 
         */
        function loadSingleItemByField(application, field, value) {
            return loadEntries(application, field, value);
        }

        /**
         * Searches for the DataEntry with matching application and refId 
         * matching the entity's 'userId' which is determined by the schema's 'userIdFieldName'.
         * 
         * @param {String} application 
         * @param {Schema}
         * @param {String} refId 
         * @returns {Promise<entities.DataEntry>} resolved with the entry found, rejected with error if no entry is found.  
         */
        function loadItemByMaximoUid(application, schema, refId) {
            return loadSingleItemByField(application, schema.userIdFieldName, refId);
        }

        //#endregion

        //#region Service Instance
        const service = {
            loadItemsByField,
            loadSingleItemByField,
            loadItemByMaximoUid
        };
        return service;

        //#endregion
    }

    //#region Service registration
    offlineMaximoApplications.factory("maximoDataService", ["swdbDAO", "$q", "$filter", maximoDataService]);
    //#endregion

})(offlineMaximoApplications);
;

(function (offlineMaximoApplications) {
    "use strict";

    function workorderOfflineService() {

        //#region Utils

        //#endregion

        //#region Public methods

        function preSync(datamap,originaldatamap) {
//            datamap['reportdate'] = new Date();
            //            originaldatamap['reportdate'] = datamap['reportdate'];
            if (originaldatamap != null && datamap.status !== originaldatamap.status) {
                datamap["#hasstatuschange"] = true;
                datamap["#forcestatuschance"] = true;

            }
        }

        //#endregion

        //#region Service Instance

        var service = {
            preSync: preSync
        };

        return service;

        //#endregion
    }

    //#region Service registration

    offlineMaximoApplications.factory("workorderOfflineService", [workorderOfflineService]);

    //#endregion

})(offlineMaximoApplications);
;
(function(app) {
    "use strict";

    app.filter("capitalize", function () {
        return function(input) {
            if (!input) {
                return input;
            }
            input = input.toLowerCase();
            return input.substring(0, 1).toUpperCase() + input.substring(1);
        };
    });

})(softwrench);;
(function(app) {
    "use strict";

    app.filter("linebreak", function () {
        return function (value) {
            if (value != null) {
                value = value.toString();
                return value.replace(/\n/g, "<br/>");
            }
            return value;
        };
    });

})(softwrench);;
(function (angular, cordova, _) {
    "use strict";

    angular.module("softwrench").config(["$provide", function ($provide) {

        $provide.decorator("$cordovaEmailComposer", ["$delegate", "$q", function ($delegate, $q) {
            //#region Utils
            function getAvailableHandler(defer) {
                return function () {
                    // in some platforms (e.g. Android) the handler receives multiple boolean arguments instead of a single one
                    // here we will consider available if at least one argument is true
                    const available = _.contains(arguments, true);
                    if (available) {
                        defer.resolve(true);
                    } else {
                        // reject with a meaningful error
                        defer.reject(new Error("Email is not available in this device"));
                    }
                }
            }
            /**
             * Fixed isAvailable method: 
             * accounts for multiple return parameters from the plugin's native implementation.
             * 
             * @returns {Promise} 
             */
            function isAvailable() {
                const q = $q.defer();
                cordova.plugins.email.isAvailable(getAvailableHandler(q));
                return q.promise;
            }
            //#endregion

            //#region Decorator
            $delegate.isAvailable = isAvailable.bind($delegate);

            return $delegate;
            //#endregion
        }]);

    }]);

})(angular, cordova, _);;
(function (angular) {
    "use strict";

    angular.module("softwrench").config(["$provide", function ($provide) {

        function decorator($delegate, $window, $q, $cordovaFileError) {
            //#region Utils

            function toCordovaFileError(error) {
                error.message = $cordovaFileError[error.code] || error.message;
                return error;
            }

            /**
             * List all FileEntries in a directory.
             * 
             * @param {FilePath} path cordova file path (e.g. cordova.file.dataDirectory)
             * @param {String} dirName name of the directory (optional)
             * @returns {Promise<Array<FileEntry>>} fileentries in the directory
             */
            function listDir(path, dirName) {
                const q = $q.defer();
                const dirPath = path + (dirName ? dirName : "");
                try {
                    $window.resolveLocalFileSystemURL(dirPath,
                        fileSystem => {
                            const reader = fileSystem.createReader();
                            reader.readEntries(
                                entries => q.resolve(entries),
                                error => q.reject(toCordovaFileError(error))
                            );
                        },
                        error => q.reject(toCordovaFileError(error))
                    );

                } catch (e) {
                    q.reject(toCordovaFileError(e));
                }

                return q.promise;
            }
            //#endregion

            //#region Decorator

            // adding listDir method to $cordovaFile
            if (!angular.isFunction($delegate.listDir)) {
                $delegate.listDir = listDir.bind($delegate);
            }

            return $delegate;

            //#endregion
        };

        // #region Decorator Registration
        $provide.decorator("$cordovaFile", ["$delegate", "$window", "$q", "$cordovaFileError", decorator]);
        // #endregion
    }]);

})(angular);;
(function (angular, mobileServices, cordova) {
    "use strict";

    mobileServices.config(["$provide", function ($provide) {

        $provide.decorator("$exceptionHandler", ["$delegate", "$injector", "fileConstants", "rollingLogFileConstants", function ($delegate, $injector, fileConstants, rollingLogFileConstants) {

            var swAlertPopup, $log, logger, contextService, supportService, restService;

            function lazyInstance(instance, name, factory = $injector, getter = "get") {
                if (!instance) {
                    instance = factory[getter](name);
                }
                return instance;
            }

            function logFilePath() {
                const directory = cordova.file[fileConstants.appDirectory];
                const fileName = rollingLogFileConstants.logFileName;
                return directory + fileName;
            }

            function shouldAlertExceptionLogged(exception) {
                const message = angular.isString(exception) ? exception : exception.message;
                // only considered a worthwhile exception if has a message with more than 10 characters
                return !!message && message.length >= 10;
            }

            function alertLogLocation() {
                // getting around circular deps: $rootScope <- contextService <- $exceptionHandler <- $rootScop
                contextService = lazyInstance(contextService, "contextService");
                if (!fileConstants.fileEnabled || contextService.isDev()) {
                    return;
                }
                // getting around circular deps: $exceptionHandler <- $interpolate <- $compile <- $ionicTemplateLoader <- $ionicPopup <- swAlertPopup <- $exceptionHandler <- $rootScope
                swAlertPopup = lazyInstance(swAlertPopup, "swAlertPopup");

                const path = logFilePath();
                swAlertPopup.show({
                    title: "Unexpected error",
                    template: "Check the application logs in the files " + path
                }, 3000);
            }

            return function (exception, cause) {
                if ((exception && isString(exception) && exception.startsWith("Possibly unhandled rejection:")) || exception.notifyException === false) {
                    return;
                }



                // getting around circular deps: $rootScope <- contextService <- $exceptionHandler <- $rootScope
                $log = lazyInstance($log, "$log");
                swAlertPopup = lazyInstance(swAlertPopup, "swAlertPopup");
                logger = lazyInstance(logger, "$exceptionHandler", $log);
                // default behavior (from angular.js source): $log.error.apply($log, arguments);
                logger.error.apply(logger, arguments);
                // alerting log file location for support
                // if (shouldAlertExceptionLogged(exception)) alertLogLocation();
                supportService = lazyInstance(supportService, "supportService");
                const logReportObject = { subject: "Unexpected Error" };
                if (!!exception && !!exception.title) {
                    logReportObject.title = exception.title;
                }
                logReportObject.notifyException = exception.notifyException;
                logReportObject.requestSupportReport = exception.requestSupportReport;

                if (exception.type === "unreacheable") {
                    restService = lazyInstance(restService, "offlineRestService", restService);
                    return restService.get("SignIn", "Ping", {}, { timeout: 3000 })
                        .then(() => {
                            //if for some reason the ping url is available, then this was a false positive, we need to allow support request
                            supportService.requestLogReporting(logReportObject);
                        })
                        .catch(() => {
                            swAlertPopup.show({
                                title: exception.title,
                                template: "Server unreachable.<br> Please make sure the url in settings is correct and check your internet / vpn connection."
                            });
                        });
                }

                if (exception.requestSupportReport !== false) {
                    supportService.requestLogReporting(logReportObject);
                } else {
                    swAlertPopup.show({
                        title: exception.title,
                        template: exception.message
                    });
                }

            };

        }]);
    }]);


})(angular, mobileServices, cordova);;
(function (angular, mobileServices, _) {
    "use strict";

    /**
     * Decorates $log so that the messages are logged into a file.
     */
    mobileServices.config(["$provide", function ($provide) {

        $provide.decorator("$log", ["$delegate", "$injector", "rollingLogFileConstants", "fileConstants", function ($delegate, $injector, rollingLogFileConstants, fileConstants) {

            //#region Utils

            var $roll;

            /**
             * $roll config + internal state meta
             */
            const rollingLog = {
                enabled: fileConstants.fileEnabled,
                configured: false,
                started: false,
                config: {
                    logSize: rollingLogFileConstants.logFileSize,
                    eventBuffer: rollingLogFileConstants.eventBuffer,
                    writeOnPause: rollingLogFileConstants.writeOnPause,
                    console: rollingLogFileConstants.logToConsole,
                    debug: rollingLogFileConstants.debug,
                    prefix: rollingLogFileConstants.logFileName,
                    directory: fileConstants.appDirectory
                }
            }

            const logMethods = ["log", "info", "warn", "debug", "trace", "error"];

            const startRollingLogService = ionic.debounce(function () {
                // deboucing as workaround to the fact that $roll.start is async:
                // multiple $roll.starts called before setting rollingLog.started = true
                // debounce makes all those calls 'turn into' a single one (debounce time determined empirically)
                if (!rollingLog.started) {
                    $roll.start()
                        .then(() => rollingLog.started = true)
                        .catch(error => console.error("Couldn't start file logger", error));
                }
            }, 100);

            /**
            * Injects $roll instance and bootstraps it with the default configuration.
            */
            function initRollingLog() {
                if (!rollingLog.enabled) {
                    return;
                }

                // getting around circular deps: $rootScope <- $q <- $roll <- $log <- $exceptionHandler <- $rootScope
                if (!$roll) $roll = $injector.get("$roll");

                if (!rollingLog.configured) {
                    $roll.setConfig(rollingLog.config);
                }
                startRollingLogService();
            }

            /**
             * Logs args to file if the level is enabled.
             * 
             * @param {String} level 
             * @param {Array<Object>} args 
             */
            function logToFile(level, args) {
                if (!rollingLog.enabled || !rollingLog.started) return;
                $roll[level].apply($roll, args);
            }

            const isLoggingMethod = name => _.contains(logMethods, name);


            /**
             * Enhances the logger's method by logging it's arguments to 
             * a rolling log file using $roll service.
             * 
             * @param Function method a logger's logging method
             * @param String methodName logging method's name
             * @param {$log#get} logger instance of a logger service
             */
            function enhanceLoggingMethod(method, methodName, logger) {
                // needs the method reference because if the method is retrieved by name at this point 
                // it leads to a stackoverflow being thrown (infinite recursion enhancing it)
                return function () {
                    const args = [].slice.call(arguments);
                    const logs = method.apply(logger, args);
                    // only log to file if enabled
                    if (logger.isLevelEnabled(methodName) && !!logs && logs.length > 0) {
                        logToFile(methodName, logs);
                    }
                    return logs;
                }
            }

            /**
             * Enhances all of the logger's logging methods.
             * 
             * @param {$log#get} logger instance of a logger service
             */
            function enhanceLogger(logger) {
                for (let method in logger) {
                    if (!logger.hasOwnProperty(method) || !angular.isFunction(logger[method]) || !isLoggingMethod(method)) continue;
                    logger[method] = enhanceLoggingMethod(logger[method], method, logger);
                }
            }

            //#endregion

            //#region Decorator

            var getInstance = $delegate.getInstance;
            let contextService = null;

            // to improve performance - sessionStorage["loglevel"] is called thousands of times
            if (sessionStorage.loglevel) {
                window.loglevel = sessionStorage.loglevel;
            }

            const descriptor = Object.getOwnPropertyDescriptor(sessionStorage, "loglevel");
            if (!descriptor || descriptor.configurable === true) {
                Object.defineProperty(sessionStorage, "loglevel", {
                    set: (value) => window.loglevel = value,
                    get: () => window.loglevel
                }, { enumerable: true, writable: true, configurable: true });
            }

            function globalLogLevel() {
                if (!window.loglevel) {
                    if (!contextService) {
                        contextService = $injector.get("contextService");
                    }
                    window.loglevel = contextService.retrieveFromContext("defaultlevel") || "warn";
                }
                return window.loglevel;
            }

            const logCache = {};

            $delegate.getInstance = function () {
                if (!arguments[1] || arguments[1].indexOf("angular") === -1) {
                    //prevent initing the rolling logs for log calls that are specific to angular initialization logic, and would possibly trigger a circular dependency
                    //letÂ´s init it later
                    initRollingLog();
                }

                const level = globalLogLevel();
                if (!logCache[level]) {
                    logCache[level] = {}
                }
                const cacheKey = arguments[0] + "#" + arguments[1];
                if (logCache[level][cacheKey]) {
                    return logCache[level][cacheKey];
                }

                const args = [].slice.call(arguments);
                const instance = getInstance.apply($delegate, args);
                enhanceLogger(instance);
                logCache[level][cacheKey] = instance;
                return instance;
            }

            return $delegate;
            //#endregion
        }]);

    }]);


})(angular, mobileServices, _);;
(function (angular) {
    "use strict";

    angular.module("sw_mobile_services").config(["$provide", function ($provide) {

        $provide.decorator("$q", ["$delegate", function ($delegate) {

            var originalDefer = $delegate.defer;

            $delegate.defer = function () {
                // Get the prototype of the promise
                const promiseProto = originalDefer().promise.constructor.prototype;

                // Add the spread method
                Object.defineProperty(promiseProto, "spread", {
                    value: function (resolve, reject) {
                        function spread(data) {
                            return resolve.apply(void 0, data);
                        }

                        return this.then(spread, reject);
                    },
                    writable: true,
                    enumerable: false
                });

                return originalDefer();
            };

            return $delegate;
        }]);
    }]);

})(angular);;

(function (angular) {
    "use strict";

    class indexCreatorService {

        constructor(swdbDAO, $log, loadingService) {
            this.swdbDAO = swdbDAO;
            this.$log = $log;
            this.loadingService = loadingService;
        }

        createIndexAfterFirstSync() {

            const queries = [];
            const log = this.$log.get("indexCreatorService#createIndexAfterFirstSync", ["persistence"]);

            
            if (isRippleEmulator()) {
                return;
            }
            log.info("creating sql indexes");
            this.loadingService.show("Applying Indexes");

            queries.push(this.swdbDAO.addIndexQuery("DataEntry", "textindex01", false));
            queries.push(this.swdbDAO.addIndexQuery("DataEntry", "textindex02", false));
//
            queries.push(this.swdbDAO.addIndexQuery("DataEntry", "dateindex01", false));
            queries.push(this.swdbDAO.addIndexQuery("DataEntry", ["application", "remoteid"], true));
//
            queries.push(this.swdbDAO.addIndexQuery("AssociationData", "textindex01", false));
            queries.push(this.swdbDAO.addIndexQuery("AssociationData", "textindex02", false));
//
            queries.push(this.swdbDAO.addIndexQuery("AssociationData", ["application", "textindex01"], false));


            this.swdbDAO.executeQueries(queries).then(r => {
                log.info("sql indexes created successfully");
                this.loadingService.hide();
            });
        }

        dropIndexes() {

            const log = this.$log.get("indexCreatorService#dropIndexes",["persistence"]);

            if (isRippleEmulator()) {
                return;
            }

            log.info("dropping sql indexes");

            this.swdbDAO.dropIndex("DataEntry", "textindex01");
            this.swdbDAO.dropIndex("DataEntry", "textindex02");


            this.swdbDAO.dropIndex("DataEntry", "dateindex01");

            this.swdbDAO.dropIndex("AssociationData", "textindex01");
            this.swdbDAO.dropIndex("AssociationData", "textindex02");
            this.swdbDAO.dropIndex("AssociationData", ["application", "textindex01"]);
            this.swdbDAO.dropIndex("DataEntry", ["application", "remoteid"]);

            log.info("sql indexes dropped successfully");

        }

    }


    indexCreatorService["$inject"] = ["swdbDAO", "$log", "loadingService"];

    angular.module("persistence.offline").service("indexCreatorService", indexCreatorService);

})(angular);


(function (angular) {
    "use strict";

    try {
        angular.module("persistence.offline");
    } catch (err) {
        return;
    }

    //#region audit.offline migrations
    angular.module("persistence.offline").config(["offlineMigrationsProvider", function (offlineMigrationsProvider) {
        const migrationGroup = offlineMigrationsProvider.createMigrationGroup(15, "index migrations");

        //        migrationGroup.addMigration("Data Entry Indexes", {
        //            up: function () {
        //                this.addIndex("DataEntry", "textindex01",false);
        //                this.addIndex("DataEntry", "textindex02",false);
        //                
        //                this.addIndex("DataEntry", "numericindex01", false);
        //                this.addIndex("DataEntry", "numericindex02", false);
        //
        //                this.addIndex("DataEntry", "dateindex01", false);
        //                
        //                this.addIndex("AssociationData", "textindex01", false);
        //                this.addIndex("AssociationData", "textindex02", false);
        //
        //                this.addIndex("AssociationData", ["application","textindex01"], false);
        //
        //            },
        //            down: function () {
//                        this.removeIndex("DataEntry", "textindex01");
        //                this.removeIndex("DataEntry", "textindex02");
        //                this.removeIndex("DataEntry", "textindex03");
        //                this.removeIndex("DataEntry", "textindex04");
        //                this.removeIndex("DataEntry", "textindex05");
        //
        //                this.removeIndex("DataEntry", "numericindex01");
        //                this.removeIndex("DataEntry", "numericindex02");
        //
        //                this.removeIndex("DataEntry", "dateindex01");
        //                this.removeIndex("DataEntry", "dateindex02");
        //                this.removeIndex("DataEntry", "dateindex03");
        //
        //                this.removeIndex("AssociationData", "textindex01");
        //                this.removeIndex("AssociationData", "textindex02");
        //
        //                this.removeIndex("AssociationData", "dateindex01");
        //                this.removeIndex("AssociationData", "dateindex02");
        //                this.removeIndex("AssociationData", "dateindex03");
        //            }
        //        });
    }]);
    //#endregion



})(angular);;
(function (angular, _) {
    "use strict";

    function paeAssetService(scanningCommonsService, $log, crudContextService, audit, $ionicPopup, maximoDataService, dao, offlineSaveService, securityService, $q) {
        //#region Utils
        const config = {
            /** holds previously scanned VIN code when scanning assets by ASSSETNUM */
            vin: null,
            /** flag indicates whether or not to find the scanned assets by VIN (the other otpion is by ASSSETNUM) */
            vinMode: true,

            codes: {
                ignore: "CODE_IGNORE_ERROR"
            }
        };

        function scanBySerialnum(serialnum) {
            serialnum = serialnum.slice(-12);

            return maximoDataService.loadSingleItemByField("transportation", "serialnum", serialnum)
                .catch(error => {
                    const confirm = $ionicPopup.confirm({
                        title: "Transportation Asset Scan",
                        template: `VIN/SN ${serialnum} not found.<br>Would you like to scan using the asset?`
                    });
                    return confirm.then(res => {
                        if (!res) {
                            return $q.reject({ code: config.codes.ignore });
                        }
                        // prepare 'scan by assetnum' mode
                        config.vin = serialnum;
                        config.vinMode = false;
                        return $q.reject({ code: config.codes.ignore });
                    });
                });
        }

        function scanByAssetnum(assetnum, schema) {
            return maximoDataService.loadItemByMaximoUid("transportation", schema, assetnum)
                .then(asset => {
                    asset.datamap["serialnum"] = config.vin;
                    return asset;
                })
                .finally(() => {
                    // restore original mode
                    config.vin = null;
                    config.vinMode = true;
                });
        }

        function auditAndOpenDetail(promise, application, scanData) {
            return promise
                // register scan audit event
                .then(asset =>
                    audit.registerEvent("scan", application, asset.id, asset.remoteId, scanData).then(entry => asset)
                )
                // refresh grid (reflect detail changes) and redirect to asset detail
                .then(asset => crudContextService.refreshGrid().then(() => asset))
                .then(asset => crudContextService.loadDetail(asset))
                // alert error
                .catch(error => {
                    // user action interrupted operation
                    if (error && error.code === config.codes.ignore) return;

                    $log.get("paeAssetService#initScanEventListener", ["scan"]).error(error);
                    $ionicPopup.alert({ title: error.message });
                });
        }

        function initScanEventListener(schema, parameters) {
            scanningCommonsService.registerScanCallBackOnSchema(parameters, function (data) {

                const promise = maximoDataService.loadItemByMaximoUid("asset", schema, data).then(asset => {
                    asset.isDirty = true;
                    return offlineSaveService.saveItem("asset", asset, "Asset", false);
                });

                auditAndOpenDetail(promise, "asset", data);
            });
        }

        function markAsScanned(datamap) {
            const asset = crudContextService.currentDetailItem();
            const personId = securityService.currentFullUser()["PersonId"];
            const now = new Date();
            asset.isDirty = true;
            asset.datamap["invposttype"] = "AUTOMATIC";
            asset.datamap["invpostdateby"] = personId;
            asset.datamap["changeby"] = personId;
            asset.datamap["invpostdate"] = now;
            asset.datamap["changedate"] = now;
            asset.datamap["scanremarks"] = "No Scan Remarks Entered";

            return offlineSaveService.saveItem("transportation", asset, "Transportation", false);
        }

        function initTransportationScanEventListener(schema, parameters) {
            scanningCommonsService.registerScanCallBackOnSchema(parameters, function (data) {

                // scan according to mode
                const scanPromise = config.vinMode ? scanBySerialnum(data) : scanByAssetnum(data, schema);

                // common scan chain
                const promise = scanPromise.then(asset => {
                    // update asset
                    const personId = securityService.currentFullUser()["PersonId"];
                    const now = new Date();
                    asset.isDirty = true;
                    asset.datamap["invposttype"] = "AUTOMATIC";
                    asset.datamap["invpostdateby"] = personId;
                    asset.datamap["changeby"] = personId;
                    asset.datamap["invpostdate"] = now;
                    asset.datamap["changedate"] = now;
                    asset.datamap["scanremarks"] = "No Scan Remarks Entered";

                    return offlineSaveService.saveItem("transportation", asset, "Transportation", false);
                });

                auditAndOpenDetail(promise, "transportation", data);
            });
        }

        //#endregion

        //#region Public methods

        function preSync(datamap, originaldatamap) {
            datamap["#originallocation"] = datamap["location"];
        }

        function initAssetDetailListener(scope, schema, datamap, parameters) {
            initScanEventListener(schema, parameters);
        }

        function initAssetGridListener(scope, schema, datamap, parameters) {
            initScanEventListener(schema, parameters);
        }

        function initTransportationDetailListener(scope, schema, datamap, parameters) {
            initTransportationScanEventListener(schema, parameters);
        }

        function initTransportationGridListener(scope, schema, datamap, parameters) {
            initTransportationScanEventListener(schema, parameters);
        }

        function transportationAssetChanged(schema, datamap) {
            const user = securityService.currentFullUser();
            datamap["changeby"] = user["PersonId"];
            datamap["changedate"] = new Date();
        }

        //#endregion

        //#region Service Instance
        const service = {
            initAssetDetailListener,
            initAssetGridListener,
            initTransportationDetailListener,
            initTransportationGridListener,
            markAsScanned,
            preSync,
            transportationAssetChanged,
            
        };
        return service;
        //#endregion
    }

    //#region Service registration

    angular.module("maximo_offlineapplications")
        .service("paeAssetService", [
            "scanningCommonsService", "$log", "crudContextService", "offlineAuditService", "$ionicPopup", "maximoDataService", "swdbDAO", "offlineSaveService", "securityService", "$q", paeAssetService
        ]);

    //#endregion



})(angular, _);
;
(function (angular) {
    'use strict';

    var buildIdsString = function (deletedRecordIds) {
        var ids = [];
        angular.forEach(deletedRecordIds, function (id) {
            ids.push("'{0}'".format(id));
        });
        return ids;
    };

    class fsDataSyncHook {

        

        constructor(searchIndexService, offlineEntities,fsLaborOfflineService) {
            this.searchIndexService = searchIndexService;
            this.entities = offlineEntities;
            this.fsLaborOfflineService = fsLaborOfflineService;
        }

        modifyQueries(result, queryArray) {

            //combining all arrays into one (several compositions, one per each type of workorder)
            const labtransEntries = 
                _.chain(result.compositionData)
                .filter(c => c.applicationName === "labtrans_")
                .pluck("newdataMaps")
                .flatten()
                .value();

            if (labtransEntries.length > 0) {
                const application = result.compositionData.find(c => c.applicationName === "labtrans_")
                const syncedwos = new Set();
                labtransEntries.forEach(element => {
                    const toInsertObj = this.fsLaborOfflineService.generateTsLaborDataEntryQuery(element);
                    queryArray.push(toInsertObj.query);
                    syncedwos.add(toInsertObj.wonum)
                });
                const ids = buildIdsString(Array.from(syncedwos));
                queryArray.push({query: "delete from DataEntry where application = 'tslabor' and rowstamp is null and textindex02 in ({0})".format(ids)});
            }
            

            return null;
        }

    }


    fsDataSyncHook['$inject'] = ["searchIndexService", "offlineEntities", "fsLaborOfflineService"];

    angular.module('sw_mobile_services').service('firstsolar.dataSynchronizationHook', fsDataSyncHook);

})(angular);;

(function (angular) {
    "use strict";

    const day = 24 * 60 * 60 * 1000;

    class fsLaborMobileService {

        constructor($rootScope,securityService, searchIndexService, offlineEntities, swdbDAO) {
            this.$rootScope = $rootScope;
            this.securityService = securityService;
            this.searchIndexService = searchIndexService;
            this.entities = offlineEntities;
            this.dao = swdbDAO;

            this.$rootScope.$on("sw_itemrestored",(event,item)=>{
                swdbDAO.executeQuery({query:"delete from DataEntry where application = 'tslabor' and textindex02 = ? and rowstamp is null",args:[item.datamap.wonum] })
            })

        }


        laborCode() {
            const user = this.securityService.currentFullUser();
            if (user == null) {
                return this.securityService.logout();
            }
            return user.properties["laborcode"];
        }

        //#region Menu whereclauses
        // `assignment_`.dateindex01 = scheduled date without time
        getCurrentWeekLaborsWhereClause() {
            const now = new Date();

            const first = now.getDate() - now.getDay(); // First day is the day of the month - the day of the week
            const last = first + 6; // last day is the first day + 6

            const firstday = new Date(now.setDate(first)).getTime();
            const lastday = new Date(now.setDate(last)).getTime();

            const laborcode = this.laborCode();
            //testinga

            return "`root`.dateindex01 >= {0} and `root`.dateindex01 < {1} and `root`.textindex01 = '{2}'".format(firstday, lastday, laborcode);
        }

        getCurrentMonthLaborsWhereClause() {
            const now = new Date();

            const beginOfMonth = new Date(now.getFullYear(), now.getMonth(), 1, 0, 0, 0).getTime();
            const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1, 0, 0, 0).getTime();

            const laborcode = this.laborCode();

            return "`root`.dateindex01 >= {0} and `root`.dateindex01 < {1} and `root`.textindex01 = '{2}'".format(beginOfMonth, endOfMonth, laborcode);
        }

        generateTsLaborDataEntryQuery(compositionData, runningLabor = false) {
            const isLocal = !compositionData.id;
            const id = persistence.createUUID();
            let remoteId = compositionData.id
            //storing local id as the remoteid for local created entries
            let rowstamp = compositionData.approwstamp;
            if (isLocal){
                //this first flag will control when we should show a running labor icon or not
                compositionData["#runninglabor"] = runningLabor;
                //using this so that replace or insert works for locally created entries
                remoteId = !!compositionData["#localswdbid"] ? compositionData["#localswdbid"]: id;
                rowstamp = null;
            }

            
            const newJson = compositionData.jsonFields || JSON.stringify(compositionData); //keeping backwards compatibility //newJson = datamapSanitizationService.sanitize(newJson);
            const datamap = compositionData.jsonFields ? JSON.parse(compositionData.jsonFields) : compositionData; //keeping backwards compatibility //newJson = 
            //TODO: bring indexes from metadata... right now they are hardcoded here
            const idx = this.searchIndexService.buildIndexes(['laborcode','refwo'], [], ['enterdate'], datamap);
            const query = this.entities.DataEntry.insertOrReplacePattern;

            const insertOrUpdateQuery = { query, args: ["tslabor", newJson, remoteId, rowstamp, id, idx.t1, idx.t2, idx.t3, idx.t4, idx.t5, idx.n1, idx.n2, idx.d1, idx.d2, idx.d3] };


            return {query:insertOrUpdateQuery, wonum: datamap["refwo"]};
        }

        insertTsLaborDataEntry(compositionData, runningLabor) {
            const query = this.generateTsLaborDataEntryQuery(compositionData, runningLabor).query;
            return this.dao.executeQuery(query);
        }


    }


    fsLaborMobileService["$inject"] = ["$rootScope","securityService", "searchIndexService", "offlineEntities", "swdbDAO"];

    angular.module("sw_mobile_services").service("fsLaborOfflineService", fsLaborMobileService);

})(angular);;

(function (angular, _) {
    "use strict";

    const day = 24 * 60 * 60 * 1000;

    //#region WhereClauses
    // textindex04 = location of the wo
    const locationsOfAssignedWos = "select textindex04 from DataEntry where application like '%workorder' and textindex04 is not null";

    // textindex01 = location of locancestor
    // textindex02 = ancestor of locancestor
    const childLocationOfAssignedWos = `select textindex01 from associationdata where application = 'locancestor' and textindex02 in (${locationsOfAssignedWos})`;

    // textindex01 = location of location
    const preferredLocations = `textindex01 in (${locationsOfAssignedWos}) or textindex01 in (${childLocationOfAssignedWos})`;


    // textindex01 = location of locancestor
    // textindex02 = ancestor of locancestor
    const childLocationsOfGivenLocation = "select textindex01 from associationdata where application = 'locancestor' and textindex02 = @location";

    // textindex01 = location of asset
    const assetsWithLocationEqualOrDescendant = `textindex01 = @location or textindex01 in (${childLocationsOfGivenLocation})`;

    class fsWorkorderOfflineService {

        constructor($q, crudContextService, swdbDAO, $timeout, securityService, offlineSchemaService, $log) {
            this.$q = $q;
            this.crudContextService = crudContextService;
            this.dao = swdbDAO;
            this.$timeout = $timeout;
            this.securityService = securityService;
            this.offlineSchemaService = offlineSchemaService;
            this.$log = $log;
        }


        //afterchange
        afterFailureChanged() {
            const dm = this.crudContextService.currentDetailItemDataMap();
            if (dm["problemcode"] != null) {
                dm["problemcode"] = "null$ignorewatch";
            }
            if (dm["fr1code"] != null) {
                dm["fr1code"] = "null$ignorewatch";
            }
            if (dm["fr2code"] != null) {
                dm["fr2code"] = "null$ignorewatch";
            }
        }


        //afterchange
        afterProblemChanged() {
            const dm = this.crudContextService.currentDetailItemDataMap();
            if (dm["fr1code"] != null) {
                dm["fr1code"] = "null$ignorewatch";
            }
            if (dm["fr2code"] != null) {
                dm["fr2code"] = "null$ignorewatch";
            }
        }

        //afterchange
        afterCauseChanged() {
            const dm = this.crudContextService.currentDetailItemDataMap();
            if (dm["fr2code"] != null) {
                dm["fr2code"] = "null$ignorewatch";
            }
        }
        //afterchange
        afterRemedyChanged() {

        }

        //afterchange --> asset selected
        updateLocation(event) {
            const datamap = event.datamap;

            const asset = datamap["assetnum"];
            if (!asset || (angular.isArray(asset) && asset.length === 0)) {
                return this.$q.when();
            }

            const location = datamap["offlineasset_.location"];
            const failurecode = datamap["offlineasset_.failurecode"];
            datamap["location"] = `${location}$ignorewatch`;
            datamap["failurecode"] = failurecode;
            if (!!failurecode) {
                return this.dao.findSingleByQuery("AssociationData", `textindex01='${failurecode}' and application = 'failurelistonly'`).then(result => {
                    datamap["failurelistonly_.failurelist"] = result.datamap.failurelist;
                });
            }


        }
        //afterchange
        clearAsset(event) {
            const datamap = event.datamap;
            datamap["assetnum"] = "null$ignorewatch";
        }

        onDetailLoad() {
            const log = this.$log.get("fsWorkorderOfflineService#onDetailLoad", ["crud", "detail"]);
            const item = this.crudContextService.currentDetailItem();
            const dm = item.datamap;

            const problemData = dm["problemlist"];
            const causeData = dm["fr1list"];
            const failurelist = dm["failurelist"];

            if (!!problemData) {
                dm["offlineproblemlist_.failurelist"] = problemData;
            }

            if (!!failurelist) {
                dm["failurelistonly_.failurelist"] = failurelist;
            }

            if (!!causeData) {
                dm["offlinecauselist_.failurelist"] = causeData;
            }
            log.debug("setting failurelist ids");

        }

        onNewDetailLoad(scope, schema, datamap) {
            var offlineSchemaService = this.offlineSchemaService;
            var $timeout = this.$timeout;

            // defaults origination to 'Field Analysis'
            this.dao.findSingleByQuery("AssociationData", `application='classstructure' and datamap like '%"description":"Field Analysis"%'`)
                .then(a => {
                    if (!a || !a.datamap || !a.datamap.classstructureid) {
                        return;
                    }
                    const id = a.datamap.classstructureid;
                    const description = a.datamap.description;
                    datamap["classstructureid"] = id;
                    // setting just the viewValue to show description
                    // TODO: make $formatters do their job correctly
                    // TODO: load association descriptions correctly, similar to online mode
                    const input = document.querySelector("textarea[ion-autocomplete][item-value-key='datamap.classstructureid']");
                    const originationField = offlineSchemaService.getFieldByAttribute(schema, "classstructureid");
                    const showId = !_.contains([false, "false", "False", 0, "0"], originationField.rendererParameters["showCode"]);

                    if (!input) {
                        return;
                    }
                    $timeout(() => {
                        const $ngModel = angular.element(input).controller("ngModel");
                        $ngModel.$viewValue = showId ? `${id} - ${description}` : description;
                        $ngModel.$render();
                    });
                });
        }

        /**
         * Moves current item to 'workorder' application. 
         * 
         * @param {Schema} schema 
         * @param {Datamap} datamap 
         * @returns {Promise<entities.DataEntry>} 
         */
        assignWorkOrder(schema, datamap) {
            var crudContextService = this.crudContextService;
            var $timeout = this.$timeout;
            // const user = securityService.currentFullUser();
            const item = crudContextService.currentDetailItem();
            // datamap["owner"] = user["PersonId"];
            item["application"] = "workorder";
            return this.crudContextService.saveChanges()
                .then(saved =>
                    // TODO: set list model (in the crud context) and list view (in the history stack) manually so screen transition is not so agravating
                    crudContextService.loadApplicationGrid("workorder", "list")
                        // $timeout required so list controller has time to get and dispose it's viewmodel
                        .then(() => $timeout(() => crudContextService.loadDetail(saved), 0, false))
                );
        }


        getLocationsWhereClause() {
            return preferredLocations;
        }




        getAssetWhereClause() {
            return assetsWithLocationEqualOrDescendant;
        }

        getFacilityFilterWhereClause(option) {
            const facilities = option.split(",");
            const terms = [];
            angular.forEach(facilities, facility => {
                const trimmed = facility.trim();
                if (!trimmed) {
                    return;
                }

                // textindex04 = location of the wo
                terms.push(`root.textindex04 like '${trimmed}%'`);
            });

            return `(${terms.join(" or ")})`;
        }

        //#region Filter providers
        getFacilityFilterOptions() {
            const options = [];

            const user = this.securityService.currentFullUser();
            if (!user) {
                return options;
            }

            const props = user.properties;
            if (!props) {
                return options;
            }

            const facilities = props["sync.facilities"];
            if (!facilities) {
                return options;
            }

            angular.forEach(facilities.sort(), facility => {
                const option = { value: facility };
                option.label = option.value;
                option.text = option.value;
                options.push(option);
            });

            return options;
        }
        //#endregion

        laborCode() {
            const user = this.securityService.currentFullUser();
            if (user == null) {
                return this.securityService.logout();
            }
            return user.properties["laborcode"];
        }

        //#region Menu whereclauses
        // `assignment_`.dateindex01 = scheduled date without time
        getTodayWosWhereClause() {
            const now = new Date();
            const todayTime = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0).getTime();
            const tomorrowTime = todayTime + day;
            const laborcode = this.laborCode();

            return `assignment_.dateindex01 >= ${todayTime} and assignment_.dateindex01 < ${tomorrowTime} and assignment_.textindex02 = '${laborcode}'`;
        }

        getBaseWhereClause() {
            const laborcode = this.laborCode();
            return `assignment_.textindex02 = '${laborcode}'`;
        }

        // `assignment_`.dateindex01 = scheduled date without time
        getPastWosWhereClause() {
            const now = new Date();
            const todayTime = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0).getTime();
            const laborcode = this.laborCode();
            return `assignment_.dateindex01 < ${todayTime} and assignment_.textindex02 = '${laborcode}'`;
        }

        // `assignment_`.dateindex01 = scheduled date without time
        getFutureWosWhereClause() {
            const now = new Date();
            const tomorrowTime = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0).getTime() + day;
            const laborcode = this.laborCode();
            return `assignment_.dateindex01 >= ${tomorrowTime} and assignment_.textindex02 = '${laborcode}'`;
        }

        getCreatedWosWhereClause() {
            return "`root`.remoteId is null";
        }
        //#endregion
    }


    fsWorkorderOfflineService["$inject"] = ["$q", "crudContextService", "swdbDAO", "$timeout", "securityService", "offlineSchemaService", "$log"];

    angular.module("maximo_offlineapplications").service("fsWorkorderOfflineService", fsWorkorderOfflineService);

})(angular, _);
;
(function (angular) {
    "use strict";

    angular.module("softwrench").controller("FsLocationDrillDownController", ["$rootScope", "$scope", "$timeout", "$ionicHistory", "drillDownService", "crudContextService", "swdbDAO", function ($rootScope, $scope, $timeout, $ionicHistory, drillDownService, crudContextService, swdbDAO) {
        $scope.buildLocationTitle = function (location) {
            if (!location) {
                return "";
            }
            const datamap = location.datamap;
            return datamap.description ? `${datamap.location} - ${datamap.description}` : datamap.location;
        }

        $scope.buildAssetTitle = function (asset) {
            if (!asset) {
                return "";
            }
            const datamap = asset.datamap;
            return datamap.description ? `${datamap.assetnum} - ${datamap.description}` : datamap.assetnum;
        }

        $scope.locationClick = function (location) {
            drillDownService.locationDrillDownClick(location);
        }

        $scope.locationTitle = function () {
            return $scope.buildLocationTitle($scope.drillDown.selectedLocation);
        }

        $scope.locationSubTitle = function () {
            const dd = $scope.drillDown;
            const locationsTitle = `${dd.locationsCount} ${dd.locationsCount === 1 ? "sublocation" : "sublocations"}`;
            const assetsTitle = `${dd.assetsCount} ${dd.assetsCount === 1 ? "asset" : "assets"}`;
            return `${locationsTitle} - ${assetsTitle}`;
        }

        $scope.noChildLocations = function () {
            return ($scope.drillDown.locations ? $scope.drillDown.locations.length : 0) === 0;
        }

        $scope.assetsSubTitle = function () {
            const dd = $scope.drillDown;
            return `${dd.assetsCount} ${dd.assetsCount === 1 ? "asset" : "assets"}`;
        }

        $scope.noAssetsTitle = function () {
            const dd = $scope.drillDown;
            const location = dd.selectedLocation;
            const locationTerm = location ? ` on location ${$scope.buildLocationTitle(location)}` : "";
            const childTerm = dd.childAssetsView ? " children's" : "";
            return `No${childTerm} assets were found${locationTerm}.`;
        }

        $scope.noAssets = function () {
            return ($scope.drillDown.assets ? $scope.drillDown.assets.length : 0) === 0;
        }

        $scope.assetClick = function (asset) {
            const datamap = crudContextService.currentDetailItemDataMap();
            datamap.assetnum = asset.datamap.assetnum;
            datamap.location = asset.datamap.location;
            const failurecode = asset.datamap.failurecode;
            datamap["failurecode"] = failurecode;
            if (!!failurecode) {
                return swdbDAO.findSingleByQuery("AssociationData", `textindex01='${failurecode}' and application = 'failurelistonly'`).then(result => {
                    datamap["failurelistonly_.failurelist"] = result.datamap.failurelist;
                    $timeout(() => {
                        $ionicHistory.goBack();
                        $timeout(() => {
                            //this inner timeout is needed because we need the ionautocompletes, which have the $on listeners, to be back on the screen in order to handle the event
                            $rootScope.$broadcast("sw:association:resolved", {
                                failurelistonly_: {
                                    associationKey: "failurelistonly_",
                                    item: result
                                }
                            });        
                        },200,false);
                    }, 0, false);
                    
                });
            }

            //            datamap.failurecode = asset.datamap.failurecode;
            $timeout(() => $ionicHistory.goBack(), 0, false);
        }

        $scope.loadMore = function () {
            drillDownService.loadMore();
        }

        drillDownService.drillDownClear();
        $scope.drillDown = drillDownService.getDrillDown();

        $scope.$watch("drillDown.locationQuery", function () {
            if (!$scope.drillDown.assetView) {
                $timeout(() => drillDownService.updateDrillDownLocations(), 0, false);
            }
        });

        $scope.$watch("drillDown.assetQuery", function () {
            if ($scope.drillDown.assetView) {
                $timeout(() => drillDownService.updateDrillDownAssets(), 0, false);
            }
        });
    }]);

    angular.module("softwrench").directive("locationDrillDown", [function () {
        const directive = {
            restrict: "E",
            template: "<div ng-if='!context.currentDetailItem.datamap.assetnum'><button class='button button-calm button-block search-clear-button' ng-click='openDrillDown()' style='margin-bottom: 0px;'>Drill Down</button></div>" +
            "<textarea autosize-textarea wrap='hard' ng-model='description' ng-if='context.currentDetailItem.datamap.assetnum' ng-click='openDrillDown()' ng-readonly='true' style='cursor: pointer; color: black;'/>",
            transclude: false,
            replace: false,
            scope: {
            },
            controller: ["$rootScope", "$scope", "routeService", "drillDownService", "crudContextService", function ($rootScope, $scope, routeService, drillDownService, crudContextService) {
                $scope.openDrillDown = function () {
                    routeService.go("main.cruddetail.locationdrilldown");
                }

                $scope.context = crudContextService.getCrudContext();

                $scope.$watch("context.currentDetailItem.datamap.assetnum", function (assetNum) {
                    $scope.description = "";
                    if (!assetNum) {
                        return;
                    }
                    drillDownService.findAsset(assetNum).then((asset) => {
                        if (!asset) {
                            return;
                        }
                        const datamap = asset.datamap;
                        $scope.description = datamap.description ? datamap.assetnum + " - " + datamap.description : datamap.assetnum;
                    });
                });
            }]
        };

        return directive;
    }]);
})(angular);;
(function (angular) {
    "use strict";
    
    angular.module("softwrench").config(["$stateProvider", function($stateProvider) {

        $stateProvider
            .state("main.firstsolar", { // entry-point state for FS's custom states
                'abstract': true,
                url: "/firstsolar"
            })
            .state("main.firstsolar.userprofile", {
                url: "/myprofile",
                cache: false, // can't cache otherwise the updated profile is not fetched
                views: {
                    "main@main": {
                        templateUrl: "Content/Customers/templates/firstsolar_offline/templates/userprofile.html",
                        controller: "fsUserProfile"
                    }
                }
            });

    }]);

})(angular);;
(function (angular) {
    "use strict";

    angular.module("softwrench").controller("fsUserProfile", ["$scope", "fsUserProfileService", "routeService", "$ionicPopup", function ($scope, fsUserProfileService, routeService, $ionicPopup) {

        function init() {
            const current = fsUserProfileService.getUserProfileViewModel();

            $scope.profile = {
                original: angular.copy(current),
                current: current
            };    
        }
        

        $scope.hasChanges = function() {
            return !angular.equals($scope.profile.original, $scope.profile.current);
        };

        $scope.navigateBack = function () {
            routeService.go("main.home");
        };

        $scope.cancel = function() {
            $ionicPopup.confirm({ title: "Cancel", template: "Are you sure you want to cancel unsaved changes?" })
                .then(res => res ? init() : null);
        };

        $scope.saveProfile = function () {
            fsUserProfileService.saveUserProfile($scope.profile.current)
                .then(() => $ionicPopup.alert({ title: "Success", template: "Profile Saved Successfully" }))
                .then(init);
        };

        init();

    }]);

})(angular);;
(function (angular, _) {
    "use strict";

    function fsUserProfileService(routeService, securityService, associationConstants, $q) {
        //#region Utils
        const config = {
            facilities: {
                available: "sync.availablefacilities",
                selected: "sync.facilities"
            },
            secondorgid: "sync.secondaryorg",
            secondsiteid: "sync.secondarysite"
        };
        //#endregion

        //#region Public methods

        /**
         * Redirects the user to first solar's userprofile screen.
         * 
         * @param {Object} menuleaf clicked menu item
         * @returns {Promise<$state>} 
         */
        function goToMyProfile(menuleaf) {
            return routeService.go("main.firstsolar.userprofile");
        }

        /**
         * Builds a viewmodel-friendly object from the curent user.
         * 
         * @returns {Object} 
         */
        function getUserProfileViewModel() {
            const user = securityService.currentFullUser();

            const userVm = {
                personid: user["PersonId"],
                username: user["UserName"],
                siteid: user["SiteId"],
                orgid: user["OrgId"]
            };

            if (!user.properties || !user.properties[config.facilities.available] || !user.properties[config.facilities.selected]) {
                return userVm;
            }

            const availableFacilities = user.properties[config.facilities.available].map(f => f.toUpperCase());
            const selectedFacilities = user.properties[config.facilities.selected].map(f => f.toUpperCase());

            const facilityOptions = _.chain(availableFacilities)
                .map(f => new associationConstants.Option(f).setChecked(_.contains(selectedFacilities, f)))
                .sortBy("value")
                .value();

            userVm.facilities = {
                options: facilityOptions,
                selected: selectedFacilities.join(";")
            }

            userVm.secondorgid = user.properties[config.secondorgid];
            userVm.secondsiteid = user.properties[config.secondsiteid];
            
            return userVm;
        }

        /**
         * Updates the selected facilities for the user.
         * 
         * @param {Object} userViewModel 
         * @returns {Promise<Void>} 
         */
        function saveUserProfile(userViewModel) {
            const selectedFacilities = userViewModel.facilities.options.filter(f => f.checked).map(f => f.value);
            const properties = { [config.facilities.selected]: selectedFacilities };
            return $q.when(securityService.updateCurrentUserProperties(properties));
        }

        //#endregion

        //#region Service Instance
        const service = {
            goToMyProfile,
            getUserProfileViewModel,
            saveUserProfile
        };
        return service;
        //#endregion
    }

    //#region Service registration

    angular.module("sw_mobile_services").service("fsUserProfileService", ["routeService", "securityService", "associationConstants", "$q", fsUserProfileService]);

    //#endregion

})(angular, _);;
(function (angular) {
    "use strict";

    const day = 24 * 60 * 60 * 1000;

    class gricWorkorderOfflineService {

        constructor() {
        }


        //#region Menu whereclauses
        // dateindex01 = scheduled start date
        getTodayWosWhereClause() {
            const now = new Date();
            const todayTime = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0).getTime();
            const tomorrowTime = todayTime + day;
            return `\`root\`.dateindex01 >= ${todayTime} and 'root'.dateindex01 < ${tomorrowTime}`;
        }

        // workorder.dateindex01 = scheduled start date
        getPastWosWhereClause() {
            const now = new Date();
            const todayTime = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0).getTime();
            return `\`root\`.dateindex01 < ${todayTime}`;
        }

        // workorder.dateindex01 = scheduled start date
        getFutureWosWhereClause() {
            const now = new Date();
            const tomorrowTime = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0).getTime() + day;
            return `\`root\`.dateindex01 >= ${tomorrowTime}`;
        }
        //#endregion
    }

    gricWorkorderOfflineService["$inject"] = [];

    angular.module("maximo_offlineapplications").service("gricWorkorderOfflineService", gricWorkorderOfflineService);
})(angular);
//# sourceMappingURL=app.js.map